
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>네온 서바이버</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      font-family: 'Orbitron', sans-serif;
      overflow: hidden;
      background-color: #0d0221;
      color: white;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      margin: 0;
      padding: 1rem;
      touch-action: none;
    }
    .game-container {
      background: #0a0a1f;
      border: 2px solid #00ffff;
      box-shadow: 0 0 20px #00ffff, inset 0 0 20px #00ffff;
      width: 90vmin;
      aspect-ratio: 4 / 3;
      touch-action: none;
    }
    #game-canvas {
      background-color: #0d0221;
      cursor: none;
      width: 100%;
      height: 100%;
      display: block;
    }
    .text-glow {
      color: #fff;
      text-shadow: 0 0 7px #fff, 0 0 10px #fff, 0 0 21px #ff00ff, 0 0 42px #ff00ff;
    }
    .button-retro {
      background-color: transparent;
      border: 2px solid #fff;
      color: #fff;
      padding: 0.75rem 1.5rem;
      text-transform: uppercase;
      letter-spacing: 2px;
      transition: all 0.2s ease-in-out;
      text-shadow: 0 0 8px #ff00ff;
      cursor: pointer;
    }
    .button-retro:hover:not(:disabled) {
      background-color: #fff;
      color: #0d0221;
      box-shadow: 0 0 20px #fff, 0 0 30px #ff00ff;
    }
    .button-retro:disabled {
        cursor: not-allowed;
        opacity: 0.5;
    }
    .selection-button {
        border-width: 2px;
        border-color: #fff;
        background-color: transparent;
        padding: 0.5rem;
        height: 100%;
        font-size: 0.875rem;
    }
    .selection-button.selected {
        background-color: #00ffff;
        color: #0d0221;
        box-shadow: 0 0 20px #00ffff;
    }
    .upgrade-card {
      border: 2px solid #00ffff;
      background: rgba(13, 2, 33, 0.8);
      transition: all 0.2s ease-in-out;
      cursor: pointer;
    }
    .upgrade-card:hover {
      background: rgba(0, 255, 255, 0.2);
      box-shadow: 0 0 15px #00ffff;
      transform: translateY(-5px);
    }
    .overlay {
        position: absolute;
        inset: 0;
        background-color: rgba(0,0,0,0.85);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
        z-index: 10;
        padding: 1rem;
    }
    .hidden {
        display: none;
    }
    #start-button {
        padding: 1rem 2rem;
        font-size: 1.25rem;
        font-weight: bold;
    }
    @keyframes pulse-glow {
        0% {
            transform: scale(1);
            box-shadow: 0 0 15px #00ffff, 0 0 25px #ff00ff;
        }
        50% {
            transform: scale(1.08);
            box-shadow: 0 0 30px #00ffff, 0 0 50px #ff00ff;
        }
        100% {
            transform: scale(1);
            box-shadow: 0 0 15px #00ffff, 0 0 25px #ff00ff;
        }
    }

    #start-button:not(:disabled) {
        border-color: #00ffff;
        color: #00ffff;
        text-shadow: 0 0 8px #00ffff;
        animation: pulse-glow 2s infinite ease-in-out;
    }
    .joystick {
        position: absolute;
        width: 80px;
        height: 80px;
        pointer-events: none;
    }
    .joystick-base {
        position: absolute;
        width: 100%;
        height: 100%;
        border-radius: 50%;
        background-color: rgba(0, 255, 255, 0.1);
        border: 2px solid rgba(0, 255, 255, 0.4);
        box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        transition: transform 0.1s ease-out, background-color 0.1s, border-color 0.1s;
    }
    .joystick-handle {
        position: absolute;
        width: 40px;
        height: 40px;
        top: 20px;
        left: 20px;
        border-radius: 50%;
        background-color: rgba(0, 255, 255, 0.3);
        border: 2px solid rgba(0, 255, 255, 0.8);
        box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
        transition: transform 0.05s linear, background-color 0.1s, border-color 0.1s;
    }
    .joystick.active .joystick-base {
        transform: scale(1.1);
        background-color: rgba(0, 255, 255, 0.2);
        border-color: rgba(0, 255, 255, 0.8);
    }
    .joystick.active .joystick-handle {
        background-color: rgba(0, 255, 255, 0.6);
        border-color: #fff;
    }
    .stat {
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }
    .stat-label {
        width: 60px;
        text-align: right;
        font-size: 0.8rem;
        color: #a7a7a7;
        flex-shrink: 0;
    }
    .stat-bar-bg {
        flex-grow: 1;
        height: 10px;
        background-color: rgba(0, 50, 50, 0.5);
        border: 1px solid #00ffff;
        border-radius: 5px;
        padding: 1px;
    }
    .stat-bar-fill {
        height: 100%;
        background: linear-gradient(90deg, #ff00ff, #00ffff);
        border-radius: 3px;
        box-shadow: 0 0 5px #00ffff;
        transition: width 0.3s ease-out;
    }
  </style>
</head>
<body>

  <main class="flex flex-col items-center">
    <div class="flex justify-between w-full mb-2 px-2 text-glow" style="max-width: 90vmin;">
        <div class="flex gap-4 items-center">
            <div id="level-ui" class="text-xl">레벨: 1</div>
            <div id="current-rank-ui" class="text-lg"></div>
        </div>
        <div class="flex flex-col items-center">
            <div id="timer-ui" class="text-2xl font-bold">00:00</div>
            <div id="combo-ui" class="text-xl font-bold text-yellow-400 h-6" style="text-shadow: 0 0 8px #facc15;"></div>
        </div>
        <div id="highscore-ui" class="text-xl text-right">최고기록: 00:00</div>
    </div>
    
    <div class="w-full h-8 mb-2 flex flex-col justify-around" style="max-width: 90vmin;">
        <div class="w-full bg-gray-700 h-3 rounded-full overflow-hidden border border-red-500">
            <div id="hp-bar" class="bg-red-500 h-full" style="width: 100%"></div>
        </div>
        <div class="w-full bg-gray-700 h-3 rounded-full overflow-hidden border border-cyan-400">
            <div id="xp-bar" class="bg-cyan-400 h-full" style="width: 0%"></div>
        </div>
    </div>

    <div id="game-wrapper" class="relative rounded-lg overflow-hidden game-container">
      <canvas id="game-canvas" width="800" height="600"></canvas>
      <button id="pause-button" class="absolute top-2 right-2 text-2xl w-12 h-12 button-retro hidden items-center justify-center" style="padding: 0;">||</button>
      
      <div id="movement-joystick" class="joystick hidden">
        <div class="joystick-base"></div>
        <div class="joystick-handle"></div>
      </div>
      
      <div id="start-screen" class="overlay">
          <div class="absolute top-4 left-4 text-xs text-gray-500">제작자: 한국인이라면</div>
          <h1 class="text-5xl md:text-6xl font-bold mb-4 text-glow">네온 서바이버</h1>
          <div id="start-screen-highscore" class="text-xl mb-8 text-glow"></div>
          
          <div class="w-full max-w-2xl">
            <h2 class="text-xl mb-2 text-glow">난이도 선택</h2>
            <div id="difficulty-selection" class="grid grid-cols-3 gap-2 mb-4">
                <button class="button-retro selection-button" data-difficulty="쉬움">쉬움</button>
                <button class="button-retro selection-button selected" data-difficulty="보통">보통</button>
                <button class="button-retro selection-button" data-difficulty="어려움">어려움</button>
            </div>
          </div>

          <div class="w-full max-w-2xl mt-4">
              <h2 class="text-xl mb-2 text-glow">무기 선택</h2>
              <div id="weapon-selection" class="grid grid-cols-4 gap-2 mb-2">
                  <button class="button-retro selection-button selected" data-weapon="machine-gun">기관총</button>
                  <button class="button-retro selection-button" data-weapon="missile">유도 미사일</button>
                  <button class="button-retro selection-button" data-weapon="bomb">폭탄</button>
                  <button class="button-retro selection-button" data-weapon="laser">레이저</button>
                  <button class="button-retro selection-button" data-weapon="bow">활</button>
                  <button class="button-retro selection-button" data-weapon="chain-lightning">연쇄 번개</button>
                  <button class="button-retro selection-button" data-weapon="black-hole-generator">블랙홀</button>
                  <button class="button-retro selection-button" data-weapon="plasma-cannon">플라즈마</button>
                  <button class="button-retro selection-button" data-weapon="ricochet-blade">리코</button>
                  <button class="button-retro selection-button" data-weapon="vortex-cannon">볼텍스 캐논</button>
                  <button class="button-retro selection-button" data-weapon="glitch-pulser">글리치 펄서</button>
                  <button class="button-retro selection-button" data-weapon="cryo-gun">크라이오건</button>
              </div>
          </div>

          <button id="start-button" class="button-retro mt-8" disabled>게임 시작</button>
      </div>

      <div id="pause-screen" class="overlay hidden">
          <h2 class="text-6xl font-bold mb-8 text-glow">일시정지</h2>
          <div class="flex flex-col gap-4 w-64">
              <button id="resume-button" class="button-retro">계속하기</button>
              <button id="restart-pause-button" class="button-retro">다시 시작</button>
              <button id="quit-button" class="button-retro">그만하기</button>
          </div>
      </div>

      <div id="levelup-screen" class="overlay hidden">
          <h2 class="text-5xl font-bold mb-8 text-glow">레벨 업!</h2>
          <div id="levelup-options" class="grid grid-cols-1 md:grid-cols-3 gap-6">
              <!-- Upgrade cards will be injected here -->
          </div>
      </div>

      <div id="gameover-screen" class="overlay hidden">
          <h2 class="text-6xl font-bold mb-4 text-glow">게임 오버</h2>
          <p id="gameover-time" class="text-3xl mb-2">생존 시간: 00:00</p>
          <p id="gameover-rank" class="text-2xl mb-6"></p>
          <p id="gameover-highscore" class="text-xl mb-8">최고 기록: 00:00</p>
          <button id="restart-button" class="button-retro">새로 시작</button>
      </div>
    </div>
  </main>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- DOM Elements ---
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    const gameWrapper = document.getElementById('game-wrapper');
    const startScreen = document.getElementById('start-screen');
    const pauseScreen = document.getElementById('pause-screen');
    const levelUpScreen = document.getElementById('levelup-screen');
    const gameOverScreen = document.getElementById('gameover-screen');
    const startButton = document.getElementById('start-button');
    const restartButton = document.getElementById('restart-button');
    const pauseButton = document.getElementById('pause-button');
    const levelUpOptionsContainer = document.getElementById('levelup-options');
    const weaponSelection = document.getElementById('weapon-selection');
    const difficultySelection = document.getElementById('difficulty-selection');
    const resumeButton = document.getElementById('resume-button');
    const restartPauseButton = document.getElementById('restart-pause-button');
    const quitButton = document.getElementById('quit-button');

    // Joystick UI
    const movementJoystickUI = document.getElementById('movement-joystick');
    const movementJoystickHandle = movementJoystickUI.querySelector('.joystick-handle');
    
    // UI Elements
    const levelUI = document.getElementById('level-ui');
    const timerUI = document.getElementById('timer-ui');
    const comboUI = document.getElementById('combo-ui');
    const highscoreUI = document.getElementById('highscore-ui');
    const hpBar = document.getElementById('hp-bar');
    const xpBar = document.getElementById('xp-bar');
    const gameOverTimeUI = document.getElementById('gameover-time');
    const gameOverRankUI = document.getElementById('gameover-rank');
    const gameOverHighscoreUI = document.getElementById('gameover-highscore');
    const startScreenHighscoreUI = document.getElementById('start-screen-highscore');
    const currentRankUI = document.getElementById('current-rank-ui');

    // --- Game Constants ---
    const CANVAS_WIDTH = 800;
    const CANVAS_HEIGHT = 600;
    const PLAYER_SIZE = 20;
    const COMBO_TIMEOUT = 2500;

    // --- Ranking System ---
    const RANKS = [
        { name: '네온 초심자', threshold: 0, color: '#9ca3af' },
        { name: '그리드 러너', threshold: 60, color: '#6ee7b7' },
        { name: '서킷 브레이커', threshold: 120, color: '#60a5fa' },
        { name: '데이터 스트리머', threshold: 180, color: '#c084fc' },
        { name: '사이버 검투사', threshold: 240, color: '#f87171' },
        { name: '신스웨이브 파수꾼', threshold: 300, color: '#facc15' },
        { name: '디지털 오버로드', threshold: 420, color: '#f472b6' },
        { name: '코드 아크마스터', threshold: 600, color: '#00ffff' },
        { name: '매트릭스 군주', threshold: 900, color: '#ffffff' }
    ];

    function getRank(seconds) {
        let currentRank = RANKS[0];
        for (const rank of RANKS) {
            if (seconds >= rank.threshold) {
                currentRank = rank;
            } else {
                break;
            }
        }
        return currentRank;
    }
    
    // --- Enemy Types ---
    const ENEMY_TYPES = {
        'grunt': { size: 15, hp: 10, speed: 70, color: '#ff4d4d', xp: 1, shape: 'square', damage: 5 },
        'tank': { size: 30, hp: 50, speed: 40, color: '#ff8c66', xp: 5, shape: 'square', damage: 15 },
        'shooter': { size: 18, hp: 15, speed: 60, color: '#fcf003', xp: 2, shape: 'triangle', damage: 10, fireRate: 2000, projectileSpeed: 150 },
        'bomber': { size: 20, hp: 20, speed: 80, color: '#ff99cc', xp: 3, shape: 'square', damage: 20, onDeath: 'explode' },
        'summoner': { size: 25, hp: 40, speed: 50, color: '#cc99ff', xp: 8, shape: 'triangle', damage: 5, actionRate: 5000, action: 'summon' },
        'boss': { size: 50, hp: 500, speed: 60, color: '#ff0000', xp: 50, shape: 'square', damage: 25, fireRate: 1000, projectileSpeed: 200 },
    };


    // --- Game Configs ---
    const DIFFICULTY_SETTINGS = {
        '쉬움': { hp: 120, enemyHpMult: 0.7, enemySpeedMult: 0.8, spawnRateMult: 1.2 },
        '보통': { hp: 100, enemyHpMult: 1.0, enemySpeedMult: 1.0, spawnRateMult: 1.0 },
        '어려움': { hp: 80, enemyHpMult: 1.5, enemySpeedMult: 1.2, spawnRateMult: 0.8 },
    };
    const WEAPON_SETTINGS = {
        'machine-gun': { fireRate: 400, damage: 12, projectileType: 'bullet', name: '기관총', knockback: 20, description: '가장 균형잡힌 무기. 8발마다 강력한 넉백탄 발사!' },
        'missile': { fireRate: 1000, damage: 40, projectileType: 'missile', name: '유도 미사일', explosionRadius: 70, description: '가장 가까운 적을 추적하며 넓은 범위에 폭발 피해를 줍니다.' },
        'bomb': { fireRate: 800, damage: 25, projectileType: 'bomb', name: '폭탄', shrapnelCount: 5, description: '포물선으로 날아가 폭발하며 5개의 파편을 흩뿌립니다.' },
        'laser': { fireRate: 1200, damage: 45, projectileType: 'laser', name: '레이저', slowAmount: 0.5, slowDuration: 1000, description: '적을 관통하며 1초간 이동 속도를 50% 감소시킵니다.' },
        'bow': { fireRate: 600, damage: 25, projectileType: 'arrow', name: '활', critChance: 0.15, critMultiplier: 2, description: '적을 관통하며 15% 확률로 2배의 치명타 피해를 입힙니다.' },
        'chain-lightning': { fireRate: 800, damage: 30, projectileType: 'lightning', name: '연쇄 번개', bounces: 4, description: '적들 사이를 4번 튕기는 번개를 발사합니다.' },
        'black-hole-generator': { fireRate: 2000, damage: 0, projectileType: 'black-hole-orb', name: '블랙홀 생성기', description: '적을 끌어당기고 지속 피해를 주는 소형 블랙홀을 발사합니다.' },
        'plasma-cannon': { fireRate: 1800, damage: 50, projectileType: 'plasma-ball', name: '플라즈마 캐논', explosionRadius: 80, burnDamage: 10, burnDuration: 3000, description: '느리지만 강력한 플라즈마 구체를 발사합니다. 구체는 폭발하며 3초간 화상 피해를 입힙니다.' },
        'ricochet-blade': { fireRate: 750, damage: 20, projectileType: 'ricochet-blade', name: '리코셰 블레이드', bounces: 3, description: '적에게 튕기는 회전 칼날을 발사하여 최대 4명의 적을 공격합니다.' },
        'vortex-cannon': { fireRate: 2200, damage: 10, projectileType: 'vortex-orb', name: '볼텍스 캐논', description: '적을 끌어당기며 지속 피해를 주는 소용돌이를 생성하는 구체를 발사합니다.' },
        'glitch-pulser': { fireRate: 900, damage: 15, projectileType: 'glitch-pulse', name: '글리치 펄서', stunChance: 0.2, stunDuration: 1000, description: '짧은 거리의 적들을 관통하는 에너지 파동을 방출합니다. 피격된 적은 확률적으로 잠시 기절합니다.' },
        'cryo-gun': { fireRate: 850, damage: 18, projectileType: 'cryo-shard', name: '크라이오건', slowAmount: 0.4, slowDuration: 1500, freezeOnNthShot: 5, freezeDuration: 1000, description: '적을 느리게 만드는 얼음 파편을 발사합니다. 5번째 공격마다 적을 잠시 얼립니다.'}
    };
   
    // --- Audio ---
    let audioContext;
    try { audioContext = new (window.AudioContext || window.webkitAudioContext)(); }
    catch (e) { console.error("Web Audio API is not supported in this browser"); }

    function playSound(type, frequency, duration, volume = 0.3) {
        if (!audioContext) return;
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        oscillator.type = type;
        oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
        gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.00001, audioContext.currentTime + duration);
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + duration);
    }
    const sounds = {
        hit: () => playSound('square', 150, 0.1, 0.2),
        shoot: () => playSound('triangle', 440, 0.05, 0.1),
        xp: () => playSound('sine', 600, 0.1, 0.2),
        levelUp: () => playSound('sine', 880, 0.4),
        heal: () => playSound('sine', 700, 0.3),
        dash: () => playSound('sine', 300, 0.2, 0.4),
        explosion: () => playSound('sine', 50, 0.3, 0.5),
        nuke: () => playSound('sine', 100, 1.0, 0.8),
        powerup: () => playSound('sine', 900, 0.2),
        freeze: () => playSound('sawtooth', 200, 0.5, 0.4),
        shieldUp: () => playSound('sine', 1000, 0.2, 0.5),
        shieldDown: () => playSound('square', 100, 0.2, 0.5),
        blackHole: () => playSound('noise', 100, 2, 0.4),
        summon: () => playSound('sine', 500, 0.3, 0.2),
    };
    
    // --- Game State ---
    let gameState = 'start';
    let isPaused = false;
    let selectedDifficulty, selectedWeapon;
    let player, enemies, projectiles, enemyProjectiles, xpGems, itemPickups, explosions;
    let orbitalShields, speedBoosts, fireRateBoosts, freezeBombs, invincibilityShields, blackHoleItems;
    let drones, explosiveBarrels, blackHoles, vortexes;
    let holographicDecoys, decoys;
    let magnets, xpBombs;
    let damageTexts, nukeEffect;
    let timer, gameTime, lastTime, animationFrameId;
    let lastSpawnTime, spawnInterval, lastItemSpawnTime, itemSpawnInterval;
    let bossSpawned, enemiesFrozen, enemiesFrozenTimer;
    let mousePos = { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2 };
    let keysPressed = {};
    let highScore = Number(localStorage.getItem('neonSurvivorHighScore') || 0);
    let comboCount, lastKillTime;

    // Joystick State
    const JOYSTICK_BASE_RADIUS = 40;
    const JOYSTICK_MAX_OFFSET = JOYSTICK_BASE_RADIUS - 20;
    const JOYSTICK_DEAD_ZONE = 5;
    let movementJoystickState = { active: false, x: 0, y: 0, dx: 0, dy: 0, touchId: null, startTime: 0, startX: 0, startY: 0 };


    // --- Upgrades ---
    const UPGRADES = [
        { id: 'firerate', title: "연사력 강화", description: "공격 속도 20% 증가", apply: p => { p.baseFireRate *= 0.8; p.fireRate = p.baseFireRate;} },
        { id: 'damage', title: "강화 탄환", description: "공격력 25% 증가", apply: p => p.projectileDamage *= 1.25 },
        { id: 'multishot', title: "멀티샷", description: "발사체 수 +1", apply: p => p.projectiles++ },
        { id: 'hp', title: "나노 수리봇", description: "최대 체력 20 증가 및 모두 회복", apply: p => { p.maxHp += 20; p.hp = p.maxHp; } },
        { id: 'speed', title: "고속 추진기", description: "이동 속도 10% 증가", apply: p => { p.baseSpeed *= 1.1; p.speed = p.baseSpeed; } },
        { id: 'shield', title: '궤도 방패', description: '주위를 도는 방패 추가', apply: p => p.shields++ },
        { id: 'explosive', title: '폭발탄', description: '탄환이 명중 시 폭발합니다', apply: p => p.explosiveProjectiles = true },
        { id: 'magnet', title: '경험치 자석', description: '경험치 획득 범위 50% 증가', apply: p => p.pickupRadius *= 1.5 },
        { id: 'drone', title: '컴패니언 드론', description: '플레이어를 돕는 공격 드론을 추가합니다.', apply: p => p.drones = (p.drones || 0) + 1 },
        { id: 'regeneration', title: '나노 재생 갑옷', description: '초당 최대 체력의 1%를 회복합니다.', apply: p => p.regeneration = (p.regeneration || 0) + (p.maxHp * 0.01) },
        { id: 'thorns', title: '에너지 가시', description: '플레이어에게 닿는 적에게 20의 피해를 입힙니다.', apply: p => p.thornsDamage = (p.thornsDamage || 0) + 20 },
        { id: 'chain-reaction', title: '연쇄 폭발', description: '적이 죽을 때 15% 확률로 폭발하여 주변에 피해를 줍니다.', apply: p => p.chainReactionChance = (p.chainReactionChance || 0) + 0.15 }
    ];
    let availableUpgrades = [...UPGRADES];
    
    function createInitialPlayer(difficulty, weapon) {
        const difficultySettings = DIFFICULTY_SETTINGS[difficulty];
        const weaponSettings = WEAPON_SETTINGS[weapon];
        
        return {
            x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2,
            hp: difficultySettings.hp, maxHp: difficultySettings.hp,
            xp: 0, level: 1, xpToNextLevel: 10,
            weaponType: weapon,
            fireRate: weaponSettings.fireRate, baseFireRate: weaponSettings.fireRate,
            projectiles: 1, projectileDamage: weaponSettings.damage, projectileType: weaponSettings.projectileType,
            lastShotTime: 0, speed: 220, baseSpeed: 220, pickupRadius: 100,
            dashCooldown: 2000, lastDashTime: 0, isDashing: false, dashDuration: 150, dashSpeed: 750,
            shields: 1, // Start with 1 shield by default
            explosiveProjectiles: false,
            speedBoostTimer: 0, fireRateBoostTimer: 0, invincibilityTimer: 0, magnetTimer: 0,
            drones: 0,
            machineGunShotCount: 0,
            cryoGunShotCount: 0,
            decoyCharges: 0,
            regeneration: 0,
            thornsDamage: 0,
            chainReactionChance: 0,
        };
    }

    function formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
    }

    function togglePause() {
        if (gameState !== 'playing' || levelUpScreen.style.display === 'flex') return;
        isPaused = !isPaused;
        pauseScreen.classList.toggle('hidden', !isPaused);
        if (isPaused) {
            cancelAnimationFrame(animationFrameId);
        } else {
            lastTime = performance.now();
            requestAnimationFrame(gameLoop);
        }
    }

    function selectUpgrade(upgrade) {
        upgrade.apply(player);
        availableUpgrades = availableUpgrades.filter(u => u.id !== upgrade.id && u.id !== 'multishot');
        levelUpScreen.classList.add('hidden');
        isPaused = false;
        gameState = 'playing';
        lastTime = performance.now();
        requestAnimationFrame(gameLoop);
    }

    function levelUp() {
        isPaused = true;
        gameState = 'levelup';
        sounds.levelUp();
        
        levelUpOptionsContainer.innerHTML = '';
        const selectedUpgrades = [];
        const tempUpgrades = [...availableUpgrades];
        
        for (let i = 0; i < 3 && tempUpgrades.length > 0; i++) {
            const randomIndex = Math.floor(Math.random() * tempUpgrades.length);
            selectedUpgrades.push(tempUpgrades[randomIndex]);
            tempUpgrades.splice(randomIndex, 1);
        }

        selectedUpgrades.forEach(upgrade => {
            const card = document.createElement('div');
            card.className = 'upgrade-card p-4 rounded-lg flex flex-col items-center justify-center text-center';
            card.innerHTML = `
                <h3 class="text-xl font-bold mb-2 text-glow">${upgrade.title}</h3>
                <p>${upgrade.description}</p>
            `;
            card.onclick = () => selectUpgrade(upgrade);
            levelUpOptionsContainer.appendChild(card);
        });

        levelUpScreen.classList.remove('hidden');
    }
    
    function collectXP(amount) {
        sounds.xp();
        player.xp += amount;
        if (player.xp >= player.xpToNextLevel) {
            player.level++;
            player.xp -= player.xpToNextLevel;
            player.xpToNextLevel = Math.floor(player.xpToNextLevel * 1.5);
            levelUI.textContent = `레벨: ${player.level}`;
            levelUp();
        }
    }
    
    function createDamageText(text, x, y, isCrit = false) {
        damageTexts.push({
            text, x, y,
            alpha: 1,
            timer: 0,
            color: isCrit ? '255, 255, 0' : '255, 255, 255'
        });
    }

    function takeDamage(entity, amount) {
        entity.hp -= amount;
        if (entity.hp <= 0) {
            entity.hp = 0;
        }

        if (entity === player) {
             if (player.invincibilityTimer > 0) return;
             
             if (player.shields > 0) {
                 player.shields--;
                 player.invincibilityTimer = 1000;
                 sounds.shieldDown();
                 return;
             }
            sounds.hit();
        } else {
            createDamageText(String(Math.floor(amount)), entity.x, entity.y, false);
        }
    }
    
    function getSpawnPosition() {
        let x, y;
        const edge = Math.floor(Math.random() * 4);
        if (edge === 0) { // Top
            x = Math.random() * CANVAS_WIDTH;
            y = -30;
        } else if (edge === 1) { // Right
            x = CANVAS_WIDTH + 30;
            y = Math.random() * CANVAS_HEIGHT;
        } else if (edge === 2) { // Bottom
            x = Math.random() * CANVAS_WIDTH;
            y = CANVAS_HEIGHT + 30;
        } else { // Left
            x = -30;
            y = Math.random() * CANVAS_HEIGHT;
        }
        return { x, y };
    }

    function spawnEnemy() {
        if (enemies.length > 150) return;
        
        const { x, y } = getSpawnPosition();
        let enemyType = 'grunt';
        
        const timeFactor = Math.min(gameTime / 180, 1); // Cap difficulty increase at 3 minutes
        const rand = Math.random();

        if (gameTime > 60 && rand < 0.1 + timeFactor * 0.2) {
            enemyType = 'summoner';
        } else if (gameTime > 45 && rand < 0.2 + timeFactor * 0.2) {
            enemyType = 'bomber';
        } else if (gameTime > 30 && rand < 0.4 + timeFactor * 0.2) {
            enemyType = 'shooter';
        } else if (gameTime > 15 && rand < 0.6 + timeFactor * 0.2) {
            enemyType = 'tank';
        }

        const base = ENEMY_TYPES[enemyType];
        const finalHp = base.hp * DIFFICULTY_SETTINGS[selectedDifficulty].enemyHpMult * (1 + gameTime / 120);
        const finalSpeed = base.speed * DIFFICULTY_SETTINGS[selectedDifficulty].enemySpeedMult;
        
        enemies.push({ 
            ...base, 
            x, y, 
            hp: finalHp, 
            maxHp: finalHp, 
            speed: finalSpeed, 
            lastActionTime: 0,
            slowTimer: 0,
            freezeTimer: 0,
            burnTimer: 0,
            burnDamage: 0
        });
    }
    
    function spawnItem() {
        const ITEM_TYPES = ['health', 'speed', 'firerate', 'invincibility', 'magnet', 'nuke'];
        const type = ITEM_TYPES[Math.floor(Math.random() * ITEM_TYPES.length)];
        const x = Math.random() * (CANVAS_WIDTH - 60) + 30;
        const y = Math.random() * (CANVAS_HEIGHT - 60) + 30;
        itemPickups.push({ x, y, type, lifetime: 10000 });
    }

    function spawnBoss() {
        if (bossSpawned) return;
        bossSpawned = true;
        const { x, y } = getSpawnPosition();
        const base = ENEMY_TYPES['boss'];
        const finalHp = base.hp * DIFFICULTY_SETTINGS[selectedDifficulty].enemyHpMult;
        enemies.push({ ...base, x, y, hp: finalHp, maxHp: finalHp, lastActionTime: 0 });
    }
    
    function shoot(targetX, targetY) {
        if (performance.now() - player.lastShotTime < player.fireRate) return;
        player.lastShotTime = performance.now();
        sounds.shoot();

        const weapon = WEAPON_SETTINGS[player.weaponType];
        
        for (let i = 0; i < player.projectiles; i++) {
            let angle = Math.atan2(targetY - player.y, targetX - player.x);
            if (player.projectiles > 1) {
                angle += (i - (player.projectiles - 1) / 2) * 0.2;
            }
            
            let projectileSpeed = 300;
            let lifetime = 2000;
            
            const projectile = {
                x: player.x,
                y: player.y,
                damage: player.projectileDamage,
                type: player.projectileType,
                owner: 'player',
                lifetime: lifetime,
                explosive: player.explosiveProjectiles,
                explosionRadius: 50,
            };
            
            switch (player.projectileType) {
                case 'missile':
                    projectile.vx = Math.cos(angle) * 150;
                    projectile.vy = Math.sin(angle) * 150;
                    projectile.target = enemies.length > 0 ? enemies.reduce((closest, e) => {
                        const dist = Math.hypot(e.x - player.x, e.y - player.y);
                        return dist < closest.dist ? { dist, e } : closest;
                    }, { dist: Infinity, e: null }).e : null;
                    projectile.explosionRadius = weapon.explosionRadius;
                    break;
                case 'laser':
                    projectile.vx = Math.cos(angle) * 600;
                    projectile.vy = Math.sin(angle) * 600;
                    projectile.lifetime = 1200;
                    projectile.pierce = true;
                    projectile.slowAmount = weapon.slowAmount;
                    projectile.slowDuration = weapon.slowDuration;
                    break;
                case 'arrow':
                    projectile.vx = Math.cos(angle) * 450;
                    projectile.vy = Math.sin(angle) * 450;
                    projectile.pierce = true;
                    projectile.critChance = weapon.critChance;
                    projectile.critMultiplier = weapon.critMultiplier;
                    break;
                case 'lightning':
                    projectile.target = enemies.length > 0 ? enemies[Math.floor(Math.random() * enemies.length)] : null;
                    projectile.bouncesLeft = weapon.bounces;
                    projectile.bounceRange = 150;
                    projectile.hitEnemies = new Set();
                    if (!projectile.target) return;
                    break;
                 case 'black-hole-orb':
                    projectile.vx = Math.cos(angle) * 100;
                    projectile.vy = Math.sin(angle) * 100;
                    projectile.lifetime = 3000;
                    break;
                case 'plasma-ball':
                    projectile.vx = Math.cos(angle) * 120;
                    projectile.vy = Math.sin(angle) * 120;
                    projectile.lifetime = 4000;
                    projectile.explosionRadius = weapon.explosionRadius;
                    projectile.burnDamage = weapon.burnDamage;
                    projectile.burnDuration = weapon.burnDuration;
                    break;
                 case 'ricochet-blade':
                    projectile.vx = Math.cos(angle) * 250;
                    projectile.vy = Math.sin(angle) * 250;
                    projectile.angularVelocity = 10;
                    projectile.rotation = 0;
                    projectile.bouncesLeft = weapon.bounces;
                    projectile.bounceRange = 200;
                    projectile.hitEnemies = new Set();
                    break;
                case 'vortex-orb':
                    projectile.vx = Math.cos(angle) * 150;
                    projectile.vy = Math.sin(angle) * 150;
                    projectile.lifetime = 2500;
                    break;
                case 'glitch-pulse':
                    projectile.vx = Math.cos(angle) * 400;
                    projectile.vy = Math.sin(angle) * 400;
                    projectile.lifetime = 250;
                    projectile.pierce = true;
                    projectile.width = 40;
                    projectile.stunChance = weapon.stunChance;
                    projectile.stunDuration = weapon.stunDuration;
                    break;
                case 'cryo-shard':
                    player.cryoGunShotCount = (player.cryoGunShotCount || 0) + 1;
                    projectile.vx = Math.cos(angle) * 400;
                    projectile.vy = Math.sin(angle) * 400;
                    projectile.slowAmount = weapon.slowAmount;
                    projectile.slowDuration = weapon.slowDuration;
                    if (player.cryoGunShotCount % weapon.freezeOnNthShot === 0) {
                        projectile.shouldFreeze = true;
                        projectile.freezeDuration = weapon.freezeDuration;
                    }
                    break;
                case 'bullet':
                default:
                    player.machineGunShotCount = (player.machineGunShotCount || 0) + 1;
                    let knockback = 0;
                    if(player.machineGunShotCount % 8 === 0) {
                        knockback = weapon.knockback;
                    }
                    projectile.knockback = knockback;
                    projectile.vx = Math.cos(angle) * projectileSpeed;
                    projectile.vy = Math.sin(angle) * projectileSpeed;
                    break;
            }
            projectiles.push(projectile);
        }
    }
    
    function createExplosion(x, y, radius, damage) {
        if (radius <= 0) return;
        explosions.push({ x, y, radius, maxRadius: radius, duration: 200, timer: 0, damage: damage });
        sounds.explosion();
        // Screen shake
        gameWrapper.style.transform = `translate(${Math.random()*10-5}px, ${Math.random()*10-5}px)`;
        setTimeout(() => gameWrapper.style.transform = '', 100);
    }
    
    function resetCombo() {
        comboCount = 0;
        comboUI.textContent = '';
    }

    // --- Update Functions ---
    
    function updatePlayer(deltaTime) {
        if (player.isDashing) return;

        // Base stats
        player.speed = player.baseSpeed;
        player.fireRate = player.baseFireRate;

        // Apply boosts
        if (player.speedBoostTimer > 0) {
            player.speedBoostTimer -= deltaTime * 1000;
            player.speed *= 1.5;
        }
        if (player.fireRateBoostTimer > 0) {
            player.fireRateBoostTimer -= deltaTime * 1000;
            player.fireRate *= 0.5;
        }
        if (player.invincibilityTimer > 0) {
            player.invincibilityTimer -= deltaTime * 1000;
        }
        if (player.magnetTimer > 0) {
            player.magnetTimer -= deltaTime * 1000;
        }

        // Movement
        let dx = 0;
        let dy = 0;

        if (movementJoystickState.active) {
            dx = movementJoystickState.dx;
            dy = movementJoystickState.dy;
        } else {
            if (keysPressed.w || keysPressed.ArrowUp) dy -= 1;
            if (keysPressed.s || keysPressed.ArrowDown) dy += 1;
            if (keysPressed.a || keysPressed.ArrowLeft) dx -= 1;
            if (keysPressed.d || keysPressed.ArrowRight) dx += 1;
        }

        const len = Math.hypot(dx, dy);
        if (len > 0) {
            dx /= len;
            dy /= len;
            player.x += dx * player.speed * deltaTime;
            player.y += dy * player.speed * deltaTime;
        }

        player.x = Math.max(PLAYER_SIZE / 2, Math.min(CANVAS_WIDTH - PLAYER_SIZE / 2, player.x));
        player.y = Math.max(PLAYER_SIZE / 2, Math.min(CANVAS_HEIGHT - PLAYER_SIZE / 2, player.y));

        // Auto-shooting
        let closestEnemy = null;
        let minDistance = Infinity;
        enemies.forEach(enemy => {
            const distance = Math.hypot(enemy.x - player.x, enemy.y - player.y);
            if (distance < minDistance) {
                minDistance = distance;
                closestEnemy = enemy;
            }
        });

        if (closestEnemy) {
            shoot(closestEnemy.x, closestEnemy.y);
        }
        
        // Regeneration
        if (player.regeneration > 0) {
            player.hp = Math.min(player.maxHp, player.hp + player.regeneration * deltaTime);
        }
    }
    
    function updateEnemies(deltaTime) {
        enemies.forEach(enemy => {
            if (enemy.freezeTimer > 0) {
                enemy.freezeTimer -= deltaTime * 1000;
                return;
            }
            if (enemy.stunTimer > 0) {
                enemy.stunTimer -= deltaTime * 1000;
                return;
            }

            let currentSpeed = enemy.speed;
            if (enemy.slowTimer > 0) {
                enemy.slowTimer -= deltaTime * 1000;
                currentSpeed *= enemy.slowAmount;
            }
            if (enemy.burnTimer > 0) {
                enemy.burnTimer -= deltaTime * 1000;
                takeDamage(enemy, enemy.burnDamage * deltaTime);
            }

            const dx = player.x - enemy.x;
            const dy = player.y - enemy.y;
            const dist = Math.hypot(dx, dy);
            
            if (dist > 1) {
                enemy.x += (dx / dist) * currentSpeed * deltaTime;
                enemy.y += (dy / dist) * currentSpeed * deltaTime;
            }

            if (dist < PLAYER_SIZE / 2 + enemy.size / 2) {
                takeDamage(player, enemy.damage);
                if (player.thornsDamage > 0) {
                    takeDamage(enemy, player.thornsDamage);
                }
            }

            // Enemy actions
            if (enemy.fireRate && performance.now() - enemy.lastActionTime > enemy.fireRate) {
                enemy.lastActionTime = performance.now();
                const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                enemyProjectiles.push({
                    x: enemy.x, y: enemy.y,
                    vx: Math.cos(angle) * enemy.projectileSpeed,
                    vy: Math.sin(angle) * enemy.projectileSpeed,
                    size: 8, lifetime: 3000, damage: enemy.damage,
                    owner: 'enemy'
                });
            }
            if (enemy.action === 'summon' && performance.now() - enemy.lastActionTime > enemy.actionRate) {
                enemy.lastActionTime = performance.now();
                sounds.summon();
                for (let i = 0; i < 2; i++) {
                    const gruntBase = ENEMY_TYPES['grunt'];
                    const finalHp = gruntBase.hp * DIFFICULTY_SETTINGS[selectedDifficulty].enemyHpMult * (1 + gameTime / 120);
                    enemies.push({ 
                        ...gruntBase, 
                        x: enemy.x + (Math.random() - 0.5) * 50, 
                        y: enemy.y + (Math.random() - 0.5) * 50, 
                        hp: finalHp, 
                        maxHp: finalHp,
                        speed: gruntBase.speed * DIFFICULTY_SETTINGS[selectedDifficulty].enemySpeedMult,
                        lastActionTime: 0
                    });
                }
            }
        });
    }

    function updateProjectiles(deltaTime) {
        [projectiles, enemyProjectiles].forEach((projArray, arrIndex) => {
            for (let i = projArray.length - 1; i >= 0; i--) {
                const proj = projArray[i];
                proj.lifetime -= deltaTime * 1000;

                if (proj.type === 'missile' && proj.target && proj.target.hp > 0) {
                    const angle = Math.atan2(proj.target.y - proj.y, proj.target.x - proj.x);
                    proj.vx += Math.cos(angle) * 300 * deltaTime;
                    proj.vy += Math.sin(angle) * 300 * deltaTime;
                    const speed = Math.hypot(proj.vx, proj.vy);
                    if (speed > 250) {
                        proj.vx = (proj.vx / speed) * 250;
                        proj.vy = (proj.vy / speed) * 250;
                    }
                } else if (proj.type === 'lightning' && proj.target) {
                    const dx = proj.target.x - proj.x;
                    const dy = proj.target.y - proj.y;
                    const dist = Math.hypot(dx, dy);
                    if (dist < 10) {
                        takeDamage(proj.target, proj.damage);
                        proj.hitEnemies.add(proj.target);
                        if (proj.bouncesLeft > 0) {
                            proj.bouncesLeft--;
                            let nextTarget = null;
                            let minDistance = proj.bounceRange;
                            enemies.forEach(e => {
                                if (!proj.hitEnemies.has(e) && e.hp > 0) {
                                    const d = Math.hypot(e.x - proj.target.x, e.y - proj.target.y);
                                    if (d < minDistance) {
                                        minDistance = d;
                                        nextTarget = e;
                                    }
                                }
                            });
                            if (nextTarget) {
                                proj.target = nextTarget;
                            } else {
                                proj.lifetime = 0;
                            }
                        } else {
                            proj.lifetime = 0;
                        }
                    } else {
                       proj.x += (dx / dist) * 1000 * deltaTime;
                       proj.y += (dy / dist) * 1000 * deltaTime;
                    }
                } else if (proj.type === 'black-hole-orb' || proj.type === 'vortex-orb') {
                    proj.x += proj.vx * deltaTime;
                    proj.y += proj.vy * deltaTime;
                    if (proj.lifetime < 10 && !proj.triggered) {
                        proj.triggered = true;
                        if (proj.type === 'black-hole-orb') {
                            blackHoles.push({ x: proj.x, y: proj.y, radius: 10, maxRadius: 96, lifetime: 5000, pullForce: 250, damage: 15 });
                            sounds.blackHole();
                        } else { // vortex-orb
                            vortexes.push({ x: proj.x, y: proj.y, radius: 10, maxRadius: 100, lifetime: 4000, pullForce: 300, damage: 10, rotation: 0 });
                        }
                    }
                } else {
                    proj.x += proj.vx * deltaTime;
                    proj.y += proj.vy * deltaTime;
                }
                
                if (proj.type === 'ricochet-blade') {
                    proj.rotation += proj.angularVelocity * deltaTime;
                }

                if (proj.lifetime <= 0) {
                    if (proj.type === 'bomb') {
                        const weapon = WEAPON_SETTINGS['bomb'];
                        for (let j = 0; j < weapon.shrapnelCount; j++) {
                            const angle = Math.random() * 2 * Math.PI;
                            projectiles.push({
                                x: proj.x, y: proj.y,
                                vx: Math.cos(angle) * 200, vy: Math.sin(angle) * 200,
                                damage: proj.damage / 2, lifetime: 500, type: 'shrapnel',
                                owner: 'player'
                            });
                        }
                    } else if (proj.type === 'missile' || proj.type === 'plasma-ball') {
                        createExplosion(proj.x, proj.y, proj.explosionRadius, proj.damage);
                        if(proj.type === 'plasma-ball'){
                            enemies.forEach(enemy => {
                                const dist = Math.hypot(enemy.x - proj.x, enemy.y - proj.y);
                                if (dist < proj.explosionRadius) {
                                    enemy.burnTimer = proj.burnDuration;
                                    enemy.burnDamage = proj.burnDamage;
                                }
                            });
                        }
                    }
                    projArray.splice(i, 1);
                    continue;
                }

                if (proj.owner === 'player') {
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        const enemy = enemies[j];
                        if (proj.hitEnemies && proj.hitEnemies.has(enemy)) continue;

                        const dist = Math.hypot(proj.x - enemy.x, proj.y - enemy.y);
                        if (dist < enemy.size / 2) {
                            let finalDamage = proj.damage;
                            let isCrit = false;
                            if (proj.critChance && Math.random() < proj.critChance) {
                                finalDamage *= proj.critMultiplier;
                                isCrit = true;
                            }
                            createDamageText(String(Math.floor(finalDamage)), enemy.x, enemy.y, isCrit);
                            takeDamage(enemy, finalDamage);
                            
                            if (proj.knockback) {
                                const angle = Math.atan2(enemy.y - player.y, enemy.x - player.x);
                                enemy.x += Math.cos(angle) * proj.knockback;
                                enemy.y += Math.sin(angle) * proj.knockback;
                            }
                            if(proj.slowAmount){
                                enemy.slowTimer = proj.slowDuration;
                                enemy.slowAmount = 1 - proj.slowAmount;
                            }
                            if(proj.shouldFreeze){
                                enemy.freezeTimer = proj.freezeDuration;
                                sounds.freeze();
                            }
                            if(proj.stunChance && Math.random() < proj.stunChance) {
                                enemy.stunTimer = proj.stunDuration;
                            }
                            
                            if (proj.type === 'black-hole-orb' || proj.type === 'vortex-orb' || proj.type === 'bomb') {
                                proj.lifetime = 1; // Trigger end-of-life effect on next frame
                            }

                            if (proj.explosive) {
                                createExplosion(proj.x, proj.y, proj.explosionRadius, proj.damage / 2);
                            }
                            
                            if (proj.type === 'ricochet-blade' || proj.type === 'lightning') { // For now, lightning is handled differently
                                if(proj.hitEnemies) proj.hitEnemies.add(enemy);

                                if (proj.bouncesLeft > 0) {
                                    proj.bouncesLeft--;
                                    let nextTarget = null;
                                    let minDistance = proj.bounceRange;
                                    enemies.forEach(e => {
                                        if (!proj.hitEnemies.has(e) && e.hp > 0) {
                                            const d = Math.hypot(e.x - enemy.x, e.y - enemy.y);
                                            if (d < minDistance) {
                                                minDistance = d;
                                                nextTarget = e;
                                            }
                                        }
                                    });
                                    if (nextTarget) {
                                        const angle = Math.atan2(nextTarget.y - proj.y, nextTarget.x - proj.x);
                                        const speed = Math.hypot(proj.vx, proj.vy);
                                        proj.vx = Math.cos(angle) * speed;
                                        proj.vy = Math.sin(angle) * speed;
                                    } else {
                                        projArray.splice(i, 1);
                                    }
                                } else {
                                   projArray.splice(i, 1);
                                }
                            } else if (!proj.pierce) {
                                projArray.splice(i, 1);
                            }
                            
                            break; 
                        }
                    }
                } else { // Enemy projectile
                    const dist = Math.hypot(proj.x - player.x, proj.y - player.y);
                    if (dist < PLAYER_SIZE / 2) {
                        takeDamage(player, proj.damage);
                        projArray.splice(i, 1);
                    }
                }
            }
        });
    }
    
    function applyItemEffect(type) {
        sounds.powerup();
        switch (type) {
            case 'health':
                player.hp = Math.min(player.maxHp, player.hp + player.maxHp * 0.25);
                sounds.heal();
                break;
            case 'speed':
                player.speedBoostTimer = 5000;
                break;
            case 'firerate':
                player.fireRateBoostTimer = 5000;
                break;
            case 'invincibility':
                player.invincibilityTimer = 5000;
                sounds.shieldUp();
                break;
            case 'magnet':
                player.magnetTimer = 8000;
                break;
            case 'nuke':
                enemies.forEach(enemy => {
                    xpGems.push({ x: enemy.x, y: enemy.y, value: enemy.xp });
                });
                enemies.length = 0;
                nukeEffect = { timer: 500, duration: 500 };
                sounds.nuke();
                break;
        }
    }

    function updateItems(deltaTime) {
        // XP Gems
        for (let i = xpGems.length - 1; i >= 0; i--) {
            const gem = xpGems[i];
            const dx = player.x - gem.x;
            const dy = player.y - gem.y;
            const dist = Math.hypot(dx, dy);
            
            const currentPickupRadius = player.pickupRadius * (player.magnetTimer > 0 ? 3 : 1);

            if (dist < currentPickupRadius) {
                gem.x += (dx / dist) * 300 * deltaTime;
                gem.y += (dy / dist) * 300 * deltaTime;
            }
            if (dist < PLAYER_SIZE / 2) {
                collectXP(gem.value);
                xpGems.splice(i, 1);
            }
        }
        
        // Item Pickups
        for (let i = itemPickups.length - 1; i >= 0; i--) {
            const item = itemPickups[i];
            item.lifetime -= deltaTime * 1000;
            if (item.lifetime <= 0) {
                itemPickups.splice(i, 1);
                continue;
            }
            
            const dist = Math.hypot(player.x - item.x, player.y - item.y);
            if (dist < PLAYER_SIZE / 2 + 15) {
                applyItemEffect(item.type);
                itemPickups.splice(i, 1);
            }
        }
    }
    
    function updateBlackHoles(deltaTime) {
        for (let i = blackHoles.length - 1; i >= 0; i--) {
            const bh = blackHoles[i];
            bh.lifetime -= deltaTime * 1000;
            if (bh.lifetime <= 0) {
                blackHoles.splice(i, 1);
                continue;
            }
            if(bh.radius < bh.maxRadius) bh.radius += 50 * deltaTime;
            
            enemies.forEach(enemy => {
                const dx = bh.x - enemy.x;
                const dy = bh.y - enemy.y;
                const dist = Math.hypot(dx, dy);
                if (dist < bh.radius) {
                    enemy.x += (dx / dist) * bh.pullForce * deltaTime;
                    enemy.y += (dy / dist) * bh.pullForce * deltaTime;
                    if(dist < 15) takeDamage(enemy, bh.damage * deltaTime * 5); // Increased damage close to center
                }
            });
        }
    }
    
    function updateVortexes(deltaTime) {
        for (let i = vortexes.length - 1; i >= 0; i--) {
            const vortex = vortexes[i];
            vortex.lifetime -= deltaTime * 1000;
            if (vortex.lifetime <= 0) {
                vortexes.splice(i, 1);
                continue;
            }
             if(vortex.radius < vortex.maxRadius) vortex.radius += 60 * deltaTime;
             vortex.rotation += 2 * deltaTime;

            enemies.forEach(enemy => {
                const dx = vortex.x - enemy.x;
                const dy = vortex.y - enemy.y;
                let dist = Math.hypot(dx, dy);
                if (dist < vortex.radius && dist > 1) {
                    // Pull towards center
                    enemy.x += (dx / dist) * vortex.pullForce * deltaTime;
                    enemy.y += (dy / dist) * vortex.pullForce * deltaTime;
                    
                    // Add rotational velocity
                    const pullAngle = Math.atan2(dy, dx);
                    const rotationalAngle = pullAngle + Math.PI / 2; // Perpendicular to pull direction
                    enemy.x += Math.cos(rotationalAngle) * vortex.pullForce * 0.5 * deltaTime;
                    enemy.y += Math.sin(rotationalAngle) * vortex.pullForce * 0.5 * deltaTime;
                    
                    takeDamage(enemy, vortex.damage * deltaTime);
                }
            });
        }
    }

    function checkCollisions() {
        for (let i = enemies.length - 1; i >= 0; i--) {
            const enemy = enemies[i];
            if (enemy.hp <= 0) {
                 if (player.chainReactionChance > 0 && Math.random() < player.chainReactionChance) {
                    createExplosion(enemy.x, enemy.y, 60, 30);
                }

                xpGems.push({ x: enemy.x, y: enemy.y, value: enemy.xp });
                if (enemy.onDeath === 'explode') {
                    createExplosion(enemy.x, enemy.y, 80, enemy.damage);
                }
                enemies.splice(i, 1);
                comboCount++;
                lastKillTime = performance.now();
            }
        }
    }

    function updateUI() {
        hpBar.style.width = `${(player.hp / player.maxHp) * 100}%`;
        xpBar.style.width = `${(player.xp / player.xpToNextLevel) * 100}%`;
        timerUI.textContent = formatTime(gameTime);
        if (comboCount > 2) {
            comboUI.textContent = `x${comboCount} COMBO`;
        } else {
            comboUI.textContent = '';
        }

        const rank = getRank(gameTime);
        currentRankUI.textContent = rank.name;
        currentRankUI.style.color = rank.color;
        currentRankUI.style.textShadow = `0 0 8px ${rank.color}`;
    }

    function updateHighscoreDisplay() {
        const formattedHighscore = formatTime(highScore);
        highscoreUI.textContent = `최고기록: ${formattedHighscore}`;
        startScreenHighscoreUI.textContent = `최고 기록: ${formattedHighscore}`;
    }

    // --- Draw Functions ---

    function drawPlayer() {
        ctx.save();
        // Invincibility flicker
        if (player.invincibilityTimer > 0) {
            ctx.globalAlpha = 0.5 + Math.sin(performance.now() / 50) * 0.2;
        }

        // Boost auras
        if (player.speedBoostTimer > 0) {
             ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
             ctx.shadowColor = '#ff0';
             ctx.shadowBlur = 20;
             ctx.beginPath();
             ctx.arc(player.x, player.y, PLAYER_SIZE, 0, Math.PI * 2);
             ctx.fill();
        }
        if (player.fireRateBoostTimer > 0) {
             ctx.fillStyle = 'rgba(0, 255, 255, 0.3)';
             ctx.shadowColor = '#0ff';
             ctx.shadowBlur = 20;
             ctx.beginPath();
             ctx.arc(player.x, player.y, PLAYER_SIZE * 1.2, 0, Math.PI * 2);
             ctx.fill();
        }

        ctx.fillStyle = '#00ffff';
        ctx.shadowColor = '#00ffff';
        ctx.shadowBlur = 15;
        ctx.fillRect(player.x - PLAYER_SIZE / 2, player.y - PLAYER_SIZE / 2, PLAYER_SIZE, PLAYER_SIZE);
        
        // Shield
        if (player.shields > 0) {
            const angle = performance.now() / 500;
            for(let i=0; i<player.shields; i++){
                const shieldAngle = angle + (i * (2 * Math.PI / player.shields));
                const x = player.x + Math.cos(shieldAngle) * 40;
                const y = player.y + Math.sin(shieldAngle) * 40;
                ctx.fillStyle = '#f0f';
                ctx.shadowColor = '#f0f';
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.arc(x, y, 8, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        ctx.restore();
    }
    
    function drawEnemies() {
        enemies.forEach(enemy => {
            ctx.save();
            ctx.fillStyle = enemy.freezeTimer > 0 ? '#66ccff' : enemy.color;
            ctx.shadowColor = enemy.freezeTimer > 0 ? '#66ccff' : enemy.color;
            ctx.shadowBlur = 10;
            
            if (enemy.shape === 'triangle') {
                ctx.beginPath();
                ctx.moveTo(enemy.x, enemy.y - enemy.size / 2);
                ctx.lineTo(enemy.x - enemy.size / 2, enemy.y + enemy.size / 2);
                ctx.lineTo(enemy.x + enemy.size / 2, enemy.y + enemy.size / 2);
                ctx.closePath();
                ctx.fill();
            } else { // square
                ctx.fillRect(enemy.x - enemy.size / 2, enemy.y - enemy.size / 2, enemy.size, enemy.size);
            }
            
            // HP bar
            if (enemy.hp < enemy.maxHp) {
                ctx.fillStyle = '#333';
                ctx.fillRect(enemy.x - enemy.size, enemy.y - enemy.size - 10, enemy.size * 2, 5);
                ctx.fillStyle = 'red';
                ctx.fillRect(enemy.x - enemy.size, enemy.y - enemy.size - 10, (enemy.size * 2) * (enemy.hp / enemy.maxHp), 5);
            }
            ctx.restore();
        });
    }

    function drawProjectiles() {
        projectiles.forEach(p => {
            ctx.save();
            if (p.type === 'laser') {
                ctx.fillStyle = '#ff00ff';
                ctx.shadowColor = '#ff00ff';
            } else if (p.type === 'missile') {
                ctx.fillStyle = '#ff9900';
                ctx.shadowColor = '#ff9900';
            } else if (p.type === 'cryo-shard') {
                ctx.fillStyle = p.shouldFreeze ? '#ffffff' : '#99ccff';
                ctx.shadowColor = p.shouldFreeze ? '#ffffff' : '#99ccff';
            } else {
                ctx.fillStyle = 'white';
                ctx.shadowColor = 'white';
            }
            ctx.shadowBlur = 8;
            
            if (p.type === 'ricochet-blade') {
                ctx.translate(p.x, p.y);
                ctx.rotate(p.rotation);
                ctx.beginPath();
                ctx.arc(0, 0, 10, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#00ffff';
                ctx.fillRect(-12, -2, 24, 4);
            } else if (p.type === 'glitch-pulse') {
                ctx.globalAlpha = p.lifetime / 250;
                ctx.fillStyle = `rgba(255, 0, 255, ${0.5 + Math.random() * 0.5})`;
                ctx.shadowColor = '#ff00ff';
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.width / 2, 0, Math.PI * 2);
                ctx.fill();
            }
            else {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        });

        enemyProjectiles.forEach(p => {
            ctx.save();
            ctx.fillStyle = 'orange';
            ctx.shadowColor = 'orange';
            ctx.shadowBlur = 8;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size / 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        });
    }

    function drawItems() {
        // XP Gems
        xpGems.forEach(gem => {
            ctx.save();
            ctx.fillStyle = '#00ffff';
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.moveTo(gem.x, gem.y - 5);
            ctx.lineTo(gem.x - 5, gem.y);
            ctx.lineTo(gem.x, gem.y + 5);
            ctx.lineTo(gem.x + 5, gem.y);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        });
        
        // Pickups
        itemPickups.forEach(item => {
            ctx.save();
            ctx.globalAlpha = item.lifetime < 1000 ? (item.lifetime / 1000) : 1;
            ctx.font = 'bold 20px Orbitron';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            switch (item.type) {
                case 'health':
                    ctx.fillStyle = '#0f0';
                    ctx.shadowColor = '#0f0';
                    ctx.shadowBlur = 15;
                    ctx.fillText('+', item.x, item.y);
                    break;
                case 'speed':
                    ctx.fillStyle = '#ff0';
                    ctx.shadowColor = '#ff0';
                    ctx.shadowBlur = 15;
                    ctx.fillText('⚡', item.x, item.y);
                    break;
                case 'firerate':
                    ctx.fillStyle = '#0ff';
                    ctx.shadowColor = '#0ff';
                    ctx.shadowBlur = 15;
                    ctx.fillText('🌀', item.x, item.y);
                    break;
                case 'invincibility':
                    ctx.fillStyle = '#f0f';
                    ctx.shadowColor = '#f0f';
                    ctx.shadowBlur = 15;
                    ctx.fillText('✨', item.x, item.y);
                    break;
                case 'magnet':
                    ctx.fillStyle = '#4d4dff';
                    ctx.shadowColor = '#4d4dff';
                    ctx.shadowBlur = 15;
                    ctx.fillText('🧲', item.x, item.y);
                    break;
                case 'nuke':
                    ctx.fillStyle = '#f00';
                    ctx.shadowColor = '#f00';
                    ctx.shadowBlur = 15;
                    ctx.fillText('☢️', item.x, item.y);
                    break;
            }
            ctx.restore();
        });
    }

    function drawEffects(deltaTime) {
        // Explosions
        for (let i = explosions.length - 1; i >= 0; i--) {
            const exp = explosions[i];
            exp.timer += deltaTime * 1000;

            if (exp.timer >= exp.duration) {
                explosions.splice(i, 1);
                continue;
            }

            const progress = exp.timer / exp.duration;
            const currentRadius = exp.maxRadius * Math.sin(progress * Math.PI);
            
            ctx.save();
            ctx.beginPath();
            ctx.arc(exp.x, exp.y, currentRadius, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255, 255, 0, ${1 - progress})`;
            ctx.shadowColor = '#ff0';
            ctx.shadowBlur = 20;
            ctx.fill();
            ctx.restore();
        }
        
        // Damage texts
        for (let i = damageTexts.length - 1; i >= 0; i--) {
            const dt = damageTexts[i];
            dt.timer += deltaTime * 1000;
            dt.y -= 30 * deltaTime;
            dt.alpha -= deltaTime * 1.5;

            ctx.save();
            ctx.font = dt.color === '255, 255, 0' ? 'bold 18px Orbitron' : '14px Orbitron';
            ctx.fillStyle = `rgba(${dt.color}, ${dt.alpha})`;
            ctx.textAlign = 'center';
            ctx.fillText(dt.text, dt.x, dt.y);
            ctx.restore();
            
            if(dt.alpha <= 0) damageTexts.splice(i, 1);
        }
        
        // Nuke Effect
        if (nukeEffect && nukeEffect.timer > 0) {
            nukeEffect.timer -= deltaTime * 1000;
            const progress = nukeEffect.timer / nukeEffect.duration;
            ctx.save();
            ctx.fillStyle = `rgba(255, 255, 255, ${progress})`;
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            ctx.restore();
        }
        
        // Black Holes
        blackHoles.forEach(bh => {
            ctx.save();
            const gradient = ctx.createRadialGradient(bh.x, bh.y, 5, bh.x, bh.y, bh.radius);
            gradient.addColorStop(0, 'rgba(0,0,0,0)');
            gradient.addColorStop(0.5, 'rgba(128, 0, 128, 0.5)');
            gradient.addColorStop(1, 'rgba(255, 0, 255, 0.8)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(bh.x, bh.y, bh.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        });
        
        // Vortexes
        vortexes.forEach(v => {
            ctx.save();
            ctx.translate(v.x, v.y);
            ctx.rotate(v.rotation);
            const gradient = ctx.createRadialGradient(0, 0, v.radius / 5, 0, 0, v.radius);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 0)');
            gradient.addColorStop(0.8, 'rgba(0, 255, 255, 0.3)');
            gradient.addColorStop(1, 'rgba(0, 255, 255, 0.6)');
            ctx.fillStyle = gradient;

            for (let i = 0; i < 5; i++) {
                ctx.beginPath();
                const angle = (i / 5) * Math.PI * 2;
                ctx.moveTo(0,0);
                ctx.quadraticCurveTo(
                    Math.cos(angle + v.rotation) * v.radius * 0.5,
                    Math.sin(angle + v.rotation) * v.radius * 0.5,
                    Math.cos(angle) * v.radius,
                    Math.sin(angle) * v.radius
                );
                ctx.lineTo(
                     Math.cos(angle + 0.1) * v.radius,
                     Math.sin(angle + 0.1) * v.radius
                );
                ctx.quadraticCurveTo(
                    Math.cos(angle + 0.1 + v.rotation) * v.radius * 0.5,
                    Math.sin(angle + 0.1 + v.rotation) * v.radius * 0.5,
                    0,0
                );
                ctx.fill();
            }
            ctx.restore();
        });
    }

    function drawUI() {
        if (!('ontouchstart' in window)) {
            // Draw crosshair
            ctx.save();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(mousePos.x - 10, mousePos.y);
            ctx.lineTo(mousePos.x + 10, mousePos.y);
            ctx.moveTo(mousePos.x, mousePos.y - 10);
            ctx.lineTo(mousePos.x, mousePos.y + 10);
            ctx.stroke();
            ctx.restore();
        }
    }
    
    // --- Game Loop ---

    function gameLoop(currentTime) {
        if (!lastTime) lastTime = currentTime;
        const deltaTime = (currentTime - lastTime) / 1000;
        lastTime = currentTime;
    
        if (isPaused || gameState === 'levelup') {
            requestAnimationFrame(gameLoop);
            return;
        }

        if (gameState !== 'playing') {
            return;
        }
        
        // Update
        gameTime += deltaTime;
        
        updatePlayer(deltaTime);
        updateEnemies(deltaTime);
        updateProjectiles(deltaTime);
        updateItems(deltaTime);
        updateBlackHoles(deltaTime);
        updateVortexes(deltaTime);
        checkCollisions();

        if (performance.now() - lastKillTime > COMBO_TIMEOUT) {
            resetCombo();
        }

        lastSpawnTime += deltaTime * 1000;
        if (lastSpawnTime > spawnInterval) {
            const spawnCount = 1 + Math.floor(gameTime / 20);
            for(let i=0; i<spawnCount; i++){
                spawnEnemy();
            }
            lastSpawnTime = 0;
            spawnInterval = Math.max(200, 2000 * (1 - gameTime / 300) * DIFFICULTY_SETTINGS[selectedDifficulty].spawnRateMult);
        }

        lastItemSpawnTime += deltaTime * 1000;
        if (lastItemSpawnTime > itemSpawnInterval) {
            spawnItem();
            lastItemSpawnTime = 0;
            itemSpawnInterval = 10000 + Math.random() * 5000; // 10-15 seconds
        }

        if (gameTime > 300 && !bossSpawned) {
             spawnBoss();
        }

        updateUI();

        // Draw
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        drawItems();
        drawPlayer();
        drawEnemies();
        drawProjectiles();
        drawEffects(deltaTime);
        drawUI();

        // Check game over
        if (player.hp <= 0) {
            gameState = 'gameover';
            gameOverScreen.classList.remove('hidden');
            pauseButton.classList.add('hidden');
            gameOverTimeUI.textContent = `생존 시간: ${formatTime(gameTime)}`;
            const rank = getRank(gameTime);
            gameOverRankUI.textContent = `달성 랭크: ${rank.name}`;
            if (gameTime > highScore) {
                highScore = gameTime;
                localStorage.setItem('neonSurvivorHighScore', highScore);
                updateHighscoreDisplay();
            }
            gameOverHighscoreUI.textContent = `최고 기록: ${formatTime(highScore)}`;
            return;
        }
        
        animationFrameId = requestAnimationFrame(gameLoop);
    }
    
    // --- Game Setup ---
    
    function startGame() {
        // Reset game state
        enemies = [];
        projectiles = [];
        enemyProjectiles = [];
        xpGems = [];
        itemPickups = [];
        explosions = [];
        damageTexts = [];
        blackHoles = [];
        vortexes = [];
        nukeEffect = null;
        
        player = createInitialPlayer(selectedDifficulty, selectedWeapon);
        
        isPaused = false;
        bossSpawned = false;
        lastSpawnTime = 0;
        spawnInterval = 2000 * DIFFICULTY_SETTINGS[selectedDifficulty].spawnRateMult;
        lastItemSpawnTime = 0;
        itemSpawnInterval = 10000;
        comboCount = 0;
        lastKillTime = performance.now();
        availableUpgrades = [...UPGRADES];

        gameTime = 0;
        
        // UI
        startScreen.classList.add('hidden');
        gameOverScreen.classList.add('hidden');
        pauseScreen.classList.add('hidden');
        levelUpScreen.classList.add('hidden');
        pauseButton.classList.remove('hidden');
        levelUI.textContent = `레벨: 1`;
        updateUI();

        gameState = 'playing';
        
        lastTime = performance.now();
        animationFrameId = requestAnimationFrame(gameLoop);
    }
    
    function restartGame() {
        cancelAnimationFrame(animationFrameId);
        gameOverScreen.classList.add('hidden');
        pauseScreen.classList.add('hidden');
        startGame();
    }

    function quitToMenu() {
        cancelAnimationFrame(animationFrameId);
        gameState = 'start';
        isPaused = false;
        pauseScreen.classList.add('hidden');
        startScreen.classList.remove('hidden');
        pauseButton.classList.add('hidden');
        updateHighscoreDisplay();
    }
    
    // --- Event Listeners ---
    
    startButton.addEventListener('click', startGame);
    restartButton.addEventListener('click', restartGame);
    pauseButton.addEventListener('click', togglePause);
    resumeButton.addEventListener('click', togglePause);
    restartPauseButton.addEventListener('click', () => {
        pauseScreen.classList.add('hidden');
        restartGame();
    });
    quitButton.addEventListener('click', quitToMenu);

    weaponSelection.addEventListener('click', (e) => {
        if (e.target.tagName === 'BUTTON') {
            weaponSelection.querySelector('.selected')?.classList.remove('selected');
            e.target.classList.add('selected');
            selectedWeapon = e.target.dataset.weapon;
            startButton.disabled = false;
        }
    });

    difficultySelection.addEventListener('click', (e) => {
        if (e.target.tagName === 'BUTTON') {
            difficultySelection.querySelector('.selected')?.classList.remove('selected');
            e.target.classList.add('selected');
            selectedDifficulty = e.target.dataset.difficulty;
        }
    });
    
    window.addEventListener('keydown', (e) => {
        keysPressed[e.key] = true;
        if (e.key === 'Escape' || e.key === 'p') {
            e.preventDefault();
            togglePause();
        }
    });
    window.addEventListener('keyup', (e) => {
        keysPressed[e.key] = false;
    });

    canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        mousePos.x = (e.clientX - rect.left) * scaleX;
        mousePos.y = (e.clientY - rect.top) * scaleY;
    });

    // --- Touch Controls ---
    const isMobile = 'ontouchstart' in window;
    if (isMobile) {
        function getTouchPos(touch) {
            const rect = gameWrapper.getBoundingClientRect();
            return {
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top,
            };
        }

        function handleTouchStart(e) {
            if (gameState !== 'playing' || isPaused) return;
            e.preventDefault();
            for (const touch of e.changedTouches) {
                // Only activate if not already active. This will handle the first touch.
                if (!movementJoystickState.active) {
                    const pos = getTouchPos(touch);
                    movementJoystickState.touchId = touch.identifier;
                    movementJoystickState.active = true;
                    movementJoystickState.x = pos.x;
                    movementJoystickState.y = pos.y;
                    movementJoystickUI.style.left = `${pos.x - JOYSTICK_BASE_RADIUS}px`;
                    movementJoystickUI.style.top = `${pos.y - JOYSTICK_BASE_RADIUS}px`;
                    movementJoystickUI.classList.remove('hidden');
                    movementJoystickUI.classList.add('active');
                    break; // We only need one joystick
                }
            }
        }
        
        function handleTouchMove(e) {
            if (gameState !== 'playing' || isPaused) return;
            e.preventDefault();
            for (const touch of e.changedTouches) {
                if (touch.identifier === movementJoystickState.touchId) {
                    const pos = getTouchPos(touch);
                    let dx = pos.x - movementJoystickState.x;
                    let dy = pos.y - movementJoystickState.y;
                    const dist = Math.hypot(dx, dy);

                    if (dist > JOYSTICK_DEAD_ZONE) {
                         const clampedDist = Math.min(dist, JOYSTICK_MAX_OFFSET);
                         movementJoystickState.dx = (dx / dist);
                         movementJoystickState.dy = (dy / dist);
                         const handleX = movementJoystickState.dx * clampedDist;
                         const handleY = movementJoystickState.dy * clampedDist;
                         movementJoystickHandle.style.transform = `translate(${handleX}px, ${handleY}px)`;
                    } else {
                         movementJoystickState.dx = 0;
                         movementJoystickState.dy = 0;
                         movementJoystickHandle.style.transform = `translate(0px, 0px)`;
                    }
                }
            }
        }

        function handleTouchEnd(e) {
            if (gameState !== 'playing' || isPaused) return;
            e.preventDefault();
            for (const touch of e.changedTouches) {
                if (touch.identifier === movementJoystickState.touchId) {
                    movementJoystickState.active = false;
                    movementJoystickState.touchId = null;
                    movementJoystickState.dx = 0;
                    movementJoystickState.dy = 0;
                    movementJoystickHandle.style.transform = 'translate(0,0)';
                    movementJoystickUI.classList.remove('active');
                    movementJoystickUI.classList.add('hidden');
                }
            }
        }
        
        gameWrapper.addEventListener('touchstart', handleTouchStart, { passive: false });
        gameWrapper.addEventListener('touchmove', handleTouchMove, { passive: false });
        gameWrapper.addEventListener('touchend', handleTouchEnd, { passive: false });
        gameWrapper.addEventListener('touchcancel', handleTouchEnd, { passive: false });
    }
    
    // Auto-pause when window loses focus
    document.addEventListener('visibilitychange', () => {
        if (document.hidden && gameState === 'playing' && !isPaused) {
            togglePause();
        }
    });

    // --- Game Initialization ---
    selectedDifficulty = difficultySelection.querySelector('.selected').dataset.difficulty;
    const defaultWeaponButton = weaponSelection.querySelector('.selected');
    if (defaultWeaponButton) {
        selectedWeapon = defaultWeaponButton.dataset.weapon;
        startButton.disabled = false;
    }
    updateHighscoreDisplay();

});
</script>

</body>
</html>
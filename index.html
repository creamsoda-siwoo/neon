
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>네온 서바이버</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      font-family: 'Orbitron', sans-serif;
      overflow: hidden;
      background-color: #0d0221;
      color: white;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      margin: 0;
      touch-action: none;
    }
    .game-container {
      background: #0a0a1f;
      border: 2px solid #00ffff;
      box-shadow: 0 0 20px #00ffff, inset 0 0 20px #00ffff;
      width: min(96vw, calc((100vh - 8rem) * 4 / 3));
      height: min(calc(96vw * 3 / 4), calc(100vh - 8rem));
      touch-action: none;
    }
    #game-canvas {
      background-color: #0d0221;
      cursor: none;
      width: 100%;
      height: 100%;
      display: block;
    }
    .text-glow {
      color: #fff;
      text-shadow: 0 0 7px #fff, 0 0 10px #fff, 0 0 21px #ff00ff, 0 0 42px #ff00ff;
    }
    .button-retro {
      background-color: transparent;
      border: 2px solid #fff;
      color: #fff;
      padding: 0.75rem 1.5rem;
      text-transform: uppercase;
      letter-spacing: 2px;
      transition: all 0.2s ease-in-out;
      text-shadow: 0 0 8px #ff00ff;
      cursor: pointer;
    }
    .button-retro:hover:not(:disabled) {
      background-color: #fff;
      color: #0d0221;
      box-shadow: 0 0 20px #fff, 0 0 30px #ff00ff;
    }
    .button-retro:disabled {
        cursor: not-allowed;
        opacity: 0.5;
    }
    .selection-button {
        border-width: 2px;
        border-color: #fff;
        background-color: transparent;
        padding: 0.75rem;
        height: 100%;
        font-size: 0.9rem;
    }
    .selection-button.selected {
        background-color: #00ffff;
        color: #0d0221;
        box-shadow: 0 0 20px #00ffff;
    }
    .upgrade-card {
      border: 2px solid #00ffff;
      background: rgba(13, 2, 33, 0.8);
      transition: all 0.2s ease-in-out;
      cursor: pointer;
    }
    .upgrade-card:hover {
      background: rgba(0, 255, 255, 0.2);
      box-shadow: 0 0 15px #00ffff;
      transform: translateY(-5px);
    }
    .overlay {
        position: absolute;
        inset: 0;
        background-color: rgba(0,0,0,0.85);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
        z-index: 10;
        padding: 1rem;
    }
    .hidden {
        display: none;
    }
    #start-button {
        padding: 1rem 2rem;
        font-size: 1.25rem;
        font-weight: bold;
    }
    @keyframes pulse-glow {
        0% {
            transform: scale(1);
            box-shadow: 0 0 15px #00ffff, 0 0 25px #ff00ff;
        }
        50% {
            transform: scale(1.08);
            box-shadow: 0 0 30px #00ffff, 0 0 50px #ff00ff;
        }
        100% {
            transform: scale(1);
            box-shadow: 0 0 15px #00ffff, 0 0 25px #ff00ff;
        }
    }
    @keyframes pulse-glow-yellow {
        0% {
            transform: scale(1);
            text-shadow: 0 0 10px #facc15, 0 0 15px #fef08a;
        }
        50% {
            transform: scale(1.05);
            text-shadow: 0 0 20px #facc15, 0 0 30px #fef08a;
        }
        100% {
            transform: scale(1);
            text-shadow: 0 0 10px #facc15, 0 0 15px #fef08a;
        }
    }

    #start-button:not(:disabled) {
        border-color: #00ffff;
        color: #00ffff;
        text-shadow: 0 0 8px #00ffff;
        animation: pulse-glow 2s infinite ease-in-out;
    }
    .joystick {
        position: absolute;
        width: 80px;
        height: 80px;
        pointer-events: none;
    }
    .joystick-base {
        position: absolute;
        width: 100%;
        height: 100%;
        border-radius: 50%;
        background-color: rgba(0, 255, 255, 0.1);
        border: 2px solid rgba(0, 255, 255, 0.4);
        box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        transition: transform 0.1s ease-out, background-color 0.1s, border-color 0.1s;
    }
    .joystick-handle {
        position: absolute;
        width: 40px;
        height: 40px;
        top: 20px;
        left: 20px;
        border-radius: 50%;
        background-color: rgba(0, 255, 255, 0.3);
        border: 2px solid rgba(0, 255, 255, 0.8);
        box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
        transition: transform 0.05s linear, background-color 0.1s, border-color 0.1s;
    }
    .joystick.active .joystick-base {
        transform: scale(1.1);
        background-color: rgba(0, 255, 255, 0.2);
        border-color: rgba(0, 255, 255, 0.8);
    }
    .joystick.active .joystick-handle {
        background-color: rgba(0, 255, 255, 0.6);
        border-color: #fff;
    }
    .stat {
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }
    .stat-label {
        width: 60px;
        text-align: right;
        font-size: 0.8rem;
        color: #a7a7a7;
        flex-shrink: 0;
    }
    .stat-bar-bg {
        flex-grow: 1;
        height: 10px;
        background-color: rgba(0, 50, 50, 0.5);
        border: 1px solid #00ffff;
        border-radius: 5px;
        padding: 1px;
    }
    .stat-bar-fill {
        height: 100%;
        background: linear-gradient(90deg, #ff00ff, #00ffff);
        border-radius: 3px;
        box-shadow: 0 0 5px #00ffff;
        transition: width 0.3s ease-out;
    }
    @media (max-width: 400px) {
        .top-ui-text { font-size: 0.8rem !important; }
        #timer-ui { font-size: 1.1rem !important; }
    }
  </style>
</head>
<body>

  <main class="flex flex-col items-center w-full h-screen p-2 box-border">
    <div class="flex justify-between w-full mb-2 px-2 text-glow" style="max-width: 1200px;">
        <div class="flex gap-4 items-center">
            <div id="level-ui" class="text-xl top-ui-text">레벨: 1</div>
            <div id="current-rank-ui" class="text-lg top-ui-text"></div>
        </div>
        <div class="flex flex-col items-center">
            <div id="timer-ui" class="text-2xl font-bold">00:00</div>
            <div id="combo-ui" class="text-xl font-bold text-yellow-400 h-6" style="text-shadow: 0 0 8px #facc15;"></div>
        </div>
        <div id="highscore-ui" class="text-xl text-right top-ui-text">최고기록: 00:00</div>
    </div>
    
    <div class="w-full h-8 mb-2 flex flex-col justify-around" style="max-width: 1200px;">
        <div class="w-full bg-gray-700 h-3 rounded-full overflow-hidden border border-red-500">
            <div id="hp-bar" class="bg-red-500 h-full" style="width: 100%"></div>
        </div>
        <div class="w-full bg-gray-700 h-3 rounded-full overflow-hidden border border-cyan-400">
            <div id="xp-bar" class="bg-cyan-400 h-full" style="width: 0%"></div>
        </div>
    </div>

    <div id="game-wrapper" class="relative rounded-lg overflow-hidden game-container">
      <canvas id="game-canvas" width="800" height="600"></canvas>
      <button id="pause-button" class="absolute top-2 right-2 text-2xl w-14 h-14 button-retro hidden items-center justify-center" style="padding: 0;">||</button>
      
      <div id="movement-joystick" class="joystick hidden">
        <div class="joystick-base"></div>
        <div class="joystick-handle"></div>
      </div>
      
      <div id="start-screen" class="overlay">
          <div class="absolute top-4 left-4 text-xs text-gray-500">제작자: 한국인이라면</div>
          <h1 class="text-4xl sm:text-5xl md:text-6xl font-bold mb-4 text-glow">네온 서바이버</h1>
          <div id="start-screen-highscore" class="text-xl mb-8 text-glow"></div>
          
          <div class="w-full max-w-2xl">
            <h2 class="text-xl mb-2 text-glow">난이도 선택</h2>
            <div id="difficulty-selection" class="grid grid-cols-3 gap-2 mb-4">
                <button class="button-retro selection-button" data-difficulty="쉬움">쉬움</button>
                <button class="button-retro selection-button selected" data-difficulty="보통">보통</button>
                <button class="button-retro selection-button" data-difficulty="어려움">어려움</button>
            </div>
          </div>

          <div class="w-full max-w-2xl mt-4">
              <h2 class="text-xl mb-2 text-glow">무기 선택</h2>
              <div id="weapon-selection" class="flex flex-wrap justify-center gap-2 mb-2">
                  <button class="button-retro selection-button selected w-[45%] md:w-auto" data-weapon="machine-gun">기관총</button>
                  <button class="button-retro selection-button w-[45%] md:w-auto" data-weapon="missile">유도 미사일</button>
                  <button class="button-retro selection-button w-[45%] md:w-auto" data-weapon="bomb">폭탄</button>
                  <button class="button-retro selection-button w-[45%] md:w-auto" data-weapon="laser">레이저</button>
                  <button class="button-retro selection-button w-[45%] md:w-auto" data-weapon="bow">활</button>
                  <button class="button-retro selection-button w-[45%] md:w-auto" data-weapon="chain-lightning">연쇄 번개</button>
                  <button class="button-retro selection-button w-[45%] md:w-auto" data-weapon="black-hole-generator">블랙홀</button>
                  <button class="button-retro selection-button w-[45%] md:w-auto" data-weapon="plasma-cannon">플라즈마</button>
                  <button class="button-retro selection-button w-[45%] md:w-auto" data-weapon="ricochet-blade">리코</button>
                  <button class="button-retro selection-button w-[45%] md:w-auto" data-weapon="chrono-repeater">크로노 리피터</button>
                  <button class="button-retro selection-button w-[45%] md:w-auto" data-weapon="glitch-pulser">글리치 펄서</button>
                  <button class="button-retro selection-button w-[45%] md:w-auto" data-weapon="cryo-gun">크라이오건</button>
              </div>
          </div>

          <button id="start-button" class="button-retro mt-8" disabled>게임 시작</button>
      </div>

      <div id="pause-screen" class="overlay hidden">
          <h2 class="text-4xl sm:text-5xl font-bold mb-8 text-glow">일시정지</h2>
          <div class="flex flex-col gap-4 w-64">
              <button id="resume-button" class="button-retro">계속하기</button>
              <button id="restart-pause-button" class="button-retro">다시 시작</button>
              <button id="quit-button" class="button-retro">그만하기</button>
          </div>
      </div>

      <div id="levelup-screen" class="overlay hidden">
          <h2 class="text-4xl sm:text-5xl font-bold mb-8 text-glow">레벨 업!</h2>
          <div id="levelup-options" class="grid grid-cols-1 md:grid-cols-3 gap-6">
              <!-- Upgrade cards will be injected here -->
          </div>
      </div>

      <div id="gameover-screen" class="overlay hidden">
          <h2 class="text-4xl sm:text-5xl font-bold mb-4 text-glow">게임 오버</h2>
          <p id="new-highscore-message" class="text-3xl mb-4 text-yellow-400 hidden" style="text-shadow: 0 0 10px #facc15; animation: pulse-glow-yellow 2s infinite ease-in-out;">최고 기록 갱신!</p>
          <p id="gameover-time" class="text-3xl mb-2">생존 시간: 00:00</p>
          <p id="gameover-rank" class="text-2xl mb-6"></p>
          <p id="gameover-highscore" class="text-xl mb-8">최고 기록: 00:00</p>
          <button id="restart-button" class="button-retro">새로 시작</button>
      </div>
    </div>
  </main>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- DOM Elements ---
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    const gameWrapper = document.getElementById('game-wrapper');
    const startScreen = document.getElementById('start-screen');
    const pauseScreen = document.getElementById('pause-screen');
    const levelUpScreen = document.getElementById('levelup-screen');
    const gameOverScreen = document.getElementById('gameover-screen');
    const startButton = document.getElementById('start-button');
    const restartButton = document.getElementById('restart-button');
    const pauseButton = document.getElementById('pause-button');
    const levelUpOptionsContainer = document.getElementById('levelup-options');
    const weaponSelection = document.getElementById('weapon-selection');
    const difficultySelection = document.getElementById('difficulty-selection');
    const resumeButton = document.getElementById('resume-button');
    const restartPauseButton = document.getElementById('restart-pause-button');
    const quitButton = document.getElementById('quit-button');

    // Joystick UI
    const movementJoystickUI = document.getElementById('movement-joystick');
    const movementJoystickHandle = movementJoystickUI.querySelector('.joystick-handle');
    
    // UI Elements
    const levelUI = document.getElementById('level-ui');
    const timerUI = document.getElementById('timer-ui');
    const comboUI = document.getElementById('combo-ui');
    const highscoreUI = document.getElementById('highscore-ui');
    const hpBar = document.getElementById('hp-bar');
    const xpBar = document.getElementById('xp-bar');
    const gameOverTimeUI = document.getElementById('gameover-time');
    const gameOverRankUI = document.getElementById('gameover-rank');
    const gameOverHighscoreUI = document.getElementById('gameover-highscore');
    const startScreenHighscoreUI = document.getElementById('start-screen-highscore');
    const currentRankUI = document.getElementById('current-rank-ui');
    const newHighscoreMessage = document.getElementById('new-highscore-message');

    // --- Game Constants ---
    const CANVAS_WIDTH = 800;
    const CANVAS_HEIGHT = 600;
    const PLAYER_SIZE = 20;
    const COMBO_TIMEOUT = 2500;

    // --- Ranking System ---
    const RANKS = [
        { name: '네온 초심자', threshold: 0, color: '#9ca3af' },
        { name: '그리드 러너', threshold: 60, color: '#6ee7b7' },
        { name: '서킷 브레이커', threshold: 120, color: '#60a5fa' },
        { name: '데이터 스트리머', threshold: 180, color: '#c084fc' },
        { name: '사이버 검투사', threshold: 240, color: '#f87171' },
        { name: '신스웨이브 파수꾼', threshold: 300, color: '#facc15' },
        { name: '디지털 오버로드', threshold: 420, color: '#f472b6' },
        { name: '코드 아크마스터', threshold: 600, color: '#00ffff' },
        { name: '매트릭스 군주', threshold: 900, color: '#ffffff' }
    ];

    function getRank(seconds) {
        let currentRank = RANKS[0];
        for (const rank of RANKS) {
            if (seconds >= rank.threshold) {
                currentRank = rank;
            } else {
                break;
            }
        }
        return currentRank;
    }
    
    // --- Enemy Types ---
    const ENEMY_TYPES = {
        'grunt': { size: 15, hp: 10, speed: 70, color: '#ff4d4d', xp: 1, shape: 'square', damage: 5 },
        'tank': { size: 30, hp: 50, speed: 40, color: '#ff8c66', xp: 5, shape: 'square', damage: 15 },
        'shooter': { size: 18, hp: 15, speed: 60, color: '#fcf003', xp: 2, shape: 'triangle', damage: 10, fireRate: 2000, projectileSpeed: 150 },
        'bomber': { size: 20, hp: 20, speed: 80, color: '#ff99cc', xp: 3, shape: 'square', damage: 20, onDeath: 'explode' },
        'summoner': { size: 25, hp: 40, speed: 50, color: '#cc99ff', xp: 8, shape: 'triangle', damage: 5, actionRate: 5000, action: 'summon' },
        'boss': { size: 50, hp: 500, speed: 60, color: '#ff0000', xp: 50, shape: 'square', damage: 25, fireRate: 1000, projectileSpeed: 200 },
    };


    // --- Game Configs ---
    const DIFFICULTY_SETTINGS = {
        '쉬움': { hp: 120, enemyHpMult: 0.7, enemySpeedMult: 0.8, spawnRateMult: 1.2 },
        '보통': { hp: 100, enemyHpMult: 1.0, enemySpeedMult: 1.0, spawnRateMult: 1.0 },
        '어려움': { hp: 80, enemyHpMult: 1.5, enemySpeedMult: 1.2, spawnRateMult: 0.8 },
    };
    const WEAPON_SETTINGS = {
        'machine-gun': { fireRate: 400, damage: 12, projectileType: 'bullet', name: '기관총', knockback: 20, description: '가장 균형잡힌 무기. 8발마다 강력한 넉백탄 발사!' },
        'missile': { fireRate: 1000, damage: 40, projectileType: 'missile', name: '유도 미사일', explosionRadius: 70, description: '가장 가까운 적을 추적하며 넓은 범위에 폭발 피해를 줍니다.' },
        'bomb': { fireRate: 800, damage: 25, projectileType: 'bomb', name: '폭탄', shrapnelCount: 5, description: '포물선으로 날아가 폭발하며 5개의 파편을 흩뿌립니다.' },
        'laser': { fireRate: 1200, damage: 45, projectileType: 'laser', name: '레이저', slowAmount: 0.5, slowDuration: 1000, description: '적을 관통하며 1초간 이동 속도를 50% 감소시킵니다.' },
        'bow': { fireRate: 600, damage: 25, projectileType: 'arrow', name: '활', critChance: 0.15, critMultiplier: 2, description: '적을 관통하며 15% 확률로 2배의 치명타 피해를 입힙니다.' },
        'chain-lightning': { fireRate: 800, damage: 30, projectileType: 'lightning', name: '연쇄 번개', bounces: 4, description: '적들 사이를 4번 튕기는 번개를 발사합니다.' },
        'black-hole-generator': { fireRate: 2000, damage: 0, projectileType: 'black-hole-orb', name: '블랙홀 생성기', description: '적을 끌어당기고 지속 피해를 주는 소형 블랙홀을 발사합니다.' },
        'plasma-cannon': { fireRate: 1800, damage: 50, projectileType: 'plasma-ball', name: '플라즈마 캐논', explosionRadius: 80, burnDamage: 10, burnDuration: 3000, description: '느리지만 강력한 플라즈마 구체를 발사합니다. 구체는 폭발하며 3초간 화상 피해를 입힙니다.' },
        'ricochet-blade': { fireRate: 750, damage: 20, projectileType: 'ricochet-blade', name: '리코셰 블레이드', bounces: 3, description: '적에게 튕기는 회전 칼날을 발사하여 최대 4명의 적을 공격합니다.' },
        'chrono-repeater': { fireRate: 700, damage: 18, projectileType: 'chrono-repeater-shot', name: '크로노 리피터', slowAmount: 0.3, slowDuration: 1000, splitCount: 4, description: '시간을 왜곡하는 탄환을 발사합니다. 탄환은 적을 느리게 만들고, 사라질 때 여러 개의 작은 탄환으로 분열됩니다.' },
        'glitch-pulser': { fireRate: 900, damage: 15, projectileType: 'glitch-pulse', name: '글리치 펄서', stunChance: 0.2, stunDuration: 1000, description: '짧은 거리의 적들을 관통하는 에너지 파동을 방출합니다. 피격된 적은 확률적으로 잠시 기절합니다.' },
        'cryo-gun': { fireRate: 850, damage: 18, projectileType: 'cryo-shard', name: '크라이오건', slowAmount: 0.4, slowDuration: 1500, freezeOnNthShot: 5, freezeDuration: 1000, description: '적을 느리게 만드는 얼음 파편을 발사합니다. 5번째 공격마다 적을 잠시 얼립니다.'}
    };
   
    // --- Audio ---
    let audioContext;
    try { audioContext = new (window.AudioContext || window.webkitAudioContext)(); }
    catch (e) { console.error("Web Audio API is not supported in this browser"); }

    function playSound(type, frequency, duration, volume = 0.3) {
        if (!audioContext) return;
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        oscillator.type = type;
        oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
        gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.00001, audioContext.currentTime + duration);
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + duration);
    }
    const sounds = {
        hit: () => playSound('square', 150, 0.1, 0.2),
        shoot: () => playSound('triangle', 440, 0.05, 0.1),
        xp: () => playSound('sine', 600, 0.1, 0.2),
        levelUp: () => playSound('sine', 880, 0.4),
        heal: () => playSound('sine', 700, 0.3),
        dash: () => playSound('sine', 300, 0.2, 0.4),
        explosion: () => playSound('sine', 50, 0.3, 0.5),
        nuke: () => playSound('sine', 100, 1.0, 0.8),
        powerup: () => playSound('sine', 900, 0.2),
        freeze: () => playSound('sawtooth', 200, 0.5, 0.4),
        shieldUp: () => playSound('sine', 1000, 0.2, 0.5),
        shieldDown: () => playSound('square', 100, 0.2, 0.5),
        blackHole: () => playSound('noise', 100, 2, 0.4),
        summon: () => playSound('sine', 500, 0.3, 0.2),
    };
    
    // --- Game State ---
    let gameState = 'start';
    let isPaused = false;
    let selectedDifficulty, selectedWeapon;
    let player, enemies, projectiles, enemyProjectiles, xpGems, itemPickups, explosions;
    let orbitalShields, speedBoosts, fireRateBoosts, freezeBombs, invincibilityShields, blackHoleItems;
    let drones, explosiveBarrels, blackHoles;
    let holographicDecoys, decoys;
    let magnets, xpBombs;
    let damageTexts, nukeEffect, afterimages;
    let timer, gameTime, lastTime, animationFrameId;
    let lastSpawnTime, spawnInterval, lastItemSpawnTime, itemSpawnInterval;
    let bossSpawned, enemiesFrozen, enemiesFrozenTimer;
    let mousePos = { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2 };
    let keysPressed = {};
    let highScore = Number(localStorage.getItem('neonSurvivorHighScore') || 0);
    let comboCount, lastKillTime;

    // Joystick State
    const JOYSTICK_BASE_RADIUS = 40;
    const JOYSTICK_MAX_OFFSET = JOYSTICK_BASE_RADIUS - 20;
    const JOYSTICK_DEAD_ZONE = 5;
    let movementJoystickState = { active: false, x: 0, y: 0, dx: 0, dy: 0, touchId: null, startTime: 0, startX: 0, startY: 0, lastTapTime: 0 };


    // --- Upgrades ---
    const UPGRADES = [
        { id: 'firerate', title: "연사력 강화", description: "공격 속도 20% 증가", apply: p => { p.baseFireRate *= 0.8; p.fireRate = p.baseFireRate;} },
        { id: 'damage', title: "강화 탄환", description: "공격력 25% 증가", apply: p => p.projectileDamage *= 1.25 },
        { id: 'multishot', title: "멀티샷", description: "발사체 수 +1", apply: p => p.projectiles++ },
        { id: 'hp', title: "나노 수리봇", description: "최대 체력 20 증가 및 모두 회복", apply: p => { p.maxHp += 20; p.hp = p.maxHp; } },
        { id: 'speed', title: "고속 추진기", description: "이동 속도 10% 증가", apply: p => { p.baseSpeed *= 1.1; p.speed = p.baseSpeed; } },
        { id: 'shield', title: '궤도 방패', description: '주위를 도는 방패 추가', apply: p => p.shields++ },
        { id: 'explosive', title: '폭발탄', description: '탄환이 명중 시 폭발합니다', apply: p => p.explosiveProjectiles = true },
        { id: 'magnet', title: '경험치 자석', description: '경험치 획득 범위 50% 증가', apply: p => p.pickupRadius *= 1.5 },
        { id: 'drone', title: '컴패니언 드론', description: '플레이어를 돕는 공격 드론을 추가합니다.', apply: p => p.drones = (p.drones || 0) + 1 },
        { id: 'regeneration', title: '나노 재생 갑옷', description: '초당 최대 체력의 1%를 회복합니다.', apply: p => p.regeneration = (p.regeneration || 0) + (p.maxHp * 0.01) },
        { id: 'thorns', title: '에너지 가시', description: '플레이어에게 닿는 적에게 20의 피해를 입힙니다.', apply: p => p.thornsDamage = (p.thornsDamage || 0) + 20 },
        { id: 'chain-reaction', title: '연쇄 폭발', description: '적이 죽을 때 15% 확률로 폭발하여 주변에 피해를 줍니다.', apply: p => p.chainReactionChance = (p.chainReactionChance || 0) + 0.15 }
    ];
    let availableUpgrades = [...UPGRADES];
    
    function createInitialPlayer(difficulty, weapon) {
        const difficultySettings = DIFFICULTY_SETTINGS[difficulty];
        const weaponSettings = WEAPON_SETTINGS[weapon];
        
        return {
            x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2,
            hp: difficultySettings.hp, maxHp: difficultySettings.hp,
            xp: 0, level: 1, xpToNextLevel: 10,
            weaponType: weapon,
            fireRate: weaponSettings.fireRate, baseFireRate: weaponSettings.fireRate,
            projectiles: 1, projectileDamage: weaponSettings.damage, projectileType: weaponSettings.projectileType,
            lastShotTime: 0, speed: 220, baseSpeed: 220, pickupRadius: 100,
            dashCooldown: 2000, lastDashTime: 0, isDashing: false, dashDuration: 150, dashSpeed: 750, dashTimer: 0,
            dashDirection: { x: 1, y: 0 }, lastMoveDirection: { x: 1, y: 0 },
            shields: 1, // Start with 1 shield by default
            explosiveProjectiles: false,
            speedBoostTimer: 0, fireRateBoostTimer: 0, invincibilityTimer: 0, magnetTimer: 0,
            drones: 0,
            machineGunShotCount: 0,
            cryoGunShotCount: 0,
            decoyCharges: 0,
            regeneration: 0,
            thornsDamage: 0,
            chainReactionChance: 0,
        };
    }

    function formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
    }

    function togglePause() {
        if (gameState !== 'playing' && gameState !== 'paused') return;
        if (levelUpScreen.classList.contains('hidden') === false) return;

        isPaused = !isPaused;
        
        if (isPaused) {
            gameState = 'paused';
            pauseScreen.classList.remove('hidden');
            cancelAnimationFrame(animationFrameId);
        } else {
            gameState = 'playing';
            pauseScreen.classList.add('hidden');
            lastTime = performance.now();
            animationFrameId = requestAnimationFrame(gameLoop);
        }
    }

    function selectUpgrade(upgrade) {
        upgrade.apply(player);
        availableUpgrades = availableUpgrades.filter(u => u.id !== upgrade.id && u.id !== 'multishot');
        levelUpScreen.classList.add('hidden');
        isPaused = false;
        gameState = 'playing';
        lastTime = performance.now();
        requestAnimationFrame(gameLoop);
    }

    function levelUp() {
        isPaused = true;
        gameState = 'levelup';
        sounds.levelUp();
        
        levelUpOptionsContainer.innerHTML = '';
        const selectedUpgrades = [];
        const tempUpgrades = [...availableUpgrades];
        
        for (let i = 0; i < 3 && tempUpgrades.length > 0; i++) {
            const randomIndex = Math.floor(Math.random() * tempUpgrades.length);
            selectedUpgrades.push(tempUpgrades[randomIndex]);
            tempUpgrades.splice(randomIndex, 1);
        }

        selectedUpgrades.forEach(upgrade => {
            const card = document.createElement('div');
            card.className = 'upgrade-card p-4 sm:p-6 rounded-lg flex flex-col items-center justify-center text-center';
            card.innerHTML = `
                <h3 class="text-xl sm:text-2xl font-bold mb-2 text-glow">${upgrade.title}</h3>
                <p>${upgrade.description}</p>
            `;
            card.onclick = () => selectUpgrade(upgrade);
            levelUpOptionsContainer.appendChild(card);
        });

        levelUpScreen.classList.remove('hidden');
    }
    
    function collectXP(amount) {
        sounds.xp();
        player.xp += amount;
        if (player.xp >= player.xpToNextLevel) {
            player.level++;
            player.xp -= player.xpToNextLevel;
            player.xpToNextLevel = Math.floor(player.xpToNextLevel * 1.5);
            levelUI.textContent = `레벨: ${player.level}`;
            levelUp();
        }
    }
    
    function createDamageText(text, x, y, isCrit = false) {
        damageTexts.push({
            text, x, y,
            alpha: 1,
            timer: 0,
            color: isCrit ? '255, 255, 0' : '255, 255, 255'
        });
    }

    function takeDamage(entity, amount) {
        entity.hp -= amount;
        if (entity.hp <= 0) {
            entity.hp = 0;
        }

        if (entity === player) {
             if (player.invincibilityTimer > 0) return;
             
             if (player.shields > 0) {
                 player.shields--;
                 player.invincibilityTimer = 1000;
                 sounds.shieldDown();
                 return;
             }
            sounds.hit();
        } else {
            createDamageText(String(Math.floor(amount)), entity.x, entity.y, false);
        }
    }
    
    function getSpawnPosition() {
        let x, y;
        const edge = Math.floor(Math.random() * 4);
        if (edge === 0) { // Top
            x = Math.random() * CANVAS_WIDTH;
            y = -30;
        } else if (edge === 1) { // Right
            x = CANVAS_WIDTH + 30;
            y = Math.random() * CANVAS_HEIGHT;
        } else if (edge === 2) { // Bottom
            x = Math.random() * CANVAS_WIDTH;
            y = CANVAS_HEIGHT + 30;
        } else { // Left
            x = -30;
            y = Math.random() * CANVAS_HEIGHT;
        }
        return { x, y };
    }

    function spawnEnemy() {
        if (enemies.length > 150) return;
        
        const { x, y } = getSpawnPosition();
        let enemyType = 'grunt';
        
        const timeFactor = Math.min(gameTime / 180, 1); // Cap difficulty increase at 3 minutes
        const rand = Math.random();

        if (gameTime > 60 && rand < 0.1 + timeFactor * 0.2) {
            enemyType = 'summoner';
        } else if (gameTime > 45 && rand < 0.2 + timeFactor * 0.2) {
            enemyType = 'bomber';
        } else if (gameTime > 30 && rand < 0.4 + timeFactor * 0.2) {
            enemyType = 'shooter';
        } else if (gameTime > 15 && rand < 0.6 + timeFactor * 0.2) {
            enemyType = 'tank';
        }

        const base = ENEMY_TYPES[enemyType];
        const finalHp = base.hp * DIFFICULTY_SETTINGS[selectedDifficulty].enemyHpMult * (1 + gameTime / 120);
        const finalSpeed = base.speed * DIFFICULTY_SETTINGS[selectedDifficulty].enemySpeedMult;
        
        enemies.push({ 
            ...base, 
            x, y, 
            hp: finalHp, 
            maxHp: finalHp, 
            speed: finalSpeed, 
            lastActionTime: 0,
            slowTimer: 0,
            freezeTimer: 0,
            burnTimer: 0,
            burnDamage: 0
        });
    }
    
    function spawnItem() {
        const ITEM_TYPES = ['health', 'speed', 'firerate', 'invincibility', 'magnet', 'nuke'];
        const type = ITEM_TYPES[Math.floor(Math.random() * ITEM_TYPES.length)];
        const x = Math.random() * (CANVAS_WIDTH - 60) + 30;
        const y = Math.random() * (CANVAS_HEIGHT - 60) + 30;
        itemPickups.push({ x, y, type, lifetime: 10000 });
    }

    function spawnBoss() {
        if (bossSpawned) return;
        bossSpawned = true;
        const { x, y } = getSpawnPosition();
        const base = ENEMY_TYPES['boss'];
        const finalHp = base.hp * DIFFICULTY_SETTINGS[selectedDifficulty].enemyHpMult;
        enemies.push({ ...base, x, y, hp: finalHp, maxHp: finalHp, lastActionTime: 0 });
    }
    
    function shoot(targetX, targetY) {
        if (performance.now() - player.lastShotTime < player.fireRate) return;
        player.lastShotTime = performance.now();
        sounds.shoot();

        const weapon = WEAPON_SETTINGS[player.weaponType];
        
        for (let i = 0; i < player.projectiles; i++) {
            let angle = Math.atan2(targetY - player.y, targetX - player.x);
            if (player.projectiles > 1) {
                angle += (i - (player.projectiles - 1) / 2) * 0.2;
            }
            
            let projectileSpeed = 300;
            let lifetime = 2000;
            
            const projectile = {
                x: player.x,
                y: player.y,
                damage: player.projectileDamage,
                type: player.projectileType,
                owner: 'player',
                lifetime: lifetime,
                explosive: player.explosiveProjectiles,
                explosionRadius: 50,
            };
            
            switch (player.projectileType) {
                case 'missile':
                    projectile.vx = Math.cos(angle) * 150;
                    projectile.vy = Math.sin(angle) * 150;
                    projectile.target = enemies.length > 0 ? enemies.reduce((closest, e) => {
                        const dist = Math.hypot(e.x - player.x, e.y - player.y);
                        return dist < closest.dist ? { dist, e } : closest;
                    }, { dist: Infinity, e: null }).e : null;
                    projectile.explosionRadius = weapon.explosionRadius;
                    break;
                case 'laser':
                    projectile.vx = Math.cos(angle) * 600;
                    projectile.vy = Math.sin(angle) * 600;
                    projectile.lifetime = 1200;
                    projectile.pierce = true;
                    projectile.slowAmount = weapon.slowAmount;
                    projectile.slowDuration = weapon.slowDuration;
                    break;
                case 'arrow':
                    projectile.vx = Math.cos(angle) * 450;
                    projectile.vy = Math.sin(angle) * 450;
                    projectile.pierce = true;
                    projectile.critChance = weapon.critChance;
                    projectile.critMultiplier = weapon.critMultiplier;
                    break;
                case 'lightning':
                    projectile.target = enemies.length > 0 ? enemies[Math.floor(Math.random() * enemies.length)] : null;
                    projectile.bouncesLeft = weapon.bounces;
                    projectile.bounceRange = 150;
                    projectile.hitEnemies = new Set();
                    if (!projectile.target) return;
                    break;
                 case 'black-hole-orb':
                    projectile.vx = Math.cos(angle) * 100;
                    projectile.vy = Math.sin(angle) * 100;
                    projectile.lifetime = 3000;
                    break;
                case 'plasma-ball':
                    projectile.vx = Math.cos(angle) * 120;
                    projectile.vy = Math.sin(angle) * 120;
                    projectile.lifetime = 4000;
                    projectile.explosionRadius = weapon.explosionRadius;
                    projectile.burnDamage = weapon.burnDamage;
                    projectile.burnDuration = weapon.burnDuration;
                    break;
                 case 'ricochet-blade':
                    projectile.vx = Math.cos(angle) * 250;
                    projectile.vy = Math.sin(angle) * 250;
                    projectile.angularVelocity = 10;
                    projectile.rotation = 0;
                    projectile.bouncesLeft = weapon.bounces;
                    projectile.bounceRange = 200;
                    projectile.hitEnemies = new Set();
                    break;
                case 'chrono-repeater-shot':
                    projectile.vx = Math.cos(angle) * 200;
                    projectile.vy = Math.sin(angle) * 200;
                    projectile.lifetime = 1500;
                    projectile.slowAmount = weapon.slowAmount;
                    projectile.slowDuration = weapon.slowDuration;
                    break;
                case 'glitch-pulse':
                    projectile.vx = Math.cos(angle) * 400;
                    projectile.vy = Math.sin(angle) * 400;
                    projectile.lifetime = 250;
                    projectile.pierce = true;
                    projectile.width = 25;
                    projectile.stunChance = weapon.stunChance;
                    projectile.stunDuration = weapon.stunDuration;
                    break;
                case 'cryo-shard':
                    player.cryoGunShotCount = (player.cryoGunShotCount || 0) + 1;
                    projectile.vx = Math.cos(angle) * 400;
                    projectile.vy = Math.sin(angle) * 400;
                    projectile.slowAmount = weapon.slowAmount;
                    projectile.slowDuration = weapon.slowDuration;
                    if (player.cryoGunShotCount % weapon.freezeOnNthShot === 0) {
                        projectile.shouldFreeze = true;
                        projectile.freezeDuration = weapon.freezeDuration;
                    }
                    break;
                case 'bullet':
                default:
                    player.machineGunShotCount = (player.machineGunShotCount || 0) + 1;
                    let knockback = 0;
                    if(player.machineGunShotCount % 8 === 0) {
                        knockback = weapon.knockback;
                    }
                    projectile.knockback = knockback;
                    projectile.vx = Math.cos(angle) * projectileSpeed;
                    projectile.vy = Math.sin(angle) * projectileSpeed;
                    break;
            }
            projectiles.push(projectile);
        }
    }
    
    function createExplosion(x, y, radius, damage) {
        if (radius <= 0) return;
        explosions.push({ x, y, radius, maxRadius: radius, duration: 200, timer: 0, damage: damage });
        sounds.explosion();
        // Screen shake
        gameWrapper.style.transform = `translate(${Math.random()*10-5}px, ${Math.random()*10-5}px)`;
        setTimeout(() => gameWrapper.style.transform = '', 100);
    }
    
    function resetCombo() {
        comboCount = 0;
        comboUI.textContent = '';
    }

    // --- Update Functions ---
    
    function tryDash() {
        if (performance.now() - player.lastDashTime < player.dashCooldown) return;

        player.isDashing = true;
        player.dashTimer = player.dashDuration;
        player.lastDashTime = performance.now();
        player.invincibilityTimer = player.dashDuration + 100; // a bit of grace period
        
        player.dashDirection.x = player.lastMoveDirection.x;
        player.dashDirection.y = player.lastMoveDirection.y;
        
        sounds.dash();
    }

    function updatePlayer(deltaTime) {
        if (player.isDashing) {
            player.dashTimer -= deltaTime * 1000;
            if (player.dashTimer <= 0) {
                player.isDashing = false;
                return;
            }

            player.x += player.dashDirection.x * player.dashSpeed * deltaTime;
            player.y += player.dashDirection.y * player.dashSpeed * deltaTime;
            
            player.x = Math.max(PLAYER_SIZE / 2, Math.min(CANVAS_WIDTH - PLAYER_SIZE / 2, player.x));
            player.y = Math.max(PLAYER_SIZE / 2, Math.min(CANVAS_HEIGHT - PLAYER_SIZE / 2, player.y));

            if (Math.random() > 0.3) {
                 afterimages.push({ x: player.x, y: player.y, size: PLAYER_SIZE, alpha: 0.6, lifetime: 250, maxLifetime: 250 });
            }

            return; // Skip normal movement
        }

        // Base stats
        player.speed = player.baseSpeed;
        player.fireRate = player.baseFireRate;

        // Apply boosts
        if (player.speedBoostTimer > 0) {
            player.speedBoostTimer -= deltaTime * 1000;
            player.speed *= 1.5;
        }
        if (player.fireRateBoostTimer > 0) {
            player.fireRateBoostTimer -= deltaTime * 1000;
            player.fireRate *= 0.5;
        }
        if (player.invincibilityTimer > 0) {
            player.invincibilityTimer -= deltaTime * 1000;
        }
        if (player.magnetTimer > 0) {
            player.magnetTimer -= deltaTime * 1000;
        }

        // Movement
        let dx = 0;
        let dy = 0;

        if (movementJoystickState.active) {
            dx = movementJoystickState.dx;
            dy = movementJoystickState.dy;
        } else {
            if (keysPressed.w || keysPressed.ArrowUp) dy -= 1;
            if (keysPressed.s || keysPressed.ArrowDown) dy += 1;
            if (keysPressed.a || keysPressed.ArrowLeft) dx -= 1;
            if (keysPressed.d || keysPressed.ArrowRight) dx += 1;
        }

        const len = Math.hypot(dx, dy);
        if (len > 0) {
            dx /= len;
            dy /= len;
            player.x += dx * player.speed * deltaTime;
            player.y += dy * player.speed * deltaTime;
            player.lastMoveDirection.x = dx;
            player.lastMoveDirection.y = dy;
        }

        player.x = Math.max(PLAYER_SIZE / 2, Math.min(CANVAS_WIDTH - PLAYER_SIZE / 2, player.x));
        player.y = Math.max(PLAYER_SIZE / 2, Math.min(CANVAS_HEIGHT - PLAYER_SIZE / 2, player.y));

        // Auto-shooting
        let closestEnemy = null;
        let minDistance = Infinity;
        enemies.forEach(enemy => {
            const distance = Math.hypot(enemy.x - player.x, enemy.y - player.y);
            if (distance < minDistance) {
                minDistance = distance;
                closestEnemy = enemy;
            }
        });

        if (closestEnemy) {
            shoot(closestEnemy.x, closestEnemy.y);
        }
        
        // Regeneration
        if (player.regeneration > 0) {
            player.hp = Math.min(player.maxHp, player.hp + player.regeneration * deltaTime);
        }
    }
    
    function updateEnemies(deltaTime) {
        enemies.forEach(enemy => {
            if (enemy.freezeTimer > 0) {
                enemy.freezeTimer -= deltaTime * 1000;
                return;
            }
            if (enemy.stunTimer > 0) {
                enemy.stunTimer -= deltaTime * 1000;
                return;
            }

            let currentSpeed = enemy.speed;
            if (enemy.slowTimer > 0) {
                enemy.slowTimer -= deltaTime * 1000;
                currentSpeed *= enemy.slowAmount;
            }
            if (enemy.burnTimer > 0) {
                enemy.burnTimer -= deltaTime * 1000;
                takeDamage(enemy, enemy.burnDamage * deltaTime);
            }

            const dx = player.x - enemy.x;
            const dy = player.y - enemy.y;
            const dist = Math.hypot(dx, dy);
            
            if (dist > 1) {
                enemy.x += (dx / dist) * currentSpeed * deltaTime;
                enemy.y += (dy / dist) * currentSpeed * deltaTime;
            }

            if (dist < PLAYER_SIZE / 2 + enemy.size / 2) {
                takeDamage(player, enemy.damage);
                if (player.thornsDamage > 0) {
                    takeDamage(enemy, player.thornsDamage);
                }
            }

            // Enemy actions
            if (enemy.fireRate && performance.now() - enemy.lastActionTime > enemy.fireRate) {
                enemy.lastActionTime = performance.now();
                const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                enemyProjectiles.push({
                    x: enemy.x, y: enemy.y,
                    vx: Math.cos(angle) * enemy.projectileSpeed,
                    vy: Math.sin(angle) * enemy.projectileSpeed,
                    size: 8, lifetime: 3000, damage: enemy.damage,
                    owner: 'enemy'
                });
            }
            if (enemy.action === 'summon' && performance.now() - enemy.lastActionTime > enemy.actionRate) {
                enemy.lastActionTime = performance.now();
                sounds.summon();
                for (let i = 0; i < 2; i++) {
                    const gruntBase = ENEMY_TYPES['grunt'];
                    const finalHp = gruntBase.hp * DIFFICULTY_SETTINGS[selectedDifficulty].enemyHpMult * (1 + gameTime / 120);
                    enemies.push({ 
                        ...gruntBase, 
                        x: enemy.x + (Math.random() - 0.5) * 50, 
                        y: enemy.y + (Math.random() - 0.5) * 50, 
                        hp: finalHp, 
                        maxHp: finalHp,
                        speed: gruntBase.speed * DIFFICULTY_SETTINGS[selectedDifficulty].enemySpeedMult,
                        lastActionTime: 0
                    });
                }
            }
        });
    }

    function updateProjectiles(deltaTime) {
        [projectiles, enemyProjectiles].forEach((projArray, arrIndex) => {
            for (let i = projArray.length - 1; i >= 0; i--) {
                const proj = projArray[i];
                proj.lifetime -= deltaTime * 1000;

                if (proj.type === 'missile' && proj.target && proj.target.hp > 0) {
                    const angle = Math.atan2(proj.target.y - proj.y, proj.target.x - proj.x);
                    proj.vx += Math.cos(angle) * 300 * deltaTime;
                    proj.vy += Math.sin(angle) * 300 * deltaTime;
                    const speed = Math.hypot(proj.vx, proj.vy);
                    if (speed > 250) {
                        proj.vx = (proj.vx / speed) * 250;
                        proj.vy = (proj.vy / speed) * 250;
                    }
                } else if (proj.type === 'lightning' && proj.target) {
                    const dx = proj.target.x - proj.x;
                    const dy = proj.target.y - proj.y;
                    const dist = Math.hypot(dx, dy);
                    if (dist < 10) {
                        takeDamage(proj.target, proj.damage);
                        proj.hitEnemies.add(proj.target);
                        if (proj.bouncesLeft > 0) {
                            proj.bouncesLeft--;
                            let nextTarget = null;
                            let minDistance = proj.bounceRange;
                            enemies.forEach(e => {
                                if (!proj.hitEnemies.has(e) && e.hp > 0) {
                                    const d = Math.hypot(e.x - proj.target.x, e.y - proj.target.y);
                                    if (d < minDistance) {
                                        minDistance = d;
                                        nextTarget = e;
                                    }
                                }
                            });
                            if (nextTarget) {
                                proj.target = nextTarget;
                            } else {
                                proj.lifetime = 0;
                            }
                        } else {
                            proj.lifetime = 0;
                        }
                    } else {
                       proj.x += (dx / dist) * 1000 * deltaTime;
                       proj.y += (dy / dist) * 1000 * deltaTime;
                    }
                } else if (proj.type === 'black-hole-orb') {
                    proj.x += proj.vx * deltaTime;
                    proj.y += proj.vy * deltaTime;
                    if (proj.lifetime < 10 && !proj.triggered) {
                        proj.triggered = true;
                        blackHoles.push({ x: proj.x, y: proj.y, radius: 10, maxRadius: 96, lifetime: 5000, pullForce: 250, damage: 15 });
                        sounds.blackHole();
                    }
                } else {
                    proj.x += proj.vx * deltaTime;
                    proj.y += proj.vy * deltaTime;
                }
                
                if (proj.type === 'ricochet-blade') {
                    proj.rotation += proj.angularVelocity * deltaTime;
                }

                if (proj.lifetime <= 0) {
                    if (proj.type === 'bomb') {
                        const weapon = WEAPON_SETTINGS['bomb'];
                        for (let j = 0; j < weapon.shrapnelCount; j++) {
                            const angle = Math.random() * 2 * Math.PI;
                            projectiles.push({
                                x: proj.x, y: proj.y,
                                vx: Math.cos(angle) * 200, vy: Math.sin(angle) * 200,
                                damage: proj.damage / 2, lifetime: 500, type: 'shrapnel',
                                owner: 'player'
                            });
                        }
                    } else if (proj.type === 'chrono-repeater-shot') {
                        const weapon = WEAPON_SETTINGS['chrono-repeater'];
                        for (let j = 0; j < weapon.splitCount; j++) {
                            const angle = (j / weapon.splitCount) * 2 * Math.PI;
                            projectiles.push({
                                x: proj.x, y: proj.y,
                                vx: Math.cos(angle) * 250,
                                vy: Math.sin(angle) * 250,
                                damage: proj.damage / 2,
                                lifetime: 400,
                                type: 'chrono-repeater-fragment',
                                owner: 'player'
                            });
                        }
                    } else if (proj.type === 'missile' || proj.type === 'plasma-ball') {
                        createExplosion(proj.x, proj.y, proj.explosionRadius, proj.damage);
                        if(proj.type === 'plasma-ball'){
                            enemies.forEach(enemy => {
                                const dist = Math.hypot(enemy.x - proj.x, enemy.y - proj.y);
                                if (dist < proj.explosionRadius) {
                                    enemy.burnTimer = proj.burnDuration;
                                    enemy.burnDamage = proj.burnDamage;
                                }
                            });
                        }
                    }
                    projArray.splice(i, 1);
                    continue;
                }

                if (proj.owner === 'player') {
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        const enemy = enemies[j];
                        if (proj.hitEnemies && proj.hitEnemies.has(enemy)) continue;

                        const dist = Math.hypot(proj.x - enemy.x, proj.y - enemy.y);
                        if (dist < enemy.size / 2) {
                            let finalDamage = proj.damage;
                            let isCrit = false;
                            if (proj.critChance && Math.random() < proj.critChance) {
                                finalDamage *= proj.critMultiplier;
                                isCrit = true;
                            }
                            createDamageText(String(Math.floor(finalDamage)), enemy.x, enemy.y, isCrit);
                            takeDamage(enemy, finalDamage);
                            
                            if (proj.knockback) {
                                const angle = Math.atan2(enemy.y - player.y, enemy.x - player.x);
                                enemy.x += Math.cos(angle) * proj.knockback;
                                enemy.y += Math.sin(angle) * proj.knockback;
                            }
                            if(proj.slowAmount){
                                enemy.slowTimer = proj.slowDuration;
                                enemy.slowAmount = 1 - proj.slowAmount;
                            }
                            if(proj.shouldFreeze){
                                enemy.freezeTimer = proj.freezeDuration;
                                sounds.freeze();
                            }
                            if(proj.stunChance && Math.random() < proj.stunChance) {
                                enemy.stunTimer = proj.stunDuration;
                            }
                            
                            if (proj.type === 'black-hole-orb' || proj.type === 'bomb') {
                                proj.lifetime = 1; // Trigger end-of-life effect on next frame
                            }

                            if (proj.explosive) {
                                createExplosion(proj.x, proj.y, proj.explosionRadius, proj.damage / 2);
                            }
                            
                            if (proj.type === 'ricochet-blade' || proj.type === 'lightning') { // For now, lightning is handled differently
                                if(proj.hitEnemies) proj.hitEnemies.add(enemy);

                                if (proj.bouncesLeft > 0) {
                                    proj.bouncesLeft--;
                                    let nextTarget = null;
                                    let minDistance = proj.bounceRange;
                                    enemies.forEach(e => {
                                        if (!proj.hitEnemies.has(e) && e.hp > 0) {
                                            const d = Math.hypot(e.x - enemy.x, e.y - enemy.y);
                                            if (d < minDistance) {
                                                minDistance = d;
                                                nextTarget = e;
                                            }
                                        }
                                    });
                                    if (nextTarget) {
                                        const angle = Math.atan2(nextTarget.y - proj.y, nextTarget.x - proj.x);
                                        const speed = Math.hypot(proj.vx, proj.vy);
                                        proj.vx = Math.cos(angle) * speed;
                                        proj.vy = Math.sin(angle) * speed;
                                    } else {
                                        projArray.splice(i, 1);
                                    }
                                } else {
                                   projArray.splice(i, 1);
                                }
                            } else if (!proj.pierce) {
                                projArray.splice(i, 1);
                            }
                            
                            break; 
                        }
                    }
                } else { // Enemy projectile
                    const dist = Math.hypot(proj.x - player.x, proj.y - player.y);
                    if (dist < PLAYER_SIZE / 2) {
                        takeDamage(player, proj.damage);
                        projArray.splice(i, 1);
                    }
                }
            }
        });
    }
    
    function applyItemEffect(type) {
        sounds.powerup();
        switch (type) {
            case 'health':
                player.hp = Math.min(player.maxHp, player.hp + player.maxHp * 0.25);
                sounds.heal();
                break;
            case 'speed':
                player.speedBoostTimer = 5000;
                break;
            case 'firerate':
                player.fireRateBoostTimer = 5000;
                break;
            case 'invincibility':
                player.invincibilityTimer = 5000;
                sounds.shieldUp();
                break;
            case 'magnet':
                player.magnetTimer = 8000;
                break;
            case 'nuke':
                enemies.forEach(enemy => {
                    xpGems.push({ x: enemy.x, y: enemy.y, value: enemy.xp });
                });
                enemies.length = 0;
                nukeEffect = { timer: 500, duration: 500 };
                sounds.nuke();
                break;
        }
    }

    function updateItems(deltaTime) {
        // XP Gems
        for (let i = xpGems.length - 1; i >= 0; i--) {
            const gem = xpGems[i];
            const dx = player.x - gem.x;
            const dy = player.y - gem.y;
            const dist = Math.hypot(dx, dy);
            
            const currentPickupRadius = player.pickupRadius * (player.magnetTimer > 0 ? 3 : 1);

            if (dist < currentPickupRadius) {
                gem.x += (dx / dist) * 300 * deltaTime;
                gem.y += (dy / dist) * 300 * deltaTime;
            }
            if (dist < PLAYER_SIZE / 2) {
                collectXP(gem.value);
                xpGems.splice(i, 1);
            }
        }
        
        // Item Pickups
        for (let i = itemPickups.length - 1; i >= 0; i--) {
            const item = itemPickups[i];
            item.lifetime -= deltaTime * 1000;
            if (item.lifetime <= 0) {
                itemPickups.splice(i, 1);
                continue;
            }
            
            const dist = Math.hypot(player.x - item.x, player.y - item.y);
            if (dist < PLAYER_SIZE / 2 + 15) {
                applyItemEffect(item.type);
                itemPickups.splice(i, 1);
            }
        }
    }
    
    function updateBlackHoles(deltaTime) {
        for (let i = blackHoles.length - 1; i >= 0; i--) {
            const bh = blackHoles[i];
            bh.lifetime -= deltaTime * 1000;
            if (bh.lifetime <= 0) {
                blackHoles.splice(i, 1);
                continue;
            }
            if(bh.radius < bh.maxRadius) bh.radius += 50 * deltaTime;
            
            enemies.forEach(enemy => {
                const dx = bh.x - enemy.x;
                const dy = bh.y - enemy.y;
                const dist = Math.hypot(dx, dy);
                if (dist < bh.radius) {
                    enemy.x += (dx / dist) * bh.pullForce * deltaTime;
                    enemy.y += (dy / dist) * bh.pullForce * deltaTime;
                    if(dist < 15) takeDamage(enemy, bh.damage * deltaTime * 5); // Increased damage close to center
                }
            });
        }
    }

    function updateAfterimages(deltaTime) {
        for (let i = afterimages.length - 1; i >= 0; i--) {
            const img = afterimages[i];
            img.lifetime -= deltaTime * 1000;
            if (img.lifetime <= 0) {
                afterimages.splice(i, 1);
            } else {
                img.alpha = (img.lifetime / img.maxLifetime) * 0.5;
            }
        }
    }
    
    function updateDrones(deltaTime) {
        if (!player || player.drones <= 0) return;
        drones.forEach((drone, i) => {
            const angle = (gameTime * 1.5) + (i * (2 * Math.PI / player.drones));
            drone.x = player.x + Math.cos(angle) * 60;
            drone.y = player.y + Math.sin(angle) * 60;
            
            drone.shotTimer -= deltaTime * 1000;
            if (drone.shotTimer <= 0) {
                let closestEnemy = null;
                let minDistance = 250; // Drone range
                enemies.forEach(enemy => {
                    const distance = Math.hypot(enemy.x - drone.x, enemy.y - drone.y);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestEnemy = enemy;
                    }
                });
                
                if (closestEnemy) {
                    const pAngle = Math.atan2(closestEnemy.y - drone.y, closestEnemy.x - drone.x);
                    projectiles.push({
                        x: drone.x, y: drone.y,
                        vx: Math.cos(pAngle) * 350, vy: Math.sin(pAngle) * 350,
                        damage: 10, lifetime: 1000, type: 'drone-bullet', owner: 'player'
                    });
                    drone.shotTimer = 1000;
                }
            }
        });
    }

    function updateExplosions(deltaTime) {
        for (let i = explosions.length - 1; i >= 0; i--) {
            const exp = explosions[i];
            exp.timer += deltaTime * 1000;
            if (exp.timer >= exp.duration) {
                // Apply damage once on creation
                if(exp.timer < exp.duration + deltaTime * 1000){ // check to apply only once
                    enemies.forEach(enemy => {
                        const dist = Math.hypot(enemy.x - exp.x, enemy.y - exp.y);
                        if (dist < exp.maxRadius) {
                            takeDamage(enemy, exp.damage);
                        }
                    });
                }
                explosions.splice(i, 1);
            }
        }
    }

    function updateUI() {
        hpBar.style.width = `${(player.hp / player.maxHp) * 100}%`;
        xpBar.style.width = `${(player.xp / player.xpToNextLevel) * 100}%`;
        timerUI.textContent = formatTime(gameTime);
        highscoreUI.textContent = `최고기록: ${formatTime(highScore)}`;
        const rank = getRank(gameTime);
        currentRankUI.textContent = rank.name;
        currentRankUI.style.color = rank.color;
        currentRankUI.style.textShadow = `0 0 8px ${rank.color}`;
        
        if (comboCount > 1) {
            comboUI.textContent = `${comboCount} COMBO!`;
            comboUI.style.animation = 'pulse-glow-yellow 0.5s ease-in-out';
            setTimeout(() => comboUI.style.animation = '', 500);
        } else {
            comboUI.textContent = '';
        }
    }
    
    function update(deltaTime) {
        updatePlayer(deltaTime);
        updateEnemies(deltaTime);
        updateProjectiles(deltaTime);
        updateItems(deltaTime);
        updateBlackHoles(deltaTime);
        updateAfterimages(deltaTime);
        updateDrones(deltaTime);
        updateExplosions(deltaTime);

        for (let i = enemies.length - 1; i >= 0; i--) {
            if (enemies[i].hp <= 0) {
                const enemy = enemies[i];
                if (enemy.onDeath === 'explode') {
                    createExplosion(enemy.x, enemy.y, 60, enemy.damage);
                }
                if (player.chainReactionChance > 0 && Math.random() < player.chainReactionChance) {
                    createExplosion(enemy.x, enemy.y, 50, 20);
                }
                xpGems.push({ x: enemy.x, y: enemy.y, value: enemy.xp });
                enemies.splice(i, 1);
                
                comboCount++;
                lastKillTime = performance.now();
            }
        }
        
        if (performance.now() - lastKillTime > COMBO_TIMEOUT) {
            resetCombo();
        }

        // Spawning logic
        lastSpawnTime += deltaTime * 1000;
        if (lastSpawnTime > spawnInterval) {
            const spawnCount = 1 + Math.floor(gameTime / 20);
            for (let i = 0; i < spawnCount; i++) {
                spawnEnemy();
            }
            lastSpawnTime = 0;
            spawnInterval = Math.max(200, 1500 * (1 - gameTime / 300) * DIFFICULTY_SETTINGS[selectedDifficulty].spawnRateMult);
        }
        
        lastItemSpawnTime += deltaTime * 1000;
        if (lastItemSpawnTime > itemSpawnInterval) {
            spawnItem();
            lastItemSpawnTime = 0;
        }

        if (gameTime > 300 && !bossSpawned) {
             spawnBoss();
        }
        
        updateUI();
    }

    // --- Draw Functions ---

    function drawGrid() {
        ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
        ctx.lineWidth = 1;
        for (let i = 0; i < CANVAS_WIDTH; i += 20) {
            ctx.beginPath();
            ctx.moveTo(i, 0);
            ctx.lineTo(i, CANVAS_HEIGHT);
            ctx.stroke();
        }
        for (let i = 0; i < CANVAS_HEIGHT; i += 20) {
            ctx.beginPath();
            ctx.moveTo(0, i);
            ctx.lineTo(CANVAS_WIDTH, i);
            ctx.stroke();
        }
    }

    function drawPlayer() {
        // Afterimages
        afterimages.forEach(img => {
            ctx.fillStyle = `rgba(0, 255, 255, ${img.alpha})`;
            ctx.beginPath();
            ctx.arc(img.x, img.y, img.size / 2, 0, Math.PI * 2);
            ctx.fill();
        });
        
        ctx.save();
        ctx.translate(player.x, player.y);
        
        // Invincibility shield
        if (player.invincibilityTimer > 0) {
            const alpha = (player.invincibilityTimer % 500) / 500;
            ctx.fillStyle = `rgba(255, 255, 0, ${0.5 * Math.sin(alpha * Math.PI)})`;
            ctx.beginPath();
            ctx.arc(0, 0, PLAYER_SIZE * 1.2, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Player body
        ctx.fillStyle = '#00ffff';
        ctx.beginPath();
        ctx.arc(0, 0, PLAYER_SIZE / 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Player direction indicator
        ctx.beginPath();
        const angle = Math.atan2(player.lastMoveDirection.y, player.lastMoveDirection.x);
        ctx.moveTo(0, 0);
        ctx.lineTo(Math.cos(angle) * (PLAYER_SIZE), Math.sin(angle) * (PLAYER_SIZE));
        ctx.stroke();
        
        // Orbital shields
        for (let i = 0; i < player.shields; i++) {
            const shieldAngle = (gameTime * 2) + (i * (2 * Math.PI / player.shields));
            const x = Math.cos(shieldAngle) * 40;
            const y = Math.sin(shieldAngle) * 40;
            ctx.fillStyle = '#00ffff';
            ctx.beginPath();
            ctx.arc(x, y, 5, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.restore();
    }
    
    function drawEnemies() {
        enemies.forEach(enemy => {
            ctx.save();
            ctx.translate(enemy.x, enemy.y);
            
            ctx.fillStyle = enemy.color;
             if (enemy.freezeTimer > 0) {
                ctx.fillStyle = '#ADD8E6';
            } else if (enemy.slowTimer > 0) {
                 ctx.fillStyle = '#87CEEB';
            }
            if(enemy.burnTimer > 0 && Math.floor(performance.now() / 100) % 2 === 0){
                ctx.fillStyle = '#FFA500';
            }

            if (enemy.shape === 'triangle') {
                ctx.beginPath();
                ctx.moveTo(0, -enemy.size / 2);
                ctx.lineTo(-enemy.size / 2, enemy.size / 2);
                ctx.lineTo(enemy.size / 2, enemy.size / 2);
                ctx.closePath();
                ctx.fill();
            } else { // square
                ctx.fillRect(-enemy.size / 2, -enemy.size / 2, enemy.size, enemy.size);
            }

            // HP bar
            if (enemy.hp < enemy.maxHp) {
                ctx.fillStyle = '#333';
                ctx.fillRect(-enemy.size, -enemy.size / 2 - 10, enemy.size * 2, 5);
                ctx.fillStyle = 'red';
                ctx.fillRect(-enemy.size, -enemy.size / 2 - 10, enemy.size * 2 * (enemy.hp / enemy.maxHp), 5);
            }
            
            ctx.restore();
        });
    }

    function drawProjectiles() {
        [projectiles, enemyProjectiles].forEach(projArray => {
            projArray.forEach(proj => {
                ctx.save();
                ctx.translate(proj.x, proj.y);
                ctx.fillStyle = proj.owner === 'player' ? '#00ffff' : '#ff00ff';
                
                if (proj.type === 'missile') {
                    const angle = Math.atan2(proj.vy, proj.vx);
                    ctx.rotate(angle);
                    ctx.beginPath();
                    ctx.moveTo(3, 0);
                    ctx.lineTo(-3, -2);
                    ctx.lineTo(-3, 2);
                    ctx.closePath();
                    ctx.fill();
                } else if (proj.type === 'laser') {
                    const angle = Math.atan2(proj.vy, proj.vx);
                    ctx.rotate(angle);
                    ctx.fillRect(-10, -1.5, 20, 3);
                } else if (proj.type === 'arrow') {
                    const angle = Math.atan2(proj.vy, proj.vx);
                    ctx.rotate(angle);
                    ctx.fillRect(-8, -1, 16, 2);
                } else if (proj.type === 'bomb' || proj.type === 'shrapnel') {
                    ctx.beginPath();
                    ctx.arc(0, 0, proj.type === 'bomb' ? 5 : 2, 0, Math.PI * 2);
                    ctx.fill();
                } else if (proj.type === 'lightning') {
                    if (proj.target) {
                        ctx.restore(); // ignore translate
                        ctx.strokeStyle = '#f0f000';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(proj.x, proj.y);
                        ctx.lineTo(proj.target.x, proj.target.y);
                        ctx.stroke();
                        ctx.save(); // save for next iteration
                        ctx.translate(proj.x, proj.y); // re-apply for ctx.restore() at the end
                    }
                } else if (proj.type === 'black-hole-orb' || proj.type === 'plasma-ball') {
                    ctx.beginPath();
                    ctx.arc(0, 0, proj.type === 'plasma-ball' ? 8 : 5, 0, Math.PI * 2);
                    ctx.fill();
                } else if (proj.type === 'ricochet-blade') {
                    ctx.rotate(proj.rotation);
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(-6, -6, 12, 12);
                } else if (proj.type === 'chrono-repeater-shot' || proj.type === 'chrono-repeater-fragment') {
                    ctx.beginPath();
                    ctx.arc(0, 0, proj.type === 'chrono-repeater-shot' ? 4 : 2, 0, Math.PI * 2);
                    ctx.fill();
                } else if (proj.type === 'glitch-pulse') {
                    const angle = Math.atan2(proj.vy, proj.vx);
                    ctx.rotate(angle);
                    ctx.globalAlpha = proj.lifetime / 250;
                    ctx.fillRect(-10, -proj.width / 2, 20, proj.width);
                } else if (proj.type === 'cryo-shard') {
                    ctx.fillStyle = '#a8dadc';
                    ctx.fillRect(-3, -3, 6, 6);
                } else if (proj.owner === 'enemy') {
                    ctx.beginPath();
                    ctx.arc(0, 0, proj.size / 2, 0, Math.PI * 2);
                    ctx.fill();
                } else { // Default bullet & drone bullet
                    ctx.beginPath();
                    ctx.arc(0, 0, 2.5, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            });
        });
    }

    function drawItems() {
        xpGems.forEach(gem => {
            ctx.fillStyle = '#00f7ff';
            ctx.beginPath();
            ctx.arc(gem.x, gem.y, 4, 0, Math.PI * 2);
            ctx.fill();
        });
        
        itemPickups.forEach(item => {
            ctx.save();
            ctx.translate(item.x, item.y);
            const size = 15;
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            
            let color = '#fff';
            let text = '?';
            
            switch (item.type) {
                case 'health': color = '#ff4d4d'; text = '+'; break;
                case 'speed': color = '#fcf003'; text = 'S'; break;
                case 'firerate': color = '#c084fc'; text = 'F'; break;
                case 'invincibility': color = '#facc15'; text = 'I'; break;
                case 'magnet': color = '#60a5fa'; text = 'M'; break;
                case 'nuke': color = '#ff8c66'; text = 'N'; break;
            }
            
            ctx.fillStyle = color;
            ctx.globalAlpha = item.lifetime < 1000 ? (item.lifetime / 1000) : 1;
            
            ctx.beginPath();
            ctx.arc(0, 0, size, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            ctx.fillStyle = '#0d0221';
            ctx.font = 'bold 18px Orbitron';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 0, 1);
            
            ctx.restore();
        });
    }
    
    function drawExplosions() {
        explosions.forEach(exp => {
            const progress = exp.timer / exp.duration;
            const currentRadius = exp.maxRadius * progress;
            ctx.fillStyle = `rgba(255, 255, 255, ${1 - progress})`;
            ctx.beginPath();
            ctx.arc(exp.x, exp.y, currentRadius, 0, Math.PI * 2);
            ctx.fill();
        });
    }

    function drawDrones() {
         drones.forEach(drone => {
            ctx.fillStyle = '#00ffff';
            ctx.beginPath();
            ctx.arc(drone.x, drone.y, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1.5;
            ctx.stroke();
        });
    }

    function drawBlackHoles() {
        blackHoles.forEach(bh => {
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(bh.x, bh.y, bh.radius, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = '#c084fc';
            ctx.lineWidth = 3;
            ctx.setLineDash([10, 5]);
            ctx.stroke();
            ctx.setLineDash([]);
        });
    }

    function drawDamageTexts() {
        damageTexts.forEach((dt, i) => {
            dt.timer += 16;
            dt.y -= 1;
            dt.alpha -= 0.02;
            if (dt.alpha <= 0) {
                damageTexts.splice(i, 1);
            }
            ctx.fillStyle = `rgba(${dt.color}, ${dt.alpha})`;
            ctx.font = 'bold 16px Orbitron';
            ctx.textAlign = 'center';
            ctx.fillText(dt.text, dt.x, dt.y);
        });
    }
    
    function drawNukeEffect() {
        if (!nukeEffect) return;
        nukeEffect.timer -= 16;
        if (nukeEffect.timer <= 0) {
            nukeEffect = null;
            return;
        }
        const progress = 1 - (nukeEffect.timer / nukeEffect.duration);
        ctx.fillStyle = `rgba(255, 255, 255, ${0.8 * (1-progress)})`;
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    }
    
    function draw() {
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        drawGrid();
        drawItems();
        drawEnemies();
        drawPlayer();
        drawProjectiles();
        drawExplosions();
        drawDrones();
        drawBlackHoles();
        drawDamageTexts();
        drawNukeEffect();
    }
    
    // --- Game Flow ---

    function gameOver() {
        gameState = 'gameover';
        cancelAnimationFrame(animationFrameId);
        
        if (gameTime > highScore) {
            highScore = gameTime;
            localStorage.setItem('neonSurvivorHighScore', highScore);
            newHighscoreMessage.classList.remove('hidden');
        } else {
            newHighscoreMessage.classList.add('hidden');
        }

        const finalRank = getRank(gameTime);
        gameOverTimeUI.textContent = `생존 시간: ${formatTime(gameTime)}`;
        gameOverRankUI.textContent = `랭크: ${finalRank.name}`;
        gameOverHighscoreUI.textContent = `최고 기록: ${formatTime(highScore)}`;
        gameOverScreen.classList.remove('hidden');
    }

    function gameLoop(currentTime) {
        if (isPaused || gameState !== 'playing') {
            return;
        }

        if (!lastTime) {
            lastTime = currentTime;
        }
        let deltaTime = (currentTime - lastTime) / 1000;
        lastTime = currentTime;
        
        // Prevent huge lag spikes from crashing the game or causing wild jumps
        if (deltaTime > 0.1) {
            deltaTime = 0.1;
        }
        
        gameTime += deltaTime;
        
        update(deltaTime);
        draw();
        
        if (player.hp > 0) {
            animationFrameId = requestAnimationFrame(gameLoop);
        } else {
            gameOver();
        }
    }

    function startGame() {
        selectedDifficulty = difficultySelection.querySelector('.selected').dataset.difficulty;
        selectedWeapon = weaponSelection.querySelector('.selected').dataset.weapon;
        
        player = createInitialPlayer(selectedDifficulty, selectedWeapon);
        
        enemies = [];
        projectiles = [];
        enemyProjectiles = [];
        xpGems = [];
        itemPickups = [];
        explosions = [];
        damageTexts = [];
        afterimages = [];
        blackHoles = [];

        drones = [];
        for(let i=0; i < (player.drones || 0); i++){
            drones.push({ x: player.x, y: player.y, shotTimer: 1000 });
        }
        
        gameTime = 0;
        lastTime = 0;
        lastSpawnTime = 0;
        spawnInterval = 3000 * DIFFICULTY_SETTINGS[selectedDifficulty].spawnRateMult;
        lastItemSpawnTime = 0;
        itemSpawnInterval = 15000;
        bossSpawned = false;
        
        comboCount = 0;
        lastKillTime = 0;
        
        gameState = 'playing';
        isPaused = false;
        
        startScreen.classList.add('hidden');
        gameOverScreen.classList.add('hidden');
        pauseScreen.classList.add('hidden');
        levelUpScreen.classList.add('hidden');
        pauseButton.classList.remove('hidden');

        updateUI();

        animationFrameId = requestAnimationFrame(gameLoop);
    }
    
    function resetToMenu() {
        gameState = 'start';
        cancelAnimationFrame(animationFrameId);
        
        startScreenHighscoreUI.textContent = `최고 기록: ${formatTime(highScore)}`;
        startScreen.classList.remove('hidden');
        gameOverScreen.classList.add('hidden');
        pauseScreen.classList.add('hidden');
        levelUpScreen.classList.add('hidden');
        pauseButton.classList.add('hidden');
    }
    
    // --- Event Listeners ---
    
    function setupEventListeners() {
        startButton.onclick = startGame;
        restartButton.onclick = startGame;
        pauseButton.onclick = togglePause;
        resumeButton.onclick = togglePause;
        
        restartPauseButton.onclick = () => {
            pauseScreen.classList.add('hidden');
            startGame();
        };
        
        quitButton.onclick = resetToMenu;

        weaponSelection.addEventListener('click', e => {
            if (e.target.tagName === 'BUTTON') {
                weaponSelection.querySelector('.selected').classList.remove('selected');
                e.target.classList.add('selected');
                startButton.disabled = false;
            }
        });

        difficultySelection.addEventListener('click', e => {
            if (e.target.tagName === 'BUTTON') {
                difficultySelection.querySelector('.selected').classList.remove('selected');
                e.target.classList.add('selected');
            }
        });
        
        window.addEventListener('keydown', e => {
            keysPressed[e.key] = true;
            if (e.key === 'p' || e.key === 'Escape') {
                togglePause();
            }
            if (e.key === ' ') {
                e.preventDefault();
                tryDash();
            }
        });
        window.addEventListener('keyup', e => {
            keysPressed[e.key] = false;
        });

        canvas.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            mousePos.x = (e.clientX - rect.left) * (CANVAS_WIDTH / rect.width);
            mousePos.y = (e.clientY - rect.top) * (CANVAS_HEIGHT / rect.height);
        });

        // Touch controls
        const isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        if (isMobile) {
            movementJoystickUI.classList.remove('hidden');
        }

        function handleTouchStart(e) {
            e.preventDefault();
            const now = performance.now();
            
            for (const touch of e.changedTouches) {
                if (movementJoystickState.touchId === null && touch.clientX < window.innerWidth / 2) {
                    movementJoystickState.touchId = touch.identifier;
                    movementJoystickState.active = true;
                    movementJoystickState.startX = touch.clientX;
                    movementJoystickState.startY = touch.clientY;
                    
                    const rect = gameWrapper.getBoundingClientRect();
                    movementJoystickUI.style.left = `${touch.clientX - rect.left - JOYSTICK_BASE_RADIUS}px`;
                    movementJoystickUI.style.top = `${touch.clientY - rect.top - JOYSTICK_BASE_RADIUS}px`;
                    movementJoystickUI.classList.add('active');
                } else { // Right side of screen
                    if (now - movementJoystickState.lastTapTime < 300) { // Double tap to dash
                         tryDash();
                    }
                    movementJoystickState.lastTapTime = now;
                }
            }
        }
        
        function handleTouchMove(e) {
            e.preventDefault();
            for (const touch of e.changedTouches) {
                if (touch.identifier === movementJoystickState.touchId) {
                    let dx = touch.clientX - movementJoystickState.startX;
                    let dy = touch.clientY - movementJoystickState.startY;
                    const dist = Math.hypot(dx, dy);

                    if (dist > JOYSTICK_MAX_OFFSET) {
                        dx = (dx / dist) * JOYSTICK_MAX_OFFSET;
                        dy = (dy / dist) * JOYSTICK_MAX_OFFSET;
                    }
                    
                    movementJoystickHandle.style.transform = `translate(${dx}px, ${dy}px)`;
                    
                    const magnitude = Math.hypot(dx, dy);
                    if (magnitude > JOYSTICK_DEAD_ZONE) {
                       movementJoystickState.dx = dx / magnitude;
                       movementJoystickState.dy = dy / magnitude;
                    } else {
                       movementJoystickState.dx = 0;
                       movementJoystickState.dy = 0;
                    }
                }
            }
        }
        
        function handleTouchEnd(e) {
            e.preventDefault();
            for (const touch of e.changedTouches) {
                if (touch.identifier === movementJoystickState.touchId) {
                    movementJoystickState.touchId = null;
                    movementJoystickState.active = false;
                    movementJoystickState.dx = 0;
                    movementJoystickState.dy = 0;
                    movementJoystickUI.classList.remove('active');
                    movementJoystickHandle.style.transform = 'translate(0px, 0px)';
                }
            }
        }

        gameWrapper.addEventListener('touchstart', handleTouchStart, { passive: false });
        gameWrapper.addEventListener('touchmove', handleTouchMove, { passive: false });
        gameWrapper.addEventListener('touchend', handleTouchEnd, { passive: false });
        gameWrapper.addEventListener('touchcancel', handleTouchEnd, { passive: false });
    }

    function init() {
        startScreenHighscoreUI.textContent = `최고 기록: ${formatTime(highScore)}`;
        setupEventListeners();
    }
    
    init();
});
</script>
</body>
</html>

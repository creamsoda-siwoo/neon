
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>ÎÑ§Ïò® ÏÑúÎ∞îÏù¥Î≤Ñ</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      font-family: 'Orbitron', sans-serif;
      overflow: hidden;
      background-color: #0d0221;
      color: white;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      margin: 0;
      padding: 1rem;
      touch-action: none;
    }
    .game-container {
      background: #0a0a1f;
      border: 2px solid #00ffff;
      box-shadow: 0 0 20px #00ffff, inset 0 0 20px #00ffff;
      width: 90vmin;
      aspect-ratio: 4 / 3;
      touch-action: none;
    }
    #game-canvas {
      background-color: #0d0221;
      cursor: none;
      width: 100%;
      height: 100%;
      display: block;
    }
    .text-glow {
      color: #fff;
      text-shadow: 0 0 7px #fff, 0 0 10px #fff, 0 0 21px #ff00ff, 0 0 42px #ff00ff;
    }
    .button-retro {
      background-color: transparent;
      border: 2px solid #fff;
      color: #fff;
      padding: 0.75rem 1.5rem;
      text-transform: uppercase;
      letter-spacing: 2px;
      transition: all 0.2s ease-in-out;
      text-shadow: 0 0 8px #ff00ff;
      cursor: pointer;
    }
    .button-retro:hover:not(:disabled) {
      background-color: #fff;
      color: #0d0221;
      box-shadow: 0 0 20px #fff, 0 0 30px #ff00ff;
    }
    .button-retro:disabled {
        cursor: not-allowed;
        opacity: 0.5;
    }
    .selection-button {
        border-width: 2px;
        border-color: #fff;
        background-color: transparent;
        padding: 0.5rem;
        height: 100%;
        font-size: 0.875rem;
    }
    .selection-button.selected {
        background-color: #00ffff;
        color: #0d0221;
        box-shadow: 0 0 20px #00ffff;
    }
    .upgrade-card {
      border: 2px solid #00ffff;
      background: rgba(13, 2, 33, 0.8);
      transition: all 0.2s ease-in-out;
      cursor: pointer;
    }
    .upgrade-card:hover {
      background: rgba(0, 255, 255, 0.2);
      box-shadow: 0 0 15px #00ffff;
      transform: translateY(-5px);
    }
    .overlay {
        position: absolute;
        inset: 0;
        background-color: rgba(0,0,0,0.85);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
        z-index: 10;
        padding: 1rem;
    }
    .hidden {
        display: none;
    }
    #start-button {
        padding: 1rem 2rem;
        font-size: 1.25rem;
        font-weight: bold;
    }
    @keyframes pulse-glow {
        0% {
            transform: scale(1);
            box-shadow: 0 0 15px #00ffff, 0 0 25px #ff00ff;
        }
        50% {
            transform: scale(1.08);
            box-shadow: 0 0 30px #00ffff, 0 0 50px #ff00ff;
        }
        100% {
            transform: scale(1);
            box-shadow: 0 0 15px #00ffff, 0 0 25px #ff00ff;
        }
    }

    #start-button:not(:disabled) {
        border-color: #00ffff;
        color: #00ffff;
        text-shadow: 0 0 8px #00ffff;
        animation: pulse-glow 2s infinite ease-in-out;
    }
    .joystick {
        position: absolute;
        width: 120px;
        height: 120px;
        pointer-events: none;
    }
    .joystick-base {
        position: absolute;
        width: 100%;
        height: 100%;
        border-radius: 50%;
        background-color: rgba(0, 255, 255, 0.1);
        border: 2px solid rgba(0, 255, 255, 0.4);
        box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
    }
    .joystick-handle {
        position: absolute;
        width: 60px;
        height: 60px;
        top: 30px;
        left: 30px;
        border-radius: 50%;
        background-color: rgba(0, 255, 255, 0.3);
        border: 2px solid rgba(0, 255, 255, 0.8);
        box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
        transition: transform 0.05s linear;
    }
  </style>
</head>
<body>

  <main class="flex flex-col items-center">
    <div class="flex justify-between w-full mb-2 px-2 text-glow" style="max-width: 90vmin;">
        <div class="flex gap-4 items-center">
            <div id="level-ui" class="text-xl">Î†àÎ≤®: 1</div>
            <div id="current-rank-ui" class="text-lg"></div>
        </div>
        <div class="flex flex-col items-center">
            <div id="timer-ui" class="text-2xl font-bold">00:00</div>
            <div id="combo-ui" class="text-xl font-bold text-yellow-400 h-6" style="text-shadow: 0 0 8px #facc15;"></div>
        </div>
        <div id="highscore-ui" class="text-xl text-right">ÏµúÍ≥†Í∏∞Î°ù: 00:00</div>
    </div>
    
    <div class="w-full h-8 mb-2 flex flex-col justify-around" style="max-width: 90vmin;">
        <div class="w-full bg-gray-700 h-3 rounded-full overflow-hidden border border-red-500">
            <div id="hp-bar" class="bg-red-500 h-full" style="width: 100%"></div>
        </div>
        <div class="w-full bg-gray-700 h-3 rounded-full overflow-hidden border border-cyan-400">
            <div id="xp-bar" class="bg-cyan-400 h-full" style="width: 0%"></div>
        </div>
    </div>

    <div id="game-wrapper" class="relative rounded-lg overflow-hidden game-container">
      <canvas id="game-canvas" width="800" height="600"></canvas>
      <button id="pause-button" class="absolute top-2 right-2 text-2xl w-12 h-12 button-retro hidden items-center justify-center" style="padding: 0;">||</button>
      
      <div id="movement-joystick" class="joystick hidden">
        <div class="joystick-base"></div>
        <div class="joystick-handle"></div>
      </div>
      <div id="attack-joystick" class="joystick hidden">
        <div class="joystick-base"></div>
        <div class="joystick-handle"></div>
      </div>
      
      <div id="start-screen" class="overlay">
          <h1 class="text-5xl md:text-6xl font-bold mb-4 text-glow">ÎÑ§Ïò® ÏÑúÎ∞îÏù¥Î≤Ñ</h1>
          <div id="start-screen-highscore" class="text-xl mb-8 text-glow"></div>
          
          <div class="w-full max-w-2xl mt-4">
              <h2 class="text-xl mb-2 text-glow">Î¨¥Í∏∞ ÏÑ†ÌÉù</h2>
              <div id="weapon-selection" class="grid grid-cols-3 gap-2 mb-2">
                  <button class="button-retro selection-button" data-weapon="machine-gun">Í∏∞Í¥ÄÏ¥ù</button>
                  <button class="button-retro selection-button" data-weapon="missile">Ïú†ÎèÑ ÎØ∏ÏÇ¨Ïùº</button>
                  <button class="button-retro selection-button" data-weapon="bomb">Ìè≠ÌÉÑ</button>
                  <button class="button-retro selection-button" data-weapon="shotgun">ÏÉ∑Í±¥</button>
                  <button class="button-retro selection-button" data-weapon="laser">Î†àÏù¥Ï†Ä</button>
                  <button class="button-retro selection-button" data-weapon="bow">Ìôú</button>
                  <button class="button-retro selection-button" data-weapon="spirit-caller">Ï†ïÎ†π ÏÜåÌôòÍ∏∞</button>
                  <button class="button-retro selection-button" data-weapon="chain-lightning">Ïó∞ÏáÑ Î≤àÍ∞ú</button>
                  <button class="button-retro selection-button" data-weapon="black-hole-generator">Î∏îÎûôÌôÄ ÏÉùÏÑ±Í∏∞</button>
                  <button class="button-retro selection-button" data-weapon="plasma-cannon">ÌîåÎùºÏ¶àÎßà Ï∫êÎÖº</button>
                  <button class="button-retro selection-button" data-weapon="ricochet-blade">Î¶¨ÏΩîÏÖ∞ Î∏îÎ†àÏù¥Îìú</button>
                  <button class="button-retro selection-button" data-weapon="splicer-drone">Î∂ÑÏó¥ ÎìúÎ°†</button>
              </div>
              <div id="weapon-stats" class="text-sm h-20 p-2 border-2 border-cyan-400 rounded-lg text-left bg-black bg-opacity-25">
                  <p>Î¨¥Í∏∞ ÏúÑÎ°ú ÎßàÏö∞Ïä§Î•º Ïò¨Î†§ Îä•Î†•ÏπòÎ•º ÌôïÏù∏ÌïòÏÑ∏Ïöî.</p>
              </div>
          </div>

          <button id="start-button" class="button-retro mt-8" disabled>Í≤åÏûÑ ÏãúÏûë</button>
      </div>

      <div id="pause-screen" class="overlay hidden">
          <h2 class="text-6xl font-bold mb-8 text-glow">ÏùºÏãúÏ†ïÏßÄ</h2>
          <div class="flex flex-col gap-4 w-64">
              <button id="resume-button" class="button-retro">Í≥ÑÏÜçÌïòÍ∏∞</button>
              <button id="restart-pause-button" class="button-retro">Îã§Ïãú ÏãúÏûë</button>
              <button id="quit-button" class="button-retro">Í∑∏ÎßåÌïòÍ∏∞</button>
          </div>
      </div>

      <div id="levelup-screen" class="overlay hidden">
          <h2 class="text-5xl font-bold mb-8 text-glow">Î†àÎ≤® ÏóÖ!</h2>
          <div id="levelup-options" class="grid grid-cols-1 md:grid-cols-3 gap-6">
              <!-- Upgrade cards will be injected here -->
          </div>
      </div>

      <div id="gameover-screen" class="overlay hidden">
          <h2 class="text-6xl font-bold mb-4 text-glow">Í≤åÏûÑ Ïò§Î≤Ñ</h2>
          <p id="gameover-time" class="text-3xl mb-2">ÏÉùÏ°¥ ÏãúÍ∞Ñ: 00:00</p>
          <p id="gameover-rank" class="text-2xl mb-6"></p>
          <p id="gameover-highscore" class="text-xl mb-8">ÏµúÍ≥† Í∏∞Î°ù: 00:00</p>
          <button id="restart-button" class="button-retro">ÏÉàÎ°ú ÏãúÏûë</button>
      </div>
    </div>
  </main>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- DOM Elements ---
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    const gameWrapper = document.getElementById('game-wrapper');
    const startScreen = document.getElementById('start-screen');
    const pauseScreen = document.getElementById('pause-screen');
    const levelUpScreen = document.getElementById('levelup-screen');
    const gameOverScreen = document.getElementById('gameover-screen');
    const startButton = document.getElementById('start-button');
    const restartButton = document.getElementById('restart-button');
    const pauseButton = document.getElementById('pause-button');
    const levelUpOptionsContainer = document.getElementById('levelup-options');
    const weaponSelection = document.getElementById('weapon-selection');
    const weaponStatsUI = document.getElementById('weapon-stats');
    const resumeButton = document.getElementById('resume-button');
    const restartPauseButton = document.getElementById('restart-pause-button');
    const quitButton = document.getElementById('quit-button');

    // Joystick UI
    const movementJoystickUI = document.getElementById('movement-joystick');
    const movementJoystickHandle = movementJoystickUI.querySelector('.joystick-handle');
    const attackJoystickUI = document.getElementById('attack-joystick');
    const attackJoystickHandle = attackJoystickUI.querySelector('.joystick-handle');
    
    // UI Elements
    const levelUI = document.getElementById('level-ui');
    const timerUI = document.getElementById('timer-ui');
    const comboUI = document.getElementById('combo-ui');
    const highscoreUI = document.getElementById('highscore-ui');
    const hpBar = document.getElementById('hp-bar');
    const xpBar = document.getElementById('xp-bar');
    const gameOverTimeUI = document.getElementById('gameover-time');
    const gameOverRankUI = document.getElementById('gameover-rank');
    const gameOverHighscoreUI = document.getElementById('gameover-highscore');
    const startScreenHighscoreUI = document.getElementById('start-screen-highscore');
    const currentRankUI = document.getElementById('current-rank-ui');

    // --- Game Constants ---
    const CANVAS_WIDTH = 800;
    const CANVAS_HEIGHT = 600;
    const PLAYER_SIZE = 20;
    const COMBO_TIMEOUT = 2500;

    // --- Ranking System ---
    const RANKS = [
        { name: 'ÎÑ§Ïò® Ï¥àÏã¨Ïûê', threshold: 0, color: '#9ca3af' },
        { name: 'Í∑∏Î¶¨Îìú Îü¨ÎÑà', threshold: 60, color: '#6ee7b7' },
        { name: 'ÏÑúÌÇ∑ Î∏åÎ†àÏù¥Ïª§', threshold: 120, color: '#60a5fa' },
        { name: 'Îç∞Ïù¥ÌÑ∞ Ïä§Ìä∏Î¶¨Î®∏', threshold: 180, color: '#c084fc' },
        { name: 'ÏÇ¨Ïù¥Î≤Ñ Í≤ÄÌà¨ÏÇ¨', threshold: 240, color: '#f87171' },
        { name: 'Ïã†Ïä§Ïõ®Ïù¥Î∏å ÌååÏàòÍæº', threshold: 300, color: '#facc15' },
        { name: 'ÎîîÏßÄÌÑ∏ Ïò§Î≤ÑÎ°úÎìú', threshold: 420, color: '#f472b6' }
    ];

    function getRank(seconds) {
        let currentRank = RANKS[0];
        for (const rank of RANKS) {
            if (seconds >= rank.threshold) {
                currentRank = rank;
            } else {
                break;
            }
        }
        return currentRank;
    }
    
    // --- Enemy Types ---
    const ENEMY_TYPES = {
        'grunt': { size: 15, hp: 10, speed: 70, color: '#ff4d4d', xp: 1, shape: 'square', damage: 5 },
        'tank': { size: 30, hp: 50, speed: 40, color: '#ff8c66', xp: 5, shape: 'square', damage: 15 },
        'shooter': { size: 18, hp: 15, speed: 60, color: '#fcf003', xp: 2, shape: 'triangle', damage: 10, fireRate: 2000, projectileSpeed: 150 },
        'bomber': { size: 20, hp: 20, speed: 80, color: '#ff99cc', xp: 3, shape: 'square', damage: 20, onDeath: 'explode' },
        'summoner': { size: 25, hp: 40, speed: 50, color: '#cc99ff', xp: 8, shape: 'triangle', damage: 5, actionRate: 5000, action: 'summon' },
        'boss': { size: 50, hp: 500, speed: 60, color: '#ff0000', xp: 50, shape: 'square', damage: 25, fireRate: 1000, projectileSpeed: 200 },
    };


    // --- Game Configs ---
    const DIFFICULTY_SETTINGS = {
        'Ïâ¨ÏõÄ': { hp: 120, enemyHpMult: 0.7, enemySpeedMult: 0.8, spawnRateMult: 1.2 },
        'Î≥¥ÌÜµ': { hp: 100, enemyHpMult: 1.0, enemySpeedMult: 1.0, spawnRateMult: 1.0 },
        'Ïñ¥Î†§ÏõÄ': { hp: 80, enemyHpMult: 1.5, enemySpeedMult: 1.2, spawnRateMult: 0.8 },
    };
    const WEAPON_SETTINGS = {
        'machine-gun': { fireRate: 400, damage: 12, projectileType: 'bullet', name: 'Í∏∞Í¥ÄÏ¥ù', knockback: 20, description: 'Í∞ÄÏû• Í∑†ÌòïÏû°Ìûå Î¨¥Í∏∞. 8Î∞úÎßàÎã§ Í∞ïÎ†•Ìïú ÎÑâÎ∞±ÌÉÑ Î∞úÏÇ¨!' },
        'missile': { fireRate: 1000, damage: 40, projectileType: 'missile', name: 'Ïú†ÎèÑ ÎØ∏ÏÇ¨Ïùº', explosionRadius: 70, description: 'Í∞ÄÏû• Í∞ÄÍπåÏö¥ Ï†ÅÏùÑ Ï∂îÏ†ÅÌïòÎ©∞ Îçî ÎÑìÏùÄ Î≤îÏúÑÏóê Ìè≠Î∞ú ÌîºÌï¥Î•º Ï§çÎãàÎã§.' },
        'bomb': { fireRate: 800, damage: 25, projectileType: 'bomb', name: 'Ìè≠ÌÉÑ', shrapnelCount: 5, description: 'Ìè¨Î¨ºÏÑ†ÏúºÎ°ú ÎÇ†ÏïÑÍ∞Ä Ìè≠Î∞úÌïòÎ©∞ 5Í∞úÏùò ÌååÌé∏ÏùÑ Ìù©ÎøåÎ¶ΩÎãàÎã§.' },
        'shotgun': { fireRate: 700, damage: 10, projectileType: 'pellet', name: 'ÏÉ∑Í±¥', pellets: 5, spread: 0.5, knockback: 5, description: 'Í∑ºÍ±∞Î¶¨Ïùò Ï†ÅÎì§ÏùÑ Î∞ÄÏ≥êÎÇ¥Î©∞ Í∞ïÎ†•Ìïú ÌîºÌï¥Î•º Ï§çÎãàÎã§.' },
        'laser': { fireRate: 1200, damage: 45, projectileType: 'laser', name: 'Î†àÏù¥Ï†Ä', slowAmount: 0.5, slowDuration: 1000, description: 'Ï†ÅÏùÑ Í¥ÄÌÜµÌïòÎ©∞ 1Ï¥àÍ∞Ñ Ïù¥Îèô ÏÜçÎèÑÎ•º 50% Í∞êÏÜåÏãúÌÇµÎãàÎã§.' },
        'bow': { fireRate: 600, damage: 25, projectileType: 'arrow', name: 'Ìôú', critChance: 0.15, critMultiplier: 2, description: 'Ï†ÅÏùÑ Í¥ÄÌÜµÌïòÎ©∞ 15% ÌôïÎ•†Î°ú 2Î∞∞Ïùò ÏπòÎ™ÖÌÉÄ ÌîºÌï¥Î•º ÏûÖÌûôÎãàÎã§.' },
        'spirit-caller': { fireRate: 1500, damage: 35, projectileType: 'spirit', name: 'Ï†ïÎ†π ÏÜåÌôòÍ∏∞', description: 'ÏûêÎèôÏúºÎ°ú Ï†ÅÏùÑ Ï∂îÏ†ÅÌïòÎäî ÎÑ§Ïò® Ï†ïÎ†πÏùÑ ÏÜåÌôòÌï©ÎãàÎã§. Îã§Ï§ë Î∞úÏÇ¨ ÏóÖÍ∑∏Î†àÏù¥ÎìúÎäî ÏÜåÌôòÎêòÎäî Ï†ïÎ†πÏùò ÏàòÎ•º ÎäòÎ¶ΩÎãàÎã§.' },
        'chain-lightning': { fireRate: 800, damage: 30, projectileType: 'lightning', name: 'Ïó∞ÏáÑ Î≤àÍ∞ú', bounces: 4, description: 'Ï†ÅÎì§ ÏÇ¨Ïù¥Î•º 4Î≤à ÌäïÍ∏∞Îäî Î≤àÍ∞úÎ•º Î∞úÏÇ¨Ìï©ÎãàÎã§.' },
        'black-hole-generator': { fireRate: 2000, damage: 0, projectileType: 'black-hole-orb', name: 'Î∏îÎûôÌôÄ ÏÉùÏÑ±Í∏∞', description: 'Ï†ÅÏùÑ ÎÅåÏñ¥ÎãπÍ∏∞Í≥† ÏßÄÏÜç ÌîºÌï¥Î•º Ï£ºÎäî ÏÜåÌòï Î∏îÎûôÌôÄÏùÑ Î∞úÏÇ¨Ìï©ÎãàÎã§.' },
        'plasma-cannon': { fireRate: 1800, damage: 50, projectileType: 'plasma-ball', name: 'ÌîåÎùºÏ¶àÎßà Ï∫êÎÖº', explosionRadius: 80, burnDamage: 10, burnDuration: 3000, description: 'ÎäêÎ¶¨ÏßÄÎßå Í∞ïÎ†•Ìïú ÌîåÎùºÏ¶àÎßà Íµ¨Ï≤¥Î•º Î∞úÏÇ¨Ìï©ÎãàÎã§. Íµ¨Ï≤¥Îäî Ìè≠Î∞úÌïòÎ©∞ 3Ï¥àÍ∞Ñ ÌôîÏÉÅ ÌîºÌï¥Î•º ÏûÖÌûôÎãàÎã§.' },
        'ricochet-blade': { fireRate: 750, damage: 20, projectileType: 'ricochet-blade', name: 'Î¶¨ÏΩîÏÖ∞ Î∏îÎ†àÏù¥Îìú', bounces: 3, description: 'Ï†ÅÏóêÍ≤å ÌäïÍ∏∞Îäî ÌöåÏ†Ñ ÏπºÎÇ†ÏùÑ Î∞úÏÇ¨ÌïòÏó¨ ÏµúÎåÄ 4Î™ÖÏùò Ï†ÅÏùÑ Í≥µÍ≤©Ìï©ÎãàÎã§.' },
        'splicer-drone': { fireRate: 2500, damage: 10, projectileType: 'splicer-drone', name: 'Î∂ÑÏó¥ ÎìúÎ°†', shrapnelCount: 8, shrapnelDamage: 5, description: 'Ï†ÅÏùÑ Ï∂îÏ†ÅÌïòÎäî ÎìúÎ°†ÏùÑ Î∞úÏÇ¨Ìï©ÎãàÎã§. ÎìúÎ°†ÏùÄ Ï†ÅÏóêÍ≤å ÎãøÏúºÎ©¥ 8Í∞úÏùò ÏûëÏùÄ ÌååÌé∏ÏúºÎ°ú Î∂ÑÏó¥Îê©ÎãàÎã§.' }
    };
   
    // --- Audio ---
    let audioContext;
    try { audioContext = new (window.AudioContext || window.webkitAudioContext)(); }
    catch (e) { console.error("Web Audio API is not supported in this browser"); }

    function playSound(type, frequency, duration, volume = 0.3) {
        if (!audioContext) return;
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        oscillator.type = type;
        oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
        gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.00001, audioContext.currentTime + duration);
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + duration);
    }
    const sounds = {
        hit: () => playSound('square', 150, 0.1, 0.2),
        shoot: () => playSound('triangle', 440, 0.05, 0.1),
        xp: () => playSound('sine', 600, 0.1, 0.2),
        levelUp: () => playSound('sine', 880, 0.4),
        heal: () => playSound('sine', 700, 0.3),
        dash: () => playSound('sine', 300, 0.2, 0.4),
        explosion: () => playSound('sine', 50, 0.3, 0.5),
        nuke: () => playSound('sine', 100, 1.0, 0.8),
        powerup: () => playSound('sine', 900, 0.2),
        freeze: () => playSound('sawtooth', 200, 0.5, 0.4),
        shieldUp: () => playSound('sine', 1000, 0.2, 0.5),
        shieldDown: () => playSound('square', 100, 0.2, 0.5),
        blackHole: () => playSound('noise', 100, 2, 0.4),
        summon: () => playSound('sine', 500, 0.3, 0.2),
    };
    
    // --- Game State ---
    let gameState = 'start';
    let isPaused = false;
    let selectedDifficulty, selectedWeapon;
    let player, enemies, projectiles, enemyProjectiles, xpGems, healthPacks, nukes, explosions;
    let orbitalShields, speedBoosts, fireRateBoosts, freezeBombs, invincibilityShields, blackHoleItems;
    let drones, explosiveBarrels, blackHoles;
    let holographicDecoys, decoys;
    let damageTexts;
    let timer, gameTime, lastTime, animationFrameId;
    let lastSpawnTime, spawnInterval;
    let bossSpawned, enemiesFrozen, enemiesFrozenTimer;
    let mousePos = { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2 };
    let keysPressed = {};
    let highScore = Number(localStorage.getItem('neonSurvivorHighScore') || 0);
    let comboCount, lastKillTime;
    let activeTouchCount = 0;

    // Joystick State
    const JOYSTICK_BASE_RADIUS = 60;
    const JOYSTICK_MAX_OFFSET = JOYSTICK_BASE_RADIUS - 30;
    let movementJoystickState = { active: false, x: 0, y: 0, dx: 0, dy: 0, touchId: null, startTime: 0, startX: 0, startY: 0 };
    let attackJoystickState = { active: false, x: 0, y: 0, dx: 0, dy: 0, touchId: null };


    // --- Upgrades ---
    const UPGRADES = [
        { id: 'firerate', title: "Ïó∞ÏÇ¨Î†• Í∞ïÌôî", description: "Í≥µÍ≤© ÏÜçÎèÑ 20% Ï¶ùÍ∞Ä", apply: p => { p.baseFireRate *= 0.8; p.fireRate = p.baseFireRate;} },
        { id: 'damage', title: "Í∞ïÌôî ÌÉÑÌôò", description: "Í≥µÍ≤©Î†• 25% Ï¶ùÍ∞Ä", apply: p => p.projectileDamage *= 1.25 },
        { id: 'multishot', title: "Î©ÄÌã∞ÏÉ∑", description: "Î∞úÏÇ¨Ï≤¥ Ïàò +1", apply: p => p.projectiles++ },
        { id: 'hp', title: "ÎÇòÎÖ∏ ÏàòÎ¶¨Î¥á", description: "ÏµúÎåÄ Ï≤¥Î†• 20 Ï¶ùÍ∞Ä Î∞è Î™®Îëê ÌöåÎ≥µ", apply: p => { p.maxHp += 20; p.hp = p.maxHp; } },
        { id: 'speed', title: "Í≥†ÏÜç Ï∂îÏßÑÍ∏∞", description: "Ïù¥Îèô ÏÜçÎèÑ 10% Ï¶ùÍ∞Ä", apply: p => { p.baseSpeed *= 1.1; p.speed = p.baseSpeed; } },
        { id: 'shield', title: 'Í∂§ÎèÑ Î∞©Ìå®', description: 'Ï£ºÏúÑÎ•º ÎèÑÎäî Î∞©Ìå® Ï∂îÍ∞Ä', apply: p => p.shields++ },
        { id: 'explosive', title: 'Ìè≠Î∞úÌÉÑ', description: 'ÌÉÑÌôòÏù¥ Î™ÖÏ§ë Ïãú Ìè≠Î∞úÌï©ÎãàÎã§', apply: p => p.explosiveProjectiles = true },
        { id: 'magnet', title: 'Í≤ΩÌóòÏπò ÏûêÏÑù', description: 'Í≤ΩÌóòÏπò ÌöçÎìù Î≤îÏúÑ 50% Ï¶ùÍ∞Ä', apply: p => p.pickupRadius *= 1.5 },
        { id: 'drone', title: 'Ïª¥Ìå®ÎãàÏñ∏ ÎìúÎ°†', description: 'ÌîåÎ†àÏù¥Ïñ¥Î•º ÎèïÎäî Í≥µÍ≤© ÎìúÎ°†ÏùÑ Ï∂îÍ∞ÄÌï©ÎãàÎã§.', apply: p => p.drones = (p.drones || 0) + 1 },
    ];
    let availableUpgrades = [...UPGRADES];
    
    function createInitialPlayer(difficulty, weapon) {
        const difficultySettings = DIFFICULTY_SETTINGS[difficulty];
        const weaponSettings = WEAPON_SETTINGS[weapon];
        
        return {
            x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2,
            hp: difficultySettings.hp, maxHp: difficultySettings.hp,
            xp: 0, level: 1, xpToNextLevel: 10,
            weaponType: weapon,
            fireRate: weaponSettings.fireRate, baseFireRate: weaponSettings.fireRate,
            projectiles: 1, projectileDamage: weaponSettings.damage, projectileType: weaponSettings.projectileType,
            lastShotTime: 0, speed: 200, baseSpeed: 200, pickupRadius: 100,
            dashCooldown: 2000, lastDashTime: 0, isDashing: false, dashDuration: 150, dashSpeed: 700,
            shields: 1, // Start with 1 shield by default
            explosiveProjectiles: false,
            speedBoostTimer: 0, fireRateBoostTimer: 0, invincibilityTimer: 0,
            drones: 0,
            machineGunShotCount: 0,
            decoyCharges: 0,
        };
    }

    function formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
    }

    function togglePause() {
        if (gameState !== 'playing' || levelUpScreen.classList.contains('hidden') === false) return;
        isPaused = !isPaused;
        pauseScreen.classList.toggle('hidden', !isPaused);
        if (!isPaused) {
            lastTime = performance.now();
            requestAnimationFrame(gameLoop);
        }
    }
    
    function triggerDash() {
        if (gameState !== 'playing' || isPaused) return;
        const now = performance.now();
        if (now - player.lastDashTime > player.dashCooldown) {
            if (player.decoyCharges > 0) {
                player.decoyCharges--;
                decoys.push({ x: player.x, y: player.y, lifespan: 4000 });
                playSound('sine', 200, 0.2, 0.3);
            }
            player.isDashing = true;
            player.lastDashTime = now;
            sounds.dash();
            setTimeout(() => player.isDashing = false, player.dashDuration);
        }
    }

    // --- Input Handling ---
    function getCanvasCoordinates(clientX, clientY) {
         const rect = canvas.getBoundingClientRect();
         const scaleX = canvas.width / rect.width;
         const scaleY = canvas.height / rect.height;
         return {
             x: (clientX - rect.left) * scaleX,
             y: (clientY - rect.top) * scaleY
         };
    }

    function handleTouchStart(e) {
        if (gameState !== 'playing' || isPaused) return;
        e.preventDefault();
        const rect = gameWrapper.getBoundingClientRect();
        const now = e.timeStamp;

        for (const touch of e.changedTouches) {
            const isLeftHalf = touch.clientX < window.innerWidth / 2;

            if (isLeftHalf && !movementJoystickState.active) {
                const state = movementJoystickState;
                state.active = true;
                state.touchId = touch.identifier;
                state.x = touch.clientX;
                state.y = touch.clientY;
                state.startX = touch.clientX;
                state.startY = touch.clientY;
                state.startTime = now;
                state.dx = 0;
                state.dy = 0;
                
                movementJoystickUI.style.left = `${touch.clientX - rect.left - JOYSTICK_BASE_RADIUS}px`;
                movementJoystickUI.style.top = `${touch.clientY - rect.top - JOYSTICK_BASE_RADIUS}px`;
                movementJoystickUI.classList.remove('hidden');

            } else if (!isLeftHalf && !attackJoystickState.active) {
                const state = attackJoystickState;
                state.active = true;
                state.touchId = touch.identifier;
                state.x = touch.clientX;
                state.y = touch.clientY;
                state.dx = 0;
                state.dy = 0;
                
                attackJoystickUI.style.left = `${touch.clientX - rect.left - JOYSTICK_BASE_RADIUS}px`;
                attackJoystickUI.style.top = `${touch.clientY - rect.top - JOYSTICK_BASE_RADIUS}px`;
                attackJoystickUI.classList.remove('hidden');
            }
        }
        activeTouchCount = e.touches.length;
    }

    function handleTouchMove(e) {
        if (gameState !== 'playing' || isPaused) return;
        e.preventDefault();
        for (const touch of e.changedTouches) {
            let state = null;
            let handle = null;
            if (touch.identifier === movementJoystickState.touchId) {
                state = movementJoystickState;
                handle = movementJoystickHandle;
            } else if (touch.identifier === attackJoystickState.touchId) {
                state = attackJoystickState;
                handle = attackJoystickHandle;
            }

            if (state && handle) {
                const deltaX = touch.clientX - state.x;
                const deltaY = touch.clientY - state.y;
                const dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                const angle = Math.atan2(deltaY, deltaX);

                if (dist > JOYSTICK_MAX_OFFSET) {
                    handle.style.transform = `translate(${Math.cos(angle) * JOYSTICK_MAX_OFFSET}px, ${Math.sin(angle) * JOYSTICK_MAX_OFFSET}px)`;
                    state.dx = Math.cos(angle);
                    state.dy = Math.sin(angle);
                } else {
                    handle.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                    state.dx = deltaX / JOYSTICK_MAX_OFFSET;
                    state.dy = deltaY / JOYSTICK_MAX_OFFSET;
                }
            }
        }
    }

    function handleTouchEnd(e) {
        if (gameState !== 'playing' || isPaused) return;
        e.preventDefault();
        const now = e.timeStamp;
        for (const touch of e.changedTouches) {
            if (touch.identifier === movementJoystickState.touchId) {
                const state = movementJoystickState;
                const duration = now - state.startTime;
                const dist = Math.sqrt((touch.clientX - state.startX)**2 + (touch.clientY - state.startY)**2);

                if (duration < 200 && dist < 20) { // Tap detection
                    triggerDash();
                }

                state.active = false;
                state.touchId = null;
                state.dx = 0;
                state.dy = 0;
                movementJoystickUI.classList.add('hidden');
                movementJoystickHandle.style.transform = 'translate(0, 0)';
            } else if (touch.identifier === attackJoystickState.touchId) {
                const state = attackJoystickState;
                state.active = false;
                state.touchId = null;
                state.dx = 0;
                state.dy = 0;
                attackJoystickUI.classList.add('hidden');
                attackJoystickHandle.style.transform = 'translate(0, 0)';
            }
        }
        activeTouchCount = e.touches.length;
    }


    function init() {
        const rank = getRank(highScore);
        highscoreUI.innerHTML = `ÏµúÍ≥†Í∏∞Î°ù: ${formatTime(highScore)} <span style="color: ${rank.color}; text-shadow: 0 0 5px ${rank.color};">(${rank.name})</span>`;
        startScreenHighscoreUI.innerHTML = `ÏµúÍ≥† Í∏∞Î°ù: ${formatTime(highScore)} &bull; Îû≠ÌÅ¨: <span style="color: ${rank.color}; text-shadow: 0 0 8px ${rank.color};">${rank.name}</span>`;
        
        weaponSelection.addEventListener('mouseover', e => {
            const target = e.target;
            if (target.tagName === 'BUTTON' && target.dataset.weapon) {
                const weaponId = target.dataset.weapon;
                const stats = WEAPON_SETTINGS[weaponId];
                const rpm = Math.round(60000 / stats.fireRate); 
                weaponStatsUI.innerHTML = `
                    <h3 class="text-lg text-cyan-300 font-bold">${stats.name}</h3>
                    <p>Îç∞ÎØ∏ÏßÄ: ${stats.damage || 'ÌäπÏàò'}${stats.pellets ? ' x ' + stats.pellets : ''} / Ïó∞ÏÇ¨ÏÜçÎèÑ: ${rpm} RPM</p>
                    <p>ÌäπÏßï: ${stats.description}</p>
                `;
            }
        });

        weaponSelection.addEventListener('click', e => {
            const target = e.target;
            if (target.tagName === 'BUTTON') {
                selectedWeapon = target.dataset.weapon;
                [...weaponSelection.children].forEach(btn => btn.classList.remove('selected'));
                target.classList.add('selected');
                checkSelections();
            }
        });
        
        selectedDifficulty = 'Î≥¥ÌÜµ';
        const defaultWeapon = weaponSelection.querySelector('[data-weapon="machine-gun"]');
        if(defaultWeapon) defaultWeapon.click();

        startButton.onclick = startGame;
        restartButton.onclick = () => {
            gameOverScreen.classList.add('hidden');
            pauseButton.classList.add('hidden');
            startScreen.classList.remove('hidden');
        };
        pauseButton.onclick = togglePause;
        
        resumeButton.onclick = togglePause;
        restartPauseButton.onclick = () => {
            pauseScreen.classList.add('hidden');
            isPaused = false;
            startGame();
        };
        quitButton.onclick = () => {
            pauseScreen.classList.add('hidden');
            isPaused = false;
            gameState = 'start';
            if(animationFrameId) cancelAnimationFrame(animationFrameId);
            startScreen.classList.remove('hidden');
            pauseButton.classList.add('hidden');
        };
        
        // Input Listeners
        window.addEventListener('keydown', e => {
            keysPressed[e.code] = true;
            if (e.key === "Escape") togglePause();
            if (e.code === 'Space') {
                triggerDash();
            }
        });
        window.addEventListener('keyup', e => { keysPressed[e.code] = false; });
        
        canvas.addEventListener('mousemove', e => {
            if (activeTouchCount === 0) {
                 mousePos = getCanvasCoordinates(e.clientX, e.clientY);
            }
        });
        gameWrapper.addEventListener('touchstart', handleTouchStart, { passive: false });
        gameWrapper.addEventListener('touchmove', handleTouchMove, { passive: false });
        gameWrapper.addEventListener('touchend', handleTouchEnd, { passive: false });
        gameWrapper.addEventListener('touchcancel', handleTouchEnd, { passive: false });

        document.addEventListener('visibilitychange', () => {
            if (document.hidden && gameState === 'playing' && !isPaused) {
                togglePause();
            }
        });
    }

    function checkSelections() {
        startButton.disabled = !selectedWeapon;
    }
    
    function spawnExplosiveBarrel() {
        const size = 30;
        const x = Math.random() * (CANVAS_WIDTH - size) + size / 2;
        const y = Math.random() * (CANVAS_HEIGHT - size) + size / 2;
        const distToPlayer = Math.sqrt((x - player.x)**2 + (y-player.y)**2);
        if(distToPlayer < 150) { // Don't spawn too close
            spawnExplosiveBarrel();
            return;
        }
        explosiveBarrels.push({ x, y, size, hp: 10, color: '#cc3300' });
    }

    function startGame() {
        player = createInitialPlayer(selectedDifficulty, selectedWeapon);
        
        enemies = []; projectiles = []; enemyProjectiles = []; xpGems = []; healthPacks = []; nukes = [];
        explosions = []; orbitalShields = []; speedBoosts = []; fireRateBoosts = []; freezeBombs = [];
        invincibilityShields = []; blackHoleItems = []; drones = []; explosiveBarrels = []; blackHoles = [];
        holographicDecoys = []; decoys = []; damageTexts = [];
        availableUpgrades = [...UPGRADES];

        if (player.shields > 0) {
            for(let i=0; i<player.shields; i++){
                 orbitalShields.push({ angle: (i * Math.PI * 2) / player.shields, radius: 50, speed: 3, size: 15, color: '#FF00FF', damage: 25, lastHitTime: 0 });
            }
        }
        
        timer = 0; gameTime = 0; lastSpawnTime = 0;
        spawnInterval = 4000 * DIFFICULTY_SETTINGS[selectedDifficulty].spawnRateMult;
        bossSpawned = false; enemiesFrozen = false; enemiesFrozenTimer = 0;
        comboCount = 0; lastKillTime = 0;
        lastTime = performance.now();
        gameState = 'playing'; isPaused = false;

        startScreen.classList.add('hidden');
        gameOverScreen.classList.add('hidden');
        levelUpScreen.classList.add('hidden');
        pauseScreen.classList.add('hidden');
        pauseButton.classList.remove('hidden');
        
        // for (let i = 0; i < 3; i++) spawnExplosiveBarrel();

        updateUI();
        if (animationFrameId) cancelAnimationFrame(animationFrameId);
        gameLoop(performance.now());
    }
    
    function updateDrones(deltaTime) {
        const now = performance.now();
        const dt = deltaTime / 1000;
        
        while(drones.length < player.drones) {
            drones.push({ x: player.x, y: player.y, angle: Math.random() * Math.PI * 2, radius: 70, size: 10, fireRate: 1000, lastShotTime: 0 });
        }

        drones.forEach(drone => {
            drone.angle += 2 * dt;
            drone.x = player.x + Math.cos(drone.angle) * drone.radius;
            drone.y = player.y + Math.sin(drone.angle) * drone.radius;

            if (now - drone.lastShotTime > drone.fireRate) {
                const nearestEnemy = findNearestEnemy(drone);
                if (nearestEnemy) {
                    drone.lastShotTime = now;
                    const dx = nearestEnemy.x - drone.x;
                    const dy = nearestEnemy.y - drone.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    projectiles.push({ x: drone.x, y: drone.y, dx: (dx/dist) * 360, dy: (dy/dist) * 360, type: 'drone-bullet', damage: 8, lifespan: 1000, color: '#f0f0f0' });
                }
            }
        });
    }

    function updateDecoys(deltaTime) {
        decoys.forEach((decoy, index) => {
            decoy.lifespan -= deltaTime;
            if (decoy.lifespan <= 0) {
                decoys.splice(index, 1);
            }
        });
    }

    function updateBlackHoles(deltaTime) {
        const dt = deltaTime / 1000;
        const now = performance.now();
        blackHoles.forEach((bh, index) => {
            bh.age += deltaTime;
            bh.rotation += 5 * dt;
            if (bh.age >= bh.duration) {
                explosions.push({ x: bh.x, y: bh.y, radius: bh.pullRadius * 1.2, duration: 400, alpha: 1, damage: 200 });
                sounds.explosion();
                blackHoles.splice(index, 1);
                return;
            }

            const doDamage = bh.damage && now - (bh.lastDamageTime || 0) > 500;
            if (doDamage) bh.lastDamageTime = now;

            enemies.forEach(e => {
                if (e.isBoss) return;
                const dx = bh.x - e.x;
                const dy = bh.y - e.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < bh.pullRadius) {
                    if (dist > 10) {
                        const pullForce = (1 - (dist / bh.pullRadius)) * bh.strength;
                        e.x += (dx / dist) * pullForce * dt;
                        e.y += (dy / dist) * pullForce * dt;
                    }
                    if (doDamage) {
                        e.hp -= bh.damage;
                        createDamageText(e.x, e.y, bh.damage);
                    }
                }
            });
        });
    }

    function update(deltaTime) {
        if (isPaused || gameState !== 'playing') return;
        const now = performance.now();
        gameTime += deltaTime;
        timer = Math.floor(gameTime / 1000);
        
        if(now - lastKillTime > COMBO_TIMEOUT && comboCount > 0) {
            comboCount = 0;
        }

        // Update Timers
        if (player.speedBoostTimer > 0) { player.speedBoostTimer -= deltaTime; if (player.speedBoostTimer <= 0) player.speed = player.baseSpeed; }
        if (player.fireRateBoostTimer > 0) { player.fireRateBoostTimer -= deltaTime; if (player.fireRateBoostTimer <= 0) player.fireRate = player.baseFireRate; }
        if (player.invincibilityTimer > 0) { player.invincibilityTimer -= deltaTime; }
        if (enemiesFrozenTimer > 0) { enemiesFrozenTimer -= deltaTime; if (enemiesFrozenTimer <= 0) enemiesFrozen = false; }
        
        const dt = deltaTime / 1000;

        // Player Movement
        let moveX = 0, moveY = 0;
        if (keysPressed['KeyW'] || keysPressed['ArrowUp']) moveY -= 1;
        if (keysPressed['KeyS'] || keysPressed['ArrowDown']) moveY += 1;
        if (keysPressed['KeyA'] || keysPressed['ArrowLeft']) moveX -= 1;
        if (keysPressed['KeyD'] || keysPressed['ArrowRight']) moveX += 1;

        if (movementJoystickState.active) {
            moveX = movementJoystickState.dx;
            moveY = movementJoystickState.dy;
        }
        
        let currentSpeed = player.speed;
        if (player.isDashing) currentSpeed = player.dashSpeed;
        else if (player.speedBoostTimer > 0) currentSpeed = player.baseSpeed * 1.5;
        
        if (moveX !== 0 || moveY !== 0) {
            const mag = Math.sqrt(moveX * moveX + moveY * moveY);
            player.x += (moveX / mag) * currentSpeed * dt;
            player.y += (moveY / mag) * currentSpeed * dt;
        }

        player.x = Math.max(PLAYER_SIZE / 2, Math.min(CANVAS_WIDTH - PLAYER_SIZE / 2, player.x));
        player.y = Math.max(PLAYER_SIZE / 2, Math.min(CANVAS_HEIGHT - PLAYER_SIZE / 2, player.y));
        
        updateEnemySpawning(gameTime);

        // Player Shooting
        const canShoot = now - player.lastShotTime > player.fireRate;
        let isShooting = false;
        let aimDx = 0, aimDy = 0;
        let hasTarget = false;

        // Touch controls
        if (attackJoystickState.active) {
            isShooting = true;
            // If joystick is moved, use its direction for manual aim
            if (Math.abs(attackJoystickState.dx) > 0.1 || Math.abs(attackJoystickState.dy) > 0.1) {
                aimDx = attackJoystickState.dx;
                aimDy = attackJoystickState.dy;
                hasTarget = true;
            } else { // If joystick is just held, auto-aim
                const nearestEnemy = findNearestEnemy(player);
                if (nearestEnemy) {
                    const dx = nearestEnemy.x - player.x;
                    const dy = nearestEnemy.y - player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                    aimDx = dx / dist;
                    aimDy = dy / dist;
                    hasTarget = true;
                } else {
                    isShooting = false;
                }
            }
        } 
        // Desktop controls (mouse aim)
        else if (activeTouchCount === 0) {
            isShooting = true;
            const dx = mousePos.x - player.x;
            const dy = mousePos.y - player.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist > PLAYER_SIZE / 2) { // Don't shoot if mouse is on player
                aimDx = dx / dist;
                aimDy = dy / dist;
                hasTarget = true;
            } else {
                isShooting = false;
            }
        }

        if (isShooting && canShoot && hasTarget) {
            player.lastShotTime = now;
            if (player.weaponType === 'spirit-caller') sounds.summon(); else sounds.shoot();
            
            const dist = Math.sqrt(aimDx * aimDx + aimDy * aimDy) || 1;
            const finalAimDx = aimDx / dist;
            const finalAimDy = aimDy / dist;

            for (let i = 0; i < player.projectiles; i++) {
                let angleOffset = 0;
                if (player.projectiles > 1 && player.weaponType !== 'spirit-caller') {
                    angleOffset = (i - (player.projectiles - 1) / 2) * 0.15;
                }
                const angle = Math.atan2(finalAimDy, finalAimDx) + angleOffset;
                createProjectile(player.x, player.y, Math.cos(angle), Math.sin(angle), player.projectileType);
            }
        }
        
        if (!enemiesFrozen) {
            updateEnemies(dt, deltaTime);
        }
        updateProjectiles(deltaTime);
        updateXPGems(dt);
        updateExplosions(deltaTime);
        updateOrbitalShields(dt);
        updateDrones(deltaTime);
        updateDecoys(deltaTime);
        updateBlackHoles(deltaTime);
        updateDamageText(deltaTime);

        handleCollisions();

        for(let i = enemies.length - 1; i >= 0; i--) {
            if (enemies[i].hp <= 0) {
                onEnemyKilled(enemies[i]);
                enemies.splice(i, 1);
            }
        }

        if (player.hp <= 0) {
            if (timer > highScore) {
                highScore = timer;
                localStorage.setItem('neonSurvivorHighScore', timer);
            }
            gameState = 'gameOver';
            showGameOverScreen();
        }

        if (player.xp >= player.xpToNextLevel) {
            handleLevelUp();
        }
        
        updateUI();
    }
    
    function draw() {
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        ctx.shadowBlur = 10;

        explosiveBarrels.forEach(barrel => {
            ctx.fillStyle = barrel.color; ctx.shadowColor = barrel.color;
            ctx.fillRect(barrel.x - barrel.size / 2, barrel.y - barrel.size / 2, barrel.size, barrel.size);
            ctx.strokeStyle = '#ff6633';
            ctx.strokeRect(barrel.x - barrel.size / 2, barrel.y - barrel.size / 2, barrel.size, barrel.size);
        });

        blackHoles.forEach(bh => {
            const pullProgress = bh.age / bh.duration;
            ctx.save(); ctx.translate(bh.x, bh.y);
            ctx.beginPath(); ctx.arc(0, 0, 20 + pullProgress * 20, 0, Math.PI * 2);
            ctx.fillStyle = 'black'; ctx.fill();
            ctx.shadowColor = '#c084fc'; ctx.lineWidth = 3;
            for(let i=0; i < 3; i++) {
                ctx.beginPath();
                const startAngle = bh.rotation + (i * Math.PI * 2 / 3);
                const endAngle = startAngle + Math.PI * 0.8;
                ctx.arc(0, 0, 40 + i * 15 + pullProgress * 50, startAngle, endAngle);
                ctx.strokeStyle = `rgba(192, 132, 252, ${1 - pullProgress})`;
                ctx.stroke();
            }
            ctx.restore();
        });

        const itemFont = 'bold 20px Orbitron';
        const drawItem = (item, text, color) => {
            ctx.font = itemFont; ctx.fillStyle = color; ctx.shadowColor = color;
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(text, item.x, item.y);
        };
        healthPacks.forEach(pack => drawItem(pack, '‚úö', '#FF4444'));
        nukes.forEach(nuke => drawItem(nuke, '‚ò¢', '#FFFF00'));
        speedBoosts.forEach(item => drawItem(item, '‚û§', '#00FFFF'));
        fireRateBoosts.forEach(item => drawItem(item, '‚ö°', '#FFA500'));
        freezeBombs.forEach(item => drawItem(item, '‚ùÑ', '#87CEEB'));
        invincibilityShields.forEach(item => drawItem(item, '‚ú®', '#F0E68C'));
        blackHoleItems.forEach(item => drawItem(item, '‚óé', '#c084fc'));
        holographicDecoys.forEach(item => drawItem(item, 'üë§', '#00e5e5'));
        
        xpGems.forEach(gem => {
            ctx.beginPath(); ctx.arc(gem.x, gem.y, 5, 0, Math.PI * 2);
            ctx.fillStyle = '#39FF14'; ctx.shadowColor = '#39FF14'; ctx.fill();
        });

        if (player.invincibilityTimer > 0) {
            ctx.beginPath(); ctx.arc(player.x, player.y, PLAYER_SIZE, 0, Math.PI * 2);
            const alpha = 0.5 + Math.sin(Date.now()/100)*0.2;
            ctx.fillStyle = `rgba(255, 255, 0, ${alpha * 0.3})`; ctx.fill();
            ctx.strokeStyle = `rgba(255, 255, 0, ${alpha})`; ctx.lineWidth = 3; ctx.stroke();
        }

        ctx.fillStyle = player.isDashing ? '#FFFFFF' : '#00FFFF';
        ctx.shadowColor = player.isDashing ? '#FFFFFF' : '#00FFFF';
        ctx.fillRect(player.x - PLAYER_SIZE / 2, player.y - PLAYER_SIZE / 2, PLAYER_SIZE, PLAYER_SIZE);
        
        decoys.forEach(decoy => {
            ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 50) * 0.2;
            ctx.fillStyle = '#00e5e5'; ctx.shadowColor = '#00e5e5';
            ctx.fillRect(decoy.x - PLAYER_SIZE / 2, decoy.y - PLAYER_SIZE / 2, PLAYER_SIZE, PLAYER_SIZE);
            ctx.globalAlpha = 1.0;
        });

        orbitalShields.forEach(s => {
            ctx.beginPath(); ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
            ctx.fillStyle = s.color; ctx.shadowColor = s.color; ctx.fill();
        });
        
        drones.forEach(drone => {
            ctx.fillStyle = '#f0f0f0'; ctx.shadowColor = '#f0f0f0';
            ctx.beginPath(); ctx.arc(drone.x, drone.y, drone.size, 0, Math.PI * 2); ctx.fill();
        });
        
        projectiles.forEach(p => {
            ctx.shadowColor = p.color;
            if (p.type === 'lightning') {
                ctx.strokeStyle = '#9400D3'; ctx.lineWidth = 3; ctx.beginPath();
                let lastPos = { x: player.x, y: player.y };
                if (p.bounceHistory.length > 0) {
                    p.bounceHistory.forEach(enemy => {
                        ctx.moveTo(lastPos.x, lastPos.y); ctx.lineTo(enemy.x, enemy.y);
                        lastPos = { x: enemy.x, y: enemy.y };
                    });
                } else if (p.target) {
                     ctx.moveTo(player.x, player.y); ctx.lineTo(p.target.x, p.target.y);
                }
                ctx.stroke();
                return;
            }
            
            if (p.type === 'ricochet-blade') {
                ctx.save();
                ctx.translate(p.x, p.y);
                ctx.rotate(p.rotation);
                ctx.strokeStyle = p.color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                const bladeSize = p.size || 8;
                ctx.moveTo(0, -bladeSize); ctx.lineTo(bladeSize, 0);
                ctx.lineTo(0, bladeSize); ctx.lineTo(-bladeSize, 0);
                ctx.closePath(); ctx.stroke();
                ctx.restore();
            } else if (p.type === 'laser' || p.type === 'arrow') {
                ctx.strokeStyle = p.color; ctx.lineWidth = p.type === 'laser' ? 4 : 2;
                ctx.beginPath();
                const angle = Math.atan2(p.dy, p.dx); const length = p.type === 'laser' ? 15 : 10;
                ctx.moveTo(p.x - Math.cos(angle) * length, p.y - Math.sin(angle) * length);
                ctx.lineTo(p.x + Math.cos(angle) * length, p.y + Math.sin(angle) * length);
                ctx.stroke();
            } else {
                ctx.fillStyle = p.color; ctx.beginPath();
                ctx.arc(p.x, p.y, p.size || 5, 0, Math.PI * 2); ctx.fill();
            }
        });

        enemies.forEach(e => {
            ctx.fillStyle = enemiesFrozen ? '#ADD8E6' : e.color;
            ctx.shadowColor = enemiesFrozen ? '#ADD8E6' : e.color;
            ctx.beginPath();
            if (e.shape === 'triangle') {
                const side = e.size * 1.5;
                ctx.moveTo(e.x, e.y - side * 0.58);
                ctx.lineTo(e.x - side / 2, e.y + side * 0.29);
                ctx.lineTo(e.x + side / 2, e.y + side * 0.29);
                ctx.closePath();
            } else {
                ctx.rect(e.x - e.size / 2, e.y - e.size / 2, e.size, e.size);
            }
            ctx.fill();
            
            if(e.type === 'tank' || e.isBoss) {
                const hpPercentage = e.hp / (ENEMY_TYPES[e.type].hp * DIFFICULTY_SETTINGS[selectedDifficulty].enemyHpMult);
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#444'; ctx.fillRect(e.x - e.size/2, e.y - e.size/2 - 10, e.size, 5);
                ctx.fillStyle = '#f00'; ctx.fillRect(e.x - e.size/2, e.y - e.size/2 - 10, e.size * hpPercentage, 5);
                ctx.shadowBlur = 10;
            }
        });

        enemyProjectiles.forEach(p => {
            ctx.fillStyle = p.color; ctx.shadowColor = p.color;
            ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill();
        });

        explosions.forEach(exp => {
            ctx.beginPath(); ctx.arc(exp.x, exp.y, exp.radius * (1 - exp.alpha), 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255, 165, 0, ${exp.alpha})`; ctx.shadowColor = 'orange'; ctx.fill();
        });

        damageTexts.forEach(dt => {
            ctx.font = dt.crit ? 'bold 20px Orbitron' : 'bold 16px Orbitron';
            ctx.fillStyle = `rgba(255, ${dt.crit ? 100 : 255}, 102, ${dt.alpha})`;
            ctx.shadowColor = dt.crit ? 'orange' : 'yellow';
            ctx.textAlign = 'center'; ctx.fillText(dt.text, dt.x, dt.y);
        });

        // Cursor
        if (gameState === 'playing' && !isPaused && activeTouchCount === 0) {
            ctx.strokeStyle = '#FFF'; ctx.shadowColor = '#FFF'; ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(mousePos.x - 10, mousePos.y); ctx.lineTo(mousePos.x + 10, mousePos.y);
            ctx.moveTo(mousePos.x, mousePos.y - 10); ctx.lineTo(mousePos.x, mousePos.y + 10);
            ctx.stroke();
        }
        ctx.shadowBlur = 0;
    }
    
    function findNearestEnemy(from, excludeList = []) {
        let nearest = null; let nearestDist = Infinity;
        enemies.forEach(e => {
            if (excludeList.includes(e)) return;
            const dist = Math.sqrt((from.x - e.x) ** 2 + (from.y - e.y) ** 2);
            if (dist < nearestDist) {
                nearest = e; nearestDist = dist;
            }
        });
        return nearest;
    }

    function createDamageText(x, y, amount, isCrit = false) {
        damageTexts.push({ x, y, text: Math.round(amount), alpha: 1, duration: 500, startTime: performance.now(), crit: isCrit });
    }
    
    function updateDamageText(deltaTime) {
        const now = performance.now();
        damageTexts.forEach((dt, index) => {
            dt.y -= 30 * (deltaTime/1000);
            dt.alpha = 1 - (now - dt.startTime) / dt.duration;
            if (dt.alpha <= 0) {
                damageTexts.splice(index, 1);
            }
        });
    }

    function updateEnemySpawning(gameTime) {
        const now = performance.now();
        if (now - lastSpawnTime > spawnInterval) {
            lastSpawnTime = now;
            spawnInterval = Math.max(500, spawnInterval * 0.98);
            const waveSize = 1 + Math.floor(timer / 10);
            for (let i = 0; i < waveSize; i++) {
                const angle = Math.random() * Math.PI * 2;
                const x = player.x + Math.cos(angle) * (CANVAS_WIDTH / 2 + 50);
                const y = player.y + Math.sin(angle) * (CANVAS_HEIGHT / 2 + 50);

                let enemyType = 'grunt';
                if (timer > 20 && Math.random() < 0.3) enemyType = 'shooter';
                if (timer > 40 && Math.random() < 0.2) enemyType = 'tank';
                if (timer > 60 && Math.random() < 0.2) enemyType = 'bomber';
                if (timer > 90 && Math.random() < 0.1) enemyType = 'summoner';
                
                const baseStats = ENEMY_TYPES[enemyType];
                const difficultyMult = DIFFICULTY_SETTINGS[selectedDifficulty];

                enemies.push({
                    x, y, ...baseStats,
                    hp: baseStats.hp * difficultyMult.enemyHpMult * (1 + timer / 60),
                    speed: baseStats.speed * difficultyMult.enemySpeedMult,
                    lastActionTime: 0,
                    type: enemyType
                });
            }
        }
        if (timer > 180 && !bossSpawned) {
             bossSpawned = true;
             const baseStats = ENEMY_TYPES['boss'];
             const difficultyMult = DIFFICULTY_SETTINGS[selectedDifficulty];
             enemies.push({ x: CANVAS_WIDTH / 2, y: 50, ...baseStats, hp: baseStats.hp * difficultyMult.enemyHpMult, speed: baseStats.speed * difficultyMult.enemySpeedMult, isBoss: true, lastActionTime: 0, type: 'boss' });
        }
    }

    function createProjectile(x, y, dx, dy, type) {
        const weaponStats = WEAPON_SETTINGS[player.weaponType];
        const baseProjectile = { x, y, dx, dy, damage: player.projectileDamage, lifespan: 1000, color: '#FFD700', size: 5, owner: 'player'};
        let speed = 400;

        switch (type) {
            case 'bullet':
                player.machineGunShotCount = (player.machineGunShotCount + 1) % 8;
                const isEnhanced = player.machineGunShotCount === 0;
                projectiles.push({ ...baseProjectile, type, dx: dx * speed, dy: dy * speed, damage: isEnhanced ? baseProjectile.damage * 2 : baseProjectile.damage, size: isEnhanced ? 8 : 5, color: isEnhanced ? '#ff8c00' : '#FFD700', knockback: isEnhanced ? weaponStats.knockback : 0 });
                break;
            case 'missile':
                projectiles.push({ ...baseProjectile, type, dx: dx * 150, dy: dy * 150, lifespan: 3000, turnSpeed: 5, speed: 150 });
                break;
            case 'bomb':
                projectiles.push({ ...baseProjectile, type, dx: dx * 200, dy: dy * 200 - 150, gravity: 400, lifespan: 2000 });
                break;
            case 'pellet':
                for(let i=0; i<weaponStats.pellets; i++) {
                    const spreadAngle = (Math.random() - 0.5) * weaponStats.spread;
                    const angle = Math.atan2(dy, dx) + spreadAngle;
                    projectiles.push({ ...baseProjectile, type, dx: Math.cos(angle) * speed, dy: Math.sin(angle) * speed, lifespan: 400, knockback: weaponStats.knockback });
                }
                break;
            case 'laser':
                 projectiles.push({ ...baseProjectile, type, dx: dx * 800, dy: dy * 800, lifespan: 1200, color: '#ff00ff', pierced: [], slowAmount: weaponStats.slowAmount, slowDuration: weaponStats.slowDuration });
                 break;
            case 'arrow':
                projectiles.push({ ...baseProjectile, type, dx: dx * 800, dy: dy * 800, lifespan: 1200, color: '#add8e6', pierced: [], critChance: weaponStats.critChance, critMultiplier: weaponStats.critMultiplier });
                break;
            case 'spirit':
                projectiles.push({ ...baseProjectile, type, x: x + (Math.random() - 0.5) * 40, y: y + (Math.random() - 0.5) * 40, dx: 0, dy: 0, speed: 180, turnSpeed: 6, lifespan: 4000, color: '#9370DB', size: 8 });
                break;
            case 'lightning':
                const nearestEnemy = findNearestEnemy(player);
                if (nearestEnemy) {
                    projectiles.push({ ...baseProjectile, type, target: nearestEnemy, bounces: weaponStats.bounces, bounceHistory: [], lifespan: 250, processed: false });
                }
                break;
            case 'black-hole-orb':
                projectiles.push({ ...baseProjectile, type, dx: dx * 150, dy: dy * 150, lifespan: 2000, color: '#5a008a', size: 8 });
                break;
            case 'plasma-ball':
                projectiles.push({ ...baseProjectile, type, dx: dx * 200, dy: dy * 200, lifespan: 2000, color: '#6a0dad', size: 10 });
                break;
            case 'ricochet-blade':
                projectiles.push({ ...baseProjectile, type, dx: dx * 500, dy: dy * 500, lifespan: 1500, color: '#00ced1', size: 8, bounces: weaponStats.bounces, hitEnemies: [], rotation: 0 });
                break;
            case 'splicer-drone':
                projectiles.push({ ...baseProjectile, type, x: x + (Math.random() - 0.5) * 40, y: y + (Math.random() - 0.5) * 40, dx: 0, dy: 0, speed: 150, turnSpeed: 4, lifespan: 5000, color: '#32cd32', size: 10 });
                break;
        }
    }

    function updateEnemies(dt, deltaTime) {
        const now = performance.now();
        enemies.forEach((e, index) => {
            let currentSpeed = e.speed;
            
            if (e.slowTimer > 0) {
                e.slowTimer -= deltaTime;
                currentSpeed *= (1 - e.slowAmount);
                if (e.slowTimer <= 0) { delete e.slowTimer; delete e.slowAmount; }
            }
            
            if (e.burnTimer > 0) {
                e.burnTimer -= deltaTime;
                if (now - (e.lastBurnTick || 0) > 500) {
                    e.hp -= e.burnDamage; createDamageText(e.x, e.y, e.burnDamage);
                    e.lastBurnTick = now;
                }
                if (e.burnTimer <= 0) { delete e.burnTimer; delete e.burnDamage; delete e.lastBurnTick; }
            }

            let target = player;
            if (decoys.length > 0) {
                let nearestDecoy = null; let nearestDistSq = Infinity;
                decoys.forEach(d => {
                    const distSq = (d.x - e.x)**2 + (d.y - e.y)**2;
                    if (distSq < nearestDistSq) { nearestDecoy = d; nearestDistSq = distSq; }
                });
                if (nearestDecoy && nearestDistSq < 400**2) { target = nearestDecoy; }
            }

            const dx = target.x - e.x; const dy = target.y - e.y;
            const dist = Math.sqrt(dx * dx + dy * dy) || 1;
            e.x += (dx / dist) * currentSpeed * dt; e.y += (dy / dist) * currentSpeed * dt;

            if (now - e.lastActionTime > (e.fireRate || e.actionRate)) {
                 e.lastActionTime = now;
                 if (e.type === 'shooter' || e.isBoss) {
                     enemyProjectiles.push({ x: e.x, y: e.y, dx: (dx/dist) * e.projectileSpeed, dy: (dy/dist) * e.projectileSpeed, damage: e.damage, size: 8, color: '#f08080', lifespan: 3000 });
                 }
                 if (e.action === 'summon') {
                    for(let i=0; i<2; i++){
                       const spawnX = e.x + (Math.random() - 0.5) * 50; const spawnY = e.y + (Math.random() - 0.5) * 50;
                       const baseStats = ENEMY_TYPES['grunt'];
                       enemies.push({ ...baseStats, x: spawnX, y: spawnY, hp: baseStats.hp/2, type: 'grunt'});
                    }
                 }
            }
        });
    }

    function updateProjectiles(deltaTime) {
        const dt = deltaTime / 1000;
        projectiles.forEach((p, index) => {
            p.lifespan -= deltaTime;
            if (p.lifespan <= 0 || p.x < -10 || p.x > CANVAS_WIDTH + 10 || p.y < -10 || p.y > CANVAS_HEIGHT + 10) {
                if (p.type === 'missile') {
                    const weaponStats = WEAPON_SETTINGS['missile'];
                    explosions.push({ x: p.x, y: p.y, radius: weaponStats.explosionRadius, duration: 300, alpha: 1, damage: p.damage });
                    sounds.explosion();
                } else if (p.type === 'bomb') {
                    const weaponStats = WEAPON_SETTINGS['bomb'];
                    explosions.push({ x: p.x, y: p.y, radius: 40, duration: 300, alpha: 1, damage: p.damage }); // Default radius from original logic
                    sounds.explosion();

                    if (weaponStats.shrapnelCount > 0) {
                        for(let i=0; i < weaponStats.shrapnelCount; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            projectiles.push({ x: p.x, y: p.y, dx: Math.cos(angle) * 300, dy: Math.sin(angle) * 300, type: 'pellet', damage: 5, lifespan: 300, color: '#FFA500', size: 3, knockback: 0 });
                        }
                    }
                }
                if (p.type === 'black-hole-orb') {
                    blackHoles.push({ x: p.x, y: p.y, pullRadius: 150, strength: 200, duration: 3000, age: 0, rotation: 0, damage: 5, lastDamageTime: 0});
                    sounds.blackHole();
                }
                projectiles.splice(index, 1);
                return;
            }

            if (p.type === 'missile') {
                const nearest = findNearestEnemy(p);
                if (nearest) {
                    const dx = nearest.x - p.x; const dy = nearest.y - p.y;
                    const angle = Math.atan2(dy, dx); const pAngle = Math.atan2(p.dy, p.dx);
                    let angleDiff = angle - pAngle;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    const newAngle = pAngle + Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), p.turnSpeed * dt);
                    p.dx = Math.cos(newAngle) * p.speed; p.dy = Math.sin(newAngle) * p.speed;
                }
                p.speed = Math.min(p.speed + 100 * dt, 400);
            }
            if (p.type === 'spirit' || p.type === 'splicer-drone') {
                if (!p.target || p.target.hp <= 0) p.target = findNearestEnemy(p);
                if (p.target) {
                    const dx = p.target.x - p.x; const dy = p.target.y - p.y;
                    const angle = Math.atan2(dy, dx);
                    const pAngle = (p.dx === 0 && p.dy === 0) ? angle : Math.atan2(p.dy, p.dx);
                    let angleDiff = angle - pAngle;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    const newAngle = pAngle + Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), p.turnSpeed * dt);
                    p.dx = Math.cos(newAngle) * p.speed; p.dy = Math.sin(newAngle) * p.speed;
                }
                p.speed = Math.min(p.speed + 150 * dt, 300);
            }
            if (p.type === 'ricochet-blade') {
                p.rotation += 20 * dt;
            }
            if (p.type === 'bomb') p.dy += p.gravity * dt;
            if (p.type !== 'lightning') { p.x += p.dx * dt; p.y += p.dy * dt; }
        });
        
        enemyProjectiles.forEach((p, index) => {
             p.lifespan -= deltaTime;
             if (p.lifespan <= 0) { enemyProjectiles.splice(index, 1); return; }
             p.x += p.dx * dt; p.y += p.dy * dt;
        });
    }

    function updateXPGems(dt) {
        xpGems.forEach((gem, index) => {
            const dx = player.x - gem.x; const dy = player.y - gem.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < player.pickupRadius) {
                if (dist < 10) {
                    player.xp += gem.value; xpGems.splice(index, 1); sounds.xp();
                } else {
                    gem.x += (dx / dist) * 300 * dt; gem.y += (dy / dist) * 300 * dt;
                }
            }
        });
    }

    function updateExplosions(deltaTime) {
        explosions.forEach((exp, index) => {
            exp.alpha -= (1 / exp.duration) * deltaTime;
            if (exp.alpha <= 0) explosions.splice(index, 1);
        });
    }
    
    function updateOrbitalShields(dt) {
        while(orbitalShields.length < player.shields) {
            orbitalShields.push({ angle: Math.random() * Math.PI * 2, radius: 50, speed: 3, size: 15, color: '#FF00FF', damage: 25, lastHitTime: 0 });
        }
         while(orbitalShields.length > player.shields) orbitalShields.pop();
        
        const angleIncrement = Math.PI * 2 / Math.max(1, orbitalShields.length);
        orbitalShields.forEach((s, i) => {
            s.angle += s.speed * dt;
            s.x = player.x + Math.cos(s.angle + i * angleIncrement) * s.radius;
            s.y = player.y + Math.sin(s.angle + i * angleIncrement) * s.radius;
        });
    }
    
    function onEnemyKilled(enemy) {
        xpGems.push({ x: enemy.x, y: enemy.y, value: enemy.xp });
        lastKillTime = performance.now();
        comboCount++;

        if (Math.random() < 0.05) healthPacks.push({ x: enemy.x, y: enemy.y, size: 15 });
        if (Math.random() < 0.01) nukes.push({ x: enemy.x, y: enemy.y, size: 20 });
        if (Math.random() < 0.02) speedBoosts.push({ x: enemy.x, y: enemy.y, size: 15 });
        if (Math.random() < 0.02) fireRateBoosts.push({ x: enemy.x, y: enemy.y, size: 15 });
        if (Math.random() < 0.015) freezeBombs.push({ x: enemy.x, y: enemy.y, size: 15 });
        if (Math.random() < 0.01) invincibilityShields.push({ x: enemy.x, y: enemy.y, size: 15 });
        if (Math.random() < 0.005) blackHoleItems.push({ x: enemy.x, y: enemy.y, size: 15 });
        if (Math.random() < 0.02) holographicDecoys.push({ x: enemy.x, y: enemy.y, size: 15 });
        
        if (enemy.onDeath === 'explode') {
             explosions.push({ x: enemy.x, y: enemy.y, radius: 80, duration: 300, alpha: 1, damage: enemy.damage });
             sounds.explosion();
        }
    }

    function handleCollisions() {
        const now = performance.now();
        for (let pIndex = projectiles.length - 1; pIndex >= 0; pIndex--) {
            const p = projectiles[pIndex];
            if (!p) continue;
            
            if (p.type === 'lightning') {
                 if (!p.processed) {
                     p.processed = true; let currentTarget = p.target; let bounceList = [];
                     for (let i = 0; i < p.bounces; i++) {
                         if (!currentTarget || currentTarget.hp <= 0) break;
                         bounceList.push(currentTarget);
                         currentTarget.hp -= p.damage; createDamageText(currentTarget.x, currentTarget.y, p.damage);
                         const nextTarget = findNearestEnemy(currentTarget, bounceList);
                         if (nextTarget) currentTarget = nextTarget; else break;
                     }
                     p.bounceHistory = bounceList;
                 }
                 continue;
            }
            
            let projectileRemoved = false;
            for (let bIndex = explosiveBarrels.length - 1; bIndex >= 0; bIndex--) {
                const b = explosiveBarrels[bIndex];
                const dist = Math.sqrt((p.x - b.x)**2 + (p.y - b.y)**2);
                if (dist < b.size / 2 + (p.size || 5) / 2) {
                    b.hp -= p.damage; createDamageText(b.x, b.y, p.damage); sounds.hit();
                     if (b.hp <= 0) {
                        explosions.push({ x: b.x, y: b.y, radius: 100, duration: 400, alpha: 1, damage: 100 });
                        sounds.explosion(); explosiveBarrels.splice(bIndex, 1);
                    }
                    const isPenetrating = p.type === 'laser' || p.type === 'arrow' || p.type === 'ricochet-blade';
                    if (!isPenetrating) {
                        projectiles.splice(pIndex, 1); projectileRemoved = true; break;
                    }
                }
            }
            if(projectileRemoved) continue;

            for (let eIndex = enemies.length - 1; eIndex >= 0; eIndex--) {
                const e = enemies[eIndex];
                const dist = Math.sqrt((p.x - e.x) ** 2 + (p.y - e.y) ** 2);
                
                if (dist < e.size / 2 + (p.size || 5) / 2) {
                    const weaponStats = WEAPON_SETTINGS[player.weaponType];
                    
                    if (p.type === 'plasma-ball') {
                        explosions.push({ x: p.x, y: p.y, radius: weaponStats.explosionRadius, duration: 300, alpha: 1, damage: 0 }); // Visual only
                        sounds.explosion();
                        enemies.forEach(enemyInRadius => {
                            const explosionDist = Math.sqrt((p.x - enemyInRadius.x)**2 + (p.y - enemyInRadius.y)**2);
                            if(explosionDist < weaponStats.explosionRadius + enemyInRadius.size/2) {
                                enemyInRadius.hp -= p.damage;
                                createDamageText(enemyInRadius.x, enemyInRadius.y, p.damage);
                                enemyInRadius.burnTimer = weaponStats.burnDuration;
                                enemyInRadius.burnDamage = weaponStats.burnDamage;
                                enemyInRadius.lastBurnTick = now;
                            }
                        });
                        projectiles.splice(pIndex, 1);
                        projectileRemoved = true;
                        break;
                    }

                    if (p.type === 'splicer-drone') {
                        e.hp -= p.damage; createDamageText(e.x, e.y, p.damage);
                        for(let i=0; i < weaponStats.shrapnelCount; i++) {
                            const angle = (i / weaponStats.shrapnelCount) * Math.PI * 2;
                            projectiles.push({ x: p.x, y: p.y, dx: Math.cos(angle) * 300, dy: Math.sin(angle) * 300, type: 'pellet', damage: weaponStats.shrapnelDamage, lifespan: 300, color: '#FFA500', size: 3, knockback: 0 });
                        }
                        projectiles.splice(pIndex, 1);
                        projectileRemoved = true;
                        break;
                    }

                    if (p.type === 'ricochet-blade' && p.hitEnemies.includes(e)) continue;

                    let damage = p.damage; let isCrit = false;
                    if (p.critChance && Math.random() < p.critChance) { damage *= p.critMultiplier; isCrit = true; }
                    createDamageText(e.x, e.y, damage, isCrit);
                    e.hp -= damage; sounds.hit();
                    if (p.knockback) { const angle = Math.atan2(e.y - p.y, e.x - p.x); e.x += Math.cos(angle) * p.knockback * 0.1; e.y += Math.sin(angle) * p.knockback * 0.1; }
                    if (p.slowAmount) { e.slowTimer = p.slowDuration; e.slowAmount = p.slowAmount; }
                    
                    if (p.type === 'ricochet-blade') {
                        p.hitEnemies.push(e);
                        p.bounces--;
                        if (p.bounces < 0) {
                            projectiles.splice(pIndex, 1);
                        } else {
                            const nextTarget = findNearestEnemy(e, p.hitEnemies);
                            if (nextTarget) {
                                const dx = nextTarget.x - e.x;
                                const dy = nextTarget.y - e.y;
                                const d = Math.sqrt(dx*dx + dy*dy) || 1;
                                const speed = Math.sqrt(p.dx**2 + p.dy**2);
                                p.dx = (dx/d) * speed;
                                p.dy = (dy/d) * speed;
                                p.x = e.x + (dx/d) * (e.size/2 + p.size/2 + 1);
                                p.y = e.y + (dy/d) * (e.size/2 + p.size/2 + 1);
                            } else {
                                projectiles.splice(pIndex, 1);
                            }
                        }
                        projectileRemoved = true;
                        break;
                    }

                    const isPenetrating = p.type === 'laser' || p.type === 'arrow';
                    if (isPenetrating) {
                        if (!p.pierced.includes(e)) p.pierced.push(e); else continue;
                    } else {
                        if(player.explosiveProjectiles && p.type !== 'missile' && p.type !== 'bomb') {
                             explosions.push({ x: p.x, y: p.y, radius: 30, duration: 200, alpha: 1, damage: p.damage / 2 });
                        }
                        projectiles.splice(pIndex, 1); 
                        projectileRemoved = true;
                        break;
                    }
                }
            }
             if (projectileRemoved) break;
        }

        if (player.invincibilityTimer <= 0 && !player.isDashing) {
            enemies.forEach(e => {
                const dist = Math.sqrt((player.x - e.x) ** 2 + (player.y - e.y) ** 2);
                if (dist < PLAYER_SIZE / 2 + e.size / 2) {
                    player.hp -= e.damage; sounds.hit(); player.invincibilityTimer = 500;
                }
            });
            enemyProjectiles.forEach((p, index) => {
                const dist = Math.sqrt((player.x - p.x) ** 2 + (player.y - p.y) ** 2);
                 if (dist < PLAYER_SIZE / 2 + p.size / 2) {
                    player.hp -= p.damage; sounds.hit(); player.invincibilityTimer = 500;
                    enemyProjectiles.splice(index, 1);
                 }
            });
         }

        orbitalShields.forEach(s => {
             enemies.forEach((e, eIndex) => {
                if(now - s.lastHitTime < 500) return;
                const dist = Math.sqrt((s.x - e.x)**2 + (s.y - e.y)**2);
                if (dist < s.size/2 + e.size/2) {
                    s.lastHitTime = now; e.hp -= s.damage; createDamageText(e.x, e.y, s.damage);
                }
            });
        });

        explosions.forEach(exp => {
             if (exp.processed) return;
             enemies.forEach((e) => {
                 const dist = Math.sqrt((exp.x - e.x)**2 + (exp.y - e.y)**2);
                 if (dist < exp.radius + e.size/2) { e.hp -= exp.damage; createDamageText(e.x, e.y, exp.damage); }
             });
             explosiveBarrels.forEach((b) => {
                 const dist = Math.sqrt((exp.x - b.x)**2 + (exp.y - b.y)**2);
                 if (dist < exp.radius + b.size/2) b.hp -= exp.damage;
             });
             exp.processed = true;
        });

        const checkItemPickup = (items, onPickup) => {
            for (let i = items.length - 1; i >= 0; i--) {
                const item = items[i];
                const dist = Math.sqrt((player.x - item.x)**2 + (player.y - item.y)**2);
                if (dist < PLAYER_SIZE/2 + (item.size || 15)/2) {
                    onPickup(item); items.splice(i, 1);
                }
            }
        };

        checkItemPickup(healthPacks, () => { player.hp = Math.min(player.maxHp, player.hp + 20); sounds.heal(); });
        checkItemPickup(nukes, () => { enemies.forEach(e => { if(!e.isBoss) {e.hp = 0; createDamageText(e.x, e.y, 9999);} }); sounds.nuke(); });
        checkItemPickup(speedBoosts, () => { player.speedBoostTimer = 5000; sounds.powerup(); });
        checkItemPickup(fireRateBoosts, () => { player.fireRateBoostTimer = 5000; sounds.powerup(); });
        checkItemPickup(freezeBombs, () => { enemiesFrozen = true; enemiesFrozenTimer = 5000; sounds.freeze(); });
        checkItemPickup(invincibilityShields, () => { player.invincibilityTimer = 5000; sounds.shieldUp(); });
        checkItemPickup(blackHoleItems, (item) => {
             blackHoles.push({ x: item.x, y: item.y, pullRadius: 200, strength: 250, duration: 5000, age: 0, rotation: 0, damage: 10});
             sounds.blackHole();
        });
        checkItemPickup(holographicDecoys, () => { player.decoyCharges = (player.decoyCharges || 0) + 1; sounds.powerup(); });
    }

    function handleLevelUp() {
        player.xp -= player.xpToNextLevel; player.level++;
        player.xpToNextLevel = Math.floor(player.xpToNextLevel * 1.4);
        sounds.levelUp();
        
        isPaused = true;
        levelUpScreen.classList.remove('hidden');
        levelUpOptionsContainer.innerHTML = '';

        const upgradeChoices = [];
        const shuffledUpgrades = [...availableUpgrades].sort(() => 0.5 - Math.random());
        for (let i = 0; i < Math.min(3, shuffledUpgrades.length); i++) upgradeChoices.push(shuffledUpgrades[i]);
        
        upgradeChoices.forEach(upgrade => {
            const card = document.createElement('div');
            card.className = 'p-4 rounded-lg upgrade-card flex flex-col items-center justify-center text-center';
            card.innerHTML = `<h3 class="text-2xl font-bold mb-2 text-glow">${upgrade.title}</h3><p class="text-gray-300">${upgrade.description}</p>`;
            card.onclick = () => {
                upgrade.apply(player);
                if (upgrade.id === 'shield') {
                    orbitalShields = [];
                    for(let i=0; i<player.shields; i++){
                         orbitalShields.push({ angle: (i * Math.PI * 2) / player.shields, radius: 50, speed: 3, size: 15, color: '#FF00FF', damage: 25, lastHitTime: 0 });
                    }
                }
                levelUpScreen.classList.add('hidden');
                isPaused = false;
                lastTime = performance.now();
                gameLoop(lastTime);
            };
            levelUpOptionsContainer.appendChild(card);
        });
    }

    function showGameOverScreen() {
        if(animationFrameId) cancelAnimationFrame(animationFrameId);
        gameOverScreen.classList.remove('hidden');
        pauseButton.classList.add('hidden');
        gameOverTimeUI.textContent = `ÏÉùÏ°¥ ÏãúÍ∞Ñ: ${formatTime(timer)}`;
        const finalRank = getRank(timer);
        gameOverRankUI.innerHTML = `Îã¨ÏÑ± Îû≠ÌÅ¨: <span style="color:${finalRank.color}; text-shadow: 0 0 8px ${finalRank.color};">${finalRank.name}</span>`;
        const highscoreRank = getRank(highScore);
        gameOverHighscoreUI.innerHTML = `ÏµúÍ≥† Í∏∞Î°ù: ${formatTime(highScore)} (${highscoreRank.name})`;
    }

    function updateUI() {
        levelUI.textContent = `Î†àÎ≤®: ${player.level}`;
        timerUI.textContent = formatTime(timer);
        hpBar.style.width = `${Math.max(0, (player.hp / player.maxHp) * 100)}%`;
        xpBar.style.width = `${(player.xp / player.xpToNextLevel) * 100}%`;
        const rank = getRank(timer);
        currentRankUI.innerHTML = `<span style="color:${rank.color}; text-shadow: 0 0 5px ${rank.color};">${rank.name}</span>`;
        if (comboCount > 1) {
            comboUI.textContent = `${comboCount} COMBO!`;
        } else {
            comboUI.textContent = '';
        }
    }

    function gameLoop(timestamp) {
        if (gameState !== 'playing') return;
        const deltaTime = timestamp - lastTime;
        lastTime = timestamp;
        if (!isPaused) {
            update(deltaTime);
            draw();
        }
        animationFrameId = requestAnimationFrame(gameLoop);
    }
    
    init();
});
</script>
</body>
</html>
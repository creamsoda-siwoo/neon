<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>네온 서바이버</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      font-family: 'Orbitron', sans-serif;
      overflow: hidden;
      background-color: #0d0221;
      color: white;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      margin: 0;
      padding: 1rem;
    }
    .game-container {
      background: #0a0a1f;
      border: 2px solid #00ffff;
      box-shadow: 0 0 20px #00ffff, inset 0 0 20px #00ffff;
    }
    #game-canvas {
      background-color: #0d0221;
      cursor: none;
    }
    .text-glow {
      color: #fff;
      text-shadow: 0 0 7px #fff, 0 0 10px #fff, 0 0 21px #ff00ff, 0 0 42px #ff00ff;
    }
    .button-retro {
      background-color: transparent;
      border: 2px solid #fff;
      color: #fff;
      padding: 0.75rem 1.5rem;
      text-transform: uppercase;
      letter-spacing: 2px;
      transition: all 0.2s ease-in-out;
      text-shadow: 0 0 8px #ff00ff;
      cursor: pointer;
    }
    .button-retro:hover:not(:disabled) {
      background-color: #fff;
      color: #0d0221;
      box-shadow: 0 0 20px #fff, 0 0 30px #ff00ff;
    }
    .button-retro:disabled {
        cursor: not-allowed;
        opacity: 0.5;
    }
    .selection-button {
        border-width: 2px;
        border-color: #fff;
        background-color: transparent;
        padding: 0.5rem 1rem;
        height: 100%;
    }
    .selection-button.selected {
        background-color: #00ffff;
        color: #0d0221;
        box-shadow: 0 0 20px #00ffff;
    }
    .upgrade-card {
      border: 2px solid #00ffff;
      background: rgba(13, 2, 33, 0.8);
      transition: all 0.2s ease-in-out;
      cursor: pointer;
    }
    .upgrade-card:hover {
      background: rgba(0, 255, 255, 0.2);
      box-shadow: 0 0 15px #00ffff;
      transform: translateY(-5px);
    }
    .overlay {
        position: absolute;
        inset: 0;
        background-color: rgba(0,0,0,0.85);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
        z-index: 10;
        padding: 1rem;
    }
    .hidden {
        display: none;
    }
  </style>
</head>
<body>

  <main class="flex flex-col items-center">
    <div class="flex justify-between w-full mb-2 px-2 text-glow">
        <div class="flex gap-4 items-center">
            <div id="level-ui" class="text-xl">레벨: 1</div>
            <div id="current-rank-ui" class="text-lg"></div>
        </div>
        <div class="flex flex-col items-center">
            <div id="timer-ui" class="text-2xl font-bold">00:00</div>
            <div id="combo-ui" class="text-xl font-bold text-yellow-400 h-6" style="text-shadow: 0 0 8px #facc15;"></div>
        </div>
        <div id="highscore-ui" class="text-xl text-right">최고기록: 00:00</div>
    </div>
    
    <div class="w-full h-8 mb-2 flex flex-col justify-around">
        <div class="w-full bg-gray-700 h-3 rounded-full overflow-hidden border border-red-500">
            <div id="hp-bar" class="bg-red-500 h-full" style="width: 100%"></div>
        </div>
        <div class="w-full bg-gray-700 h-3 rounded-full overflow-hidden border border-cyan-400">
            <div id="xp-bar" class="bg-cyan-400 h-full" style="width: 0%"></div>
        </div>
    </div>

    <div id="game-wrapper" class="relative rounded-lg overflow-hidden game-container" style="width: 800px; height: 600px;">
      <canvas id="game-canvas" width="800" height="600"></canvas>
      <button id="pause-button" class="absolute top-2 right-2 text-2xl w-12 h-12 button-retro hidden items-center justify-center" style="padding: 0;">||</button>
      
      <div id="start-screen" class="overlay">
          <h1 class="text-5xl md:text-6xl font-bold mb-4 text-glow">네온 서바이버</h1>
          <div id="start-screen-highscore" class="text-xl mb-8 text-glow"></div>
          
          <div class="mb-6">
              <h2 class="text-xl mb-2 text-glow">난이도 선택</h2>
              <div id="difficulty-selection" class="flex justify-center gap-4">
                  <button class="button-retro selection-button" data-difficulty="쉬움">쉬움</button>
                  <button class="button-retro selection-button" data-difficulty="보통">보통</button>
                  <button class="button-retro selection-button" data-difficulty="어려움">어려움</button>
              </div>
          </div>
          
          <div class="w-full max-w-2xl">
              <h2 class="text-xl mb-2 text-glow">무기 선택</h2>
              <div id="weapon-selection" class="grid grid-cols-2 md:grid-cols-4 gap-2 mb-2">
                  <button class="button-retro selection-button" data-weapon="machine-gun">기관총</button>
                  <button class="button-retro selection-button" data-weapon="missile">유도 미사일</button>
                  <button class="button-retro selection-button" data-weapon="bomb">폭탄</button>
                  <button class="button-retro selection-button" data-weapon="shotgun">샷건</button>
                  <button class="button-retro selection-button" data-weapon="laser">레이저</button>
                  <button class="button-retro selection-button" data-weapon="bow">활</button>
                  <button class="button-retro selection-button" data-weapon="flamethrower">화염방사기</button>
                  <button class="button-retro selection-button" data-weapon="chain-lightning">연쇄 번개</button>
              </div>
              <div id="weapon-stats" class="text-sm h-20 p-2 border-2 border-cyan-400 rounded-lg text-left bg-black bg-opacity-25">
                  <p>무기 위로 마우스를 올려 능력치를 확인하세요.</p>
              </div>
          </div>

          <button id="start-button" class="button-retro mt-8" disabled>게임 시작</button>
      </div>

      <div id="pause-screen" class="overlay hidden">
          <h2 class="text-6xl font-bold mb-8 text-glow">일시정지</h2>
          <div class="flex flex-col gap-4 w-64">
              <button id="resume-button" class="button-retro">계속하기</button>
              <button id="restart-pause-button" class="button-retro">다시 시작</button>
              <button id="quit-button" class="button-retro">그만하기</button>
          </div>
      </div>

      <div id="levelup-screen" class="overlay hidden">
          <h2 class="text-5xl font-bold mb-8 text-glow">레벨 업!</h2>
          <div id="levelup-options" class="grid grid-cols-1 md:grid-cols-3 gap-6">
              <!-- Upgrade cards will be injected here -->
          </div>
      </div>

      <div id="gameover-screen" class="overlay hidden">
          <h2 class="text-6xl font-bold mb-4 text-glow">게임 오버</h2>
          <p id="gameover-time" class="text-3xl mb-2">생존 시간: 00:00</p>
          <p id="gameover-rank" class="text-2xl mb-6"></p>
          <p id="gameover-highscore" class="text-xl mb-8">최고 기록: 00:00</p>
          <button id="restart-button" class="button-retro">새로 시작</button>
      </div>
    </div>
  </main>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- DOM Elements ---
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    const startScreen = document.getElementById('start-screen');
    const pauseScreen = document.getElementById('pause-screen');
    const levelUpScreen = document.getElementById('levelup-screen');
    const gameOverScreen = document.getElementById('gameover-screen');
    const startButton = document.getElementById('start-button');
    const restartButton = document.getElementById('restart-button');
    const pauseButton = document.getElementById('pause-button');
    const levelUpOptionsContainer = document.getElementById('levelup-options');
    const difficultySelection = document.getElementById('difficulty-selection');
    const weaponSelection = document.getElementById('weapon-selection');
    const weaponStatsUI = document.getElementById('weapon-stats');
    const resumeButton = document.getElementById('resume-button');
    const restartPauseButton = document.getElementById('restart-pause-button');
    const quitButton = document.getElementById('quit-button');

    // UI Elements
    const levelUI = document.getElementById('level-ui');
    const timerUI = document.getElementById('timer-ui');
    const comboUI = document.getElementById('combo-ui');
    const highscoreUI = document.getElementById('highscore-ui');
    const hpBar = document.getElementById('hp-bar');
    const xpBar = document.getElementById('xp-bar');
    const gameOverTimeUI = document.getElementById('gameover-time');
    const gameOverRankUI = document.getElementById('gameover-rank');
    const gameOverHighscoreUI = document.getElementById('gameover-highscore');
    const startScreenHighscoreUI = document.getElementById('start-screen-highscore');
    const currentRankUI = document.getElementById('current-rank-ui');

    // --- Game Constants ---
    const CANVAS_WIDTH = 800;
    const CANVAS_HEIGHT = 600;
    const PLAYER_SIZE = 20;
    const COMBO_TIMEOUT = 2500;

    // --- Ranking System ---
    const RANKS = [
        { name: '네온 초심자', threshold: 0, color: '#9ca3af' },
        { name: '그리드 러너', threshold: 60, color: '#6ee7b7' },
        { name: '서킷 브레이커', threshold: 120, color: '#60a5fa' },
        { name: '데이터 스트리머', threshold: 180, color: '#c084fc' },
        { name: '사이버 검투사', threshold: 240, color: '#f87171' },
        { name: '신스웨이브 파수꾼', threshold: 300, color: '#facc15' },
        { name: '디지털 오버로드', threshold: 420, color: '#f472b6' }
    ];

    function getRank(seconds) {
        let currentRank = RANKS[0];
        for (const rank of RANKS) {
            if (seconds >= rank.threshold) {
                currentRank = rank;
            } else {
                break;
            }
        }
        return currentRank;
    }

    // --- Game Configs ---
    const DIFFICULTY_SETTINGS = {
        '쉬움': { hp: 120, enemyHpMult: 0.7, enemySpeedMult: 0.8, spawnRateMult: 1.2 },
        '보통': { hp: 100, enemyHpMult: 1.0, enemySpeedMult: 1.0, spawnRateMult: 1.0 },
        '어려움': { hp: 80, enemyHpMult: 1.5, enemySpeedMult: 1.2, spawnRateMult: 0.8 },
    };
    const WEAPON_SETTINGS = {
        'machine-gun': { fireRate: 400, damage: 10, projectileType: 'bullet', name: '기관총', description: '가장 균형잡힌 기본 무기입니다.' },
        'missile': { fireRate: 1000, damage: 35, projectileType: 'missile', name: '유도 미사일', description: '가장 가까운 적을 추적합니다.' },
        'bomb': { fireRate: 800, damage: 25, projectileType: 'bomb', name: '폭탄', description: '포물선으로 날아가 폭발합니다.' },
        'shotgun': { fireRate: 700, damage: 8, projectileType: 'pellet', name: '샷건', pellets: 5, spread: 0.5, description: '근거리의 적들에게 강력합니다.' },
        'laser': { fireRate: 1200, damage: 50, projectileType: 'laser', name: '레이저', description: '모든 적을 관통합니다.' },
        'bow': { fireRate: 600, damage: 20, projectileType: 'arrow', name: '활', description: '포물선을 그리며 날아가는 화살을 발사합니다.' },
        'flamethrower': { fireRate: 50, damage: 2, projectileType: 'flame', name: '화염방사기', description: '짧은 거리의 적들을 불태웁니다. 관통 효과.' },
        'chain-lightning': { fireRate: 800, damage: 25, projectileType: 'lightning', name: '연쇄 번개', description: '적들 사이를 튕기는 번개를 발사합니다.' },
    };
   
    // --- Audio ---
    let audioContext;
    try { audioContext = new (window.AudioContext || window.webkitAudioContext)(); }
    catch (e) { console.error("Web Audio API is not supported in this browser"); }

    function playSound(type, frequency, duration, volume = 0.3) {
        if (!audioContext) return;
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        oscillator.type = type;
        oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
        gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.00001, audioContext.currentTime + duration);
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + duration);
    }
    const sounds = {
        hit: () => playSound('square', 150, 0.1, 0.2),
        shoot: () => playSound('triangle', 440, 0.05, 0.1),
        xp: () => playSound('sine', 600, 0.1, 0.2),
        levelUp: () => playSound('sine', 880, 0.4),
        heal: () => playSound('sine', 700, 0.3),
        dash: () => playSound('sine', 300, 0.2, 0.4),
        explosion: () => playSound('sine', 50, 0.3, 0.5),
        nuke: () => playSound('sine', 100, 1.0, 0.8),
        powerup: () => playSound('sine', 900, 0.2),
        freeze: () => playSound('sawtooth', 200, 0.5, 0.4),
        shieldUp: () => playSound('sine', 1000, 0.2, 0.5),
        shieldDown: () => playSound('square', 100, 0.2, 0.5),
        blackHole: () => playSound('noise', 100, 2, 0.4),
    };
    
    // --- Game State ---
    let gameState = 'start';
    let isPaused = false;
    let selectedDifficulty, selectedWeapon;
    let player, enemies, projectiles, enemyProjectiles, xpGems, healthPacks, nukes, explosions;
    let orbitalShields, speedBoosts, fireRateBoosts, freezeBombs, invincibilityShields, blackHoleItems;
    let drones, explosiveBarrels, blackHoles;
    let timer, gameTime, lastTime, animationFrameId;
    let lastSpawnTime, spawnInterval;
    let bossSpawned, enemiesFrozen, enemiesFrozenTimer;
    let mousePos = { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2 };
    let keysPressed = {};
    let isTouching = false;
    let highScore = Number(localStorage.getItem('neonSurvivorHighScore') || 0);
    let comboCount, lastKillTime;

    // --- Upgrades ---
    const UPGRADES = [
        { id: 'firerate', title: "연사력 강화", description: "공격 속도 20% 증가", apply: p => { p.baseFireRate *= 0.8; p.fireRate = p.baseFireRate;} },
        { id: 'damage', title: "강화 탄환", description: "공격력 25% 증가", apply: p => p.projectileDamage *= 1.25 },
        { id: 'multishot', title: "멀티샷", description: "발사체 수 +1", apply: p => p.projectiles++ },
        { id: 'hp', title: "나노 수리봇", description: "최대 체력 20 증가 및 모두 회복", apply: p => { p.maxHp += 20; p.hp = p.maxHp; } },
        { id: 'speed', title: "고속 추진기", description: "이동 속도 10% 증가", apply: p => { p.baseSpeed *= 1.1; p.speed = p.baseSpeed; } },
        { id: 'shield', title: '궤도 방패', description: '주위를 도는 방패 추가', apply: p => p.shields++ },
        { id: 'explosive', title: '폭발탄', description: '탄환이 명중 시 폭발합니다', apply: p => p.explosiveProjectiles = true },
        { id: 'magnet', title: '경험치 자석', description: '경험치 획득 범위 50% 증가', apply: p => p.pickupRadius *= 1.5 },
        { id: 'drone', title: '컴패니언 드론', description: '플레이어를 돕는 공격 드론을 추가합니다.', apply: p => p.drones = (p.drones || 0) + 1 },
    ];
    let availableUpgrades = [...UPGRADES];
    
    function createInitialPlayer(difficulty, weapon) {
        const difficultySettings = DIFFICULTY_SETTINGS[difficulty];
        const weaponSettings = WEAPON_SETTINGS[weapon];
        
        return {
            x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2,
            hp: difficultySettings.hp, maxHp: difficultySettings.hp,
            xp: 0, level: 1, xpToNextLevel: 10,
            weaponType: weapon,
            fireRate: weaponSettings.fireRate, baseFireRate: weaponSettings.fireRate,
            projectiles: 1, projectileDamage: weaponSettings.damage, projectileType: weaponSettings.projectileType,
            lastShotTime: 0, speed: 3, baseSpeed: 3, pickupRadius: 100,
            dashCooldown: 2000, lastDashTime: 0, isDashing: false, dashDuration: 150, dashSpeed: 10,
            shields: 1, // Start with 1 shield by default
            explosiveProjectiles: false,
            speedBoostTimer: 0, fireRateBoostTimer: 0, invincibilityTimer: 0,
            drones: 0,
        };
    }

    function formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
    }

    function togglePause() {
        if (gameState !== 'playing' || levelUpScreen.classList.contains('hidden') === false) return;
        isPaused = !isPaused;
        pauseScreen.classList.toggle('hidden', !isPaused);
        if (!isPaused) {
            lastTime = performance.now();
            requestAnimationFrame(gameLoop);
        }
    }

    function init() {
        const rank = getRank(highScore);
        highscoreUI.innerHTML = `최고기록: ${formatTime(highScore)} <span style="color: ${rank.color}; text-shadow: 0 0 5px ${rank.color};">(${rank.name})</span>`;
        startScreenHighscoreUI.innerHTML = `최고 기록: ${formatTime(highScore)} &bull; 랭크: <span style="color: ${rank.color}; text-shadow: 0 0 8px ${rank.color};">${rank.name}</span>`;
        
        difficultySelection.addEventListener('click', e => {
            if (e.target.tagName === 'BUTTON') {
                selectedDifficulty = e.target.dataset.difficulty;
                [...difficultySelection.children].forEach(btn => btn.classList.remove('selected'));
                e.target.classList.add('selected');
                checkSelections();
            }
        });
        weaponSelection.addEventListener('mouseover', e => {
            if (e.target.tagName === 'BUTTON' && e.target.dataset.weapon) {
                const weaponId = e.target.dataset.weapon;
                const stats = WEAPON_SETTINGS[weaponId];
                const rpm = Math.round(60000 / stats.fireRate); 
                weaponStatsUI.innerHTML = `
                    <h3 class="text-lg text-cyan-300 font-bold">${stats.name}</h3>
                    <p>데미지: ${stats.damage}${stats.pellets ? ' x ' + stats.pellets : ''} / 연사속도: ${rpm} RPM</p>
                    <p>특징: ${stats.description}</p>
                `;
            }
        });
        weaponSelection.addEventListener('click', e => {
            if (e.target.tagName === 'BUTTON') {
                selectedWeapon = e.target.dataset.weapon;
                [...weaponSelection.children].forEach(btn => btn.classList.remove('selected'));
                e.target.classList.add('selected');
                checkSelections();
            }
        });

        startButton.onclick = startGame;
        restartButton.onclick = () => {
            gameOverScreen.classList.add('hidden');
            pauseButton.classList.add('hidden');
            startScreen.classList.remove('hidden');
        };
        pauseButton.onclick = togglePause;
        
        resumeButton.onclick = togglePause;
        restartPauseButton.onclick = () => {
            pauseScreen.classList.add('hidden');
            isPaused = false;
            startGame();
        };
        quitButton.onclick = () => {
            pauseScreen.classList.add('hidden');
            isPaused = false;
            gameState = 'start';
            if(animationFrameId) cancelAnimationFrame(animationFrameId);
            startScreen.classList.remove('hidden');
            pauseButton.classList.add('hidden');
        };
        
        // Input Listeners
        window.addEventListener('keydown', e => {
            keysPressed[e.code] = true;
            if (e.key === "Escape") togglePause();
            if (e.code === 'Space' && gameState === 'playing' && !isPaused) {
                const now = performance.now();
                if (now - player.lastDashTime > player.dashCooldown) {
                    player.isDashing = true;
                    player.lastDashTime = now;
                    sounds.dash();
                    setTimeout(() => player.isDashing = false, player.dashDuration);
                }
            }
        });
        window.addEventListener('keyup', e => { keysPressed[e.code] = false; });
        
        const getMousePos = (e) => {
             const rect = canvas.getBoundingClientRect();
             return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        }
        canvas.addEventListener('mousemove', e => { if (!isTouching) mousePos = getMousePos(e); });
        canvas.addEventListener('touchstart', e => { isTouching = true; mousePos = getMousePos(e.touches[0]); e.preventDefault(); }, { passive: false });
        canvas.addEventListener('touchmove', e => { mousePos = getMousePos(e.touches[0]); e.preventDefault(); }, { passive: false });
        canvas.addEventListener('touchend', () => { isTouching = false; });

        // Auto-pause when tab is hidden
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && gameState === 'playing' && !isPaused) {
                togglePause();
            }
        });
    }

    function checkSelections() {
        startButton.disabled = !(selectedDifficulty && selectedWeapon);
    }
    
    function spawnExplosiveBarrel() {
        const size = 30;
        const x = Math.random() * (CANVAS_WIDTH - size) + size / 2;
        const y = Math.random() * (CANVAS_HEIGHT - size) + size / 2;
        const distToPlayer = Math.sqrt((x - player.x)**2 + (y-player.y)**2);
        if(distToPlayer < 150) { // Don't spawn too close
            spawnExplosiveBarrel();
            return;
        }
        explosiveBarrels.push({ x, y, size, hp: 10, color: '#cc3300' });
    }

    function startGame() {
        player = createInitialPlayer(selectedDifficulty, selectedWeapon);
        
        enemies = [];
        projectiles = [];
        enemyProjectiles = [];
        xpGems = [];
        healthPacks = [];
        nukes = [];
        explosions = [];
        orbitalShields = [];
        speedBoosts = [];
        fireRateBoosts = [];
        freezeBombs = [];
        invincibilityShields = [];
        blackHoleItems = [];
        drones = [];
        explosiveBarrels = [];
        blackHoles = [];
        availableUpgrades = [...UPGRADES];

        for(let i=0; i<5; i++){
            spawnExplosiveBarrel();
        }

        if (player.shields > 0) {
            for(let i=0; i<player.shields; i++){
                 orbitalShields.push({
                    angle: (i * Math.PI) / (player.shields / 2), radius: 50, speed: 3, size: 15,
                    color: '#FF00FF', damage: 25, lastHitTime: 0
                });
            }
        }
        
        timer = 0;
        gameTime = 0;
        lastSpawnTime = 0;
        spawnInterval = 4000 * DIFFICULTY_SETTINGS[selectedDifficulty].spawnRateMult;
        bossSpawned = false;
        enemiesFrozen = false;
        enemiesFrozenTimer = 0;
        comboCount = 0;
        lastKillTime = 0;
        lastTime = performance.now();
        gameState = 'playing';
        isPaused = false;

        startScreen.classList.add('hidden');
        gameOverScreen.classList.add('hidden');
        levelUpScreen.classList.add('hidden');
        pauseScreen.classList.add('hidden');
        pauseButton.classList.remove('hidden');
        
        updateUI();
        if (animationFrameId) cancelAnimationFrame(animationFrameId);
        gameLoop(performance.now());
    }
    
    function updateDrones(deltaTime) {
        const now = performance.now();
        drones.forEach(drone => {
            drone.angle += 2 * (deltaTime / 1000);
            drone.x = player.x + Math.cos(drone.angle) * drone.radius;
            drone.y = player.y + Math.sin(drone.angle) * drone.radius;

            if (now - drone.lastShotTime > drone.fireRate) {
                const nearestEnemy = findNearestEnemy(drone);
                if (nearestEnemy) {
                    drone.lastShotTime = now;
                    const dx = nearestEnemy.x - drone.x;
                    const dy = nearestEnemy.y - drone.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    projectiles.push({
                        x: drone.x, y: drone.y,
                        dx: (dx/dist) * 6, dy: (dy/dist) * 6,
                        type: 'drone-bullet', damage: 8, lifespan: 1000, color: '#f0f0f0'
                    });
                }
            }
        });
    }

    function updateBlackHoles(deltaTime) {
        blackHoles.forEach((bh, index) => {
            bh.age += deltaTime;
            bh.rotation += 0.1;
            if (bh.age >= bh.duration) {
                explosions.push({ x: bh.x, y: bh.y, radius: bh.pullRadius * 1.2, duration: 400, alpha: 1, damage: 200 });
                sounds.explosion();
                blackHoles.splice(index, 1);
                return;
            }

            enemies.forEach(e => {
                if (e.isBoss) return;
                const dx = bh.x - e.x;
                const dy = bh.y - e.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < bh.pullRadius && dist > 10) {
                    e.x += (dx / dist) * bh.strength;
                    e.y += (dy / dist) * bh.strength;
                }
            });
        });
    }

    function update(deltaTime) {
        if (isPaused || gameState !== 'playing') return;
        const now = performance.now();
        gameTime += deltaTime;
        timer = Math.floor(gameTime / 1000);
        
        if(now - lastKillTime > COMBO_TIMEOUT) {
            comboCount = 0;
        }

        // Update Timers
        if (player.speedBoostTimer > 0) { player.speedBoostTimer -= deltaTime; if (player.speedBoostTimer <= 0) player.speed = player.baseSpeed; }
        if (player.fireRateBoostTimer > 0) { player.fireRateBoostTimer -= deltaTime; if (player.fireRateBoostTimer <= 0) player.fireRate = player.baseFireRate; }
        if (player.invincibilityTimer > 0) { player.invincibilityTimer -= deltaTime; }
        if (enemiesFrozenTimer > 0) { enemiesFrozenTimer -= deltaTime; if (enemiesFrozenTimer <= 0) enemiesFrozen = false; }
        
        // Player Movement
        let moveX = 0, moveY = 0;
        if (keysPressed['KeyW'] || keysPressed['ArrowUp']) moveY -= 1;
        if (keysPressed['KeyS'] || keysPressed['ArrowDown']) moveY += 1;
        if (keysPressed['KeyA'] || keysPressed['ArrowLeft']) moveX -= 1;
        if (keysPressed['KeyD'] || keysPressed['ArrowRight']) moveX += 1;
        
        let currentSpeed = player.isDashing ? player.dashSpeed : player.speed;
        
        if (moveX !== 0 || moveY !== 0) {
            const mag = Math.sqrt(moveX * moveX + moveY * moveY);
            player.x += (moveX / mag) * currentSpeed;
            player.y += (moveY / mag) * currentSpeed;
        } else if(isTouching) {
            const dx = mousePos.x - player.x;
            const dy = mousePos.y - player.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist > currentSpeed) {
                player.x += (dx / dist) * currentSpeed;
                player.y += (dy / dist) * currentSpeed;
            }
        }

        player.x = Math.max(PLAYER_SIZE / 2, Math.min(CANVAS_WIDTH - PLAYER_SIZE / 2, player.x));
        player.y = Math.max(PLAYER_SIZE / 2, Math.min(CANVAS_HEIGHT - PLAYER_SIZE / 2, player.y));
        
        updateEnemySpawning(gameTime);
        if (!enemiesFrozen) {
            updateEnemies(deltaTime);
        }
        updateProjectiles(deltaTime);
        updateXPGems();
        updateExplosions(deltaTime);
        updateOrbitalShields(deltaTime);
        updateDrones(deltaTime);
        updateBlackHoles(deltaTime);


        handleCollisions();

        if (player.hp <= 0) {
            if (timer > highScore) {
                highScore = timer;
                localStorage.setItem('neonSurvivorHighScore', timer);
            }
            gameState = 'gameOver';
            showGameOverScreen();
        }

        if (player.xp >= player.xpToNextLevel) {
            handleLevelUp();
        }
        
        updateUI();
    }
    
    function draw() {
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        ctx.shadowBlur = 10;

        explosiveBarrels.forEach(barrel => {
            ctx.fillStyle = barrel.color;
            ctx.shadowColor = barrel.color;
            ctx.fillRect(barrel.x - barrel.size / 2, barrel.y - barrel.size / 2, barrel.size, barrel.size);
            ctx.strokeStyle = '#ff6633';
            ctx.strokeRect(barrel.x - barrel.size / 2, barrel.y - barrel.size / 2, barrel.size, barrel.size);
        });

        blackHoles.forEach(bh => {
            const pullProgress = bh.age / bh.duration;
            ctx.save();
            ctx.translate(bh.x, bh.y);
            ctx.beginPath();
            ctx.arc(0, 0, 20 + pullProgress * 20, 0, Math.PI * 2);
            ctx.fillStyle = 'black';
            ctx.fill();
            ctx.shadowColor = '#c084fc';
            ctx.lineWidth = 3;
            for(let i=0; i < 3; i++) {
                ctx.beginPath();
                const startAngle = bh.rotation + (i * Math.PI * 2 / 3);
                const endAngle = startAngle + Math.PI * 0.8;
                ctx.arc(0, 0, 40 + i * 15 + pullProgress * 50, startAngle, endAngle);
                ctx.strokeStyle = `rgba(192, 132, 252, ${1 - pullProgress})`;
                ctx.stroke();
            }
            ctx.restore();
        });

        const itemFont = 'bold 20px sans-serif';
        const drawItem = (item, text, color) => {
            ctx.font = itemFont; ctx.fillStyle = color; ctx.shadowColor = color;
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(text, item.x, item.y);
        };
        healthPacks.forEach(pack => drawItem(pack, '+', '#FF4444'));
        nukes.forEach(nuke => drawItem(nuke, 'N', '#FFFF00'));
        speedBoosts.forEach(item => drawItem(item, 'S', '#00FFFF'));
        fireRateBoosts.forEach(item => drawItem(item, 'F', '#FFA500'));
        freezeBombs.forEach(item => drawItem(item, '❄️', '#87CEEB'));
        invincibilityShields.forEach(item => drawItem(item, '✨', '#F0E68C'));
        blackHoleItems.forEach(item => drawItem(item, '◎', '#c084fc'));
        
        xpGems.forEach(gem => {
            ctx.beginPath(); ctx.arc(gem.x, gem.y, 5, 0, Math.PI * 2);
            ctx.fillStyle = '#39FF14'; ctx.shadowColor = '#39FF14'; ctx.fill();
        });

        // Player Invincibility Shield
        if (player.invincibilityTimer > 0) {
            ctx.beginPath();
            ctx.arc(player.x, player.y, PLAYER_SIZE, 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(255, 255, 0, ${0.5 + Math.sin(Date.now()/100)*0.2})`;
            ctx.lineWidth = 3;
            ctx.stroke();
        }

        ctx.fillStyle = player.isDashing ? '#FFFFFF' : '#00FFFF';
        ctx.shadowColor = player.isDashing ? '#FFFFFF' : '#00FFFF';
        ctx.fillRect(player.x - PLAYER_SIZE / 2, player.y - PLAYER_SIZE / 2, PLAYER_SIZE, PLAYER_SIZE);
        
        orbitalShields.forEach(s => {
            ctx.beginPath(); ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
            ctx.fillStyle = s.color; ctx.shadowColor = s.color; ctx.fill();
        });
        
        drones.forEach(drone => {
            ctx.save();
            ctx.translate(drone.x, drone.y);
            ctx.rotate(drone.angle);
            ctx.beginPath();
            ctx.moveTo(0, -8); ctx.lineTo(8, 8); ctx.lineTo(-8, 8);
            ctx.closePath();
            ctx.fillStyle = '#f0f0f0'; ctx.shadowColor = '#f0f0f0'; ctx.fill();
            ctx.restore();
        });


        enemies.forEach(e => {
            ctx.fillStyle = e.color; ctx.shadowColor = e.color;
            ctx.fillRect(e.x - e.size / 2, e.y - e.size / 2, e.size, e.size);
            if (e.isElite) {
                ctx.strokeStyle = e.color;
                ctx.lineWidth = 3;
                ctx.strokeRect(e.x - e.size / 2, e.y - e.size / 2, e.size, e.size);
            }
            if (enemiesFrozen) {
                ctx.fillStyle = 'rgba(173, 216, 230, 0.5)';
                ctx.fillRect(e.x - e.size / 2, e.y - e.size / 2, e.size, e.size);
            }
        });

        projectiles.forEach(p => {
            ctx.shadowColor = '#FFFFFF';
            if (p.type === 'laser') {
                ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p.endX, p.endY);
                ctx.strokeStyle = `rgba(255, 0, 255, ${p.lifespan / 100})`;
                ctx.lineWidth = 5; ctx.shadowColor = '#FF00FF'; ctx.stroke();
            } else if (p.type === 'arrow') {
                ctx.save();
                ctx.translate(p.x, p.y);
                ctx.rotate(Math.atan2(p.dy, p.dx));
                ctx.beginPath();
                ctx.moveTo(8, 0); ctx.lineTo(-8, -4); ctx.lineTo(-8, 4);
                ctx.closePath();
                ctx.fillStyle = '#D2B48C'; ctx.shadowColor = '#D2B48C'; ctx.fill();
                ctx.restore();
            } else if (p.type === 'flame') {
                ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, ${100 + Math.random() * 100}, 0, 0.8)`;
                ctx.shadowColor = '#FFA500'; ctx.fill();
            } else if (p.type === 'lightning') {
                ctx.beginPath();
                ctx.moveTo(p.startX, p.startY);
                ctx.lineTo(p.endX, p.endY);
                ctx.strokeStyle = `rgba(173, 216, 230, ${p.lifespan / 200})`;
                ctx.lineWidth = 3;
                ctx.shadowColor = '#ADD8E6';
                ctx.stroke();
            } else if (p.type === 'drone-bullet') {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 4, 0, Math.PI*2);
                ctx.fillStyle = p.color;
                ctx.shadowColor = p.color;
                ctx.fill();
            } else {
                 ctx.beginPath(); ctx.fillStyle = p.color || '#FFFFFF';
                if (p.type === 'bomb') ctx.arc(p.x, p.y, 8, 0, Math.PI * 2);
                else ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
                ctx.fill();
            }
        });
        enemyProjectiles.forEach(p => {
            ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fillStyle = p.color; ctx.shadowColor = p.color; ctx.fill();
        });

        explosions.forEach(exp => {
            ctx.beginPath(); ctx.arc(exp.x, exp.y, exp.radius, 0, Math.PI * 2);
            ctx.fillStyle = exp.color || `rgba(255, 255, 0, ${exp.alpha})`;
            ctx.fill();
        });
        ctx.shadowBlur = 0;
        ctx.lineWidth = 1;
    }
    
    function gameLoop(timestamp) {
        if (isPaused) return;
        const deltaTime = timestamp - lastTime;
        lastTime = timestamp;
        update(deltaTime);
        draw();
        animationFrameId = requestAnimationFrame(gameLoop);
    }
    
    function updateUI(){
        levelUI.textContent = `레벨: ${player.level}`;
        timerUI.textContent = formatTime(timer);
        comboUI.textContent = comboCount > 1 ? `${comboCount} 콤보!` : '';
        
        const currentRunRank = getRank(timer);
        currentRankUI.innerHTML = `<span style="color: ${currentRunRank.color}; text-shadow: 0 0 5px ${currentRunRank.color};">${currentRunRank.name}</span>`;

        const rank = getRank(highScore);
        highscoreUI.innerHTML = `최고기록: ${formatTime(highScore)} <span style="color: ${rank.color}; text-shadow: 0 0 5px ${rank.color};">(${rank.name})</span>`;
        hpBar.style.width = `${(player.hp / player.maxHp) * 100}%`;
        xpBar.style.width = `${(player.xp / player.xpToNextLevel) * 100}%`;
    }

    function updateEnemySpawning(now) {
        if (now - lastSpawnTime > spawnInterval) {
            lastSpawnTime = now;
            spawnInterval = Math.max(500, spawnInterval * 0.98);
            const spawnCount = 1 + Math.floor(timer / 15);
            for (let i = 0; i < spawnCount; i++) spawnEnemy();
        }
        if (!bossSpawned && timer >= 120) {
            spawnEnemy('boss'); bossSpawned = true;
        }
    }

    function spawnEnemy(type) {
        const diffSettings = DIFFICULTY_SETTINGS[selectedDifficulty];
        const side = Math.floor(Math.random() * 4);
        let x, y;
        if (side === 0) { x = -20; y = Math.random() * CANVAS_HEIGHT; }
        else if (side === 1) { x = CANVAS_WIDTH + 20; y = Math.random() * CANVAS_HEIGHT; }
        else if (side === 2) { x = Math.random() * CANVAS_WIDTH; y = -20; }
        else { x = Math.random() * CANVAS_WIDTH; y = CANVAS_HEIGHT + 20; }
        
        if (!type) {
            const roll = Math.random();
            if (roll < 0.5) type = 'grunt';
            else if (roll < 0.7) type = 'shooter';
            else if (roll < 0.85) type = 'tank';
            else type = 'bomber';
        }

        let enemy;
        const enemyStrength = 1 + timer / 60;
        const hpMultiplier = diffSettings.enemyHpMult * enemyStrength;
        const speedMultiplier = diffSettings.enemySpeedMult;
        
        switch (type) {
            case 'boss': enemy = { id: performance.now(), x, y, size: 80, speed: 0.8 * speedMultiplier, hp: 5000 * hpMultiplier, maxHp: 5000 * hpMultiplier, color: '#FF0000', type: 'boss', isBoss: true, lastAttack: 0, attackCooldown: 2000 }; break;
            case 'shooter': enemy = { id: performance.now(), x, y, size: 25, speed: 1 * speedMultiplier, hp: 30 * hpMultiplier, color: '#FFFF00', type: 'shooter', lastAttack: 0, attackCooldown: 3000 }; break;
            case 'tank': enemy = { id: performance.now(), x, y, size: 40, speed: 0.6 * speedMultiplier, hp: 150 * hpMultiplier, color: '#FF00FF', type: 'tank' }; break;
            case 'bomber': enemy = { id: performance.now(), x, y, size: 22, speed: 1.8 * speedMultiplier, hp: 15 * hpMultiplier, color: '#FFA500', type: 'bomber' }; break;
            default: enemy = { id: performance.now(), x, y, size: 20, speed: 1.5 * speedMultiplier, hp: 20 * hpMultiplier, color: '#FF5733', type: 'grunt' };
        }
        
        // Elite monster logic
        const isElite = !enemy.isBoss && Math.random() < 0.05; // 5% chance
        if (isElite) {
            enemy.isElite = true;
            enemy.hp *= 3;
            enemy.size *= 1.5;
            enemy.color = '#c084fc'; // Purple
        }

        enemies.push(enemy);
    }

    function updateEnemies() {
        enemies.forEach(e => {
            const dx = player.x - e.x; const dy = player.y - e.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (e.type === 'shooter' || e.type === 'boss') {
                if (dist > 250) { e.x += (dx / dist) * e.speed; e.y += (dy / dist) * e.speed; }
                const now = performance.now();
                if (now - e.lastAttack > e.attackCooldown) {
                    e.lastAttack = now;
                    enemyProjectiles.push({ x: e.x, y: e.y, dx: (dx/dist)*3, dy: (dy/dist)*3, size: e.isBoss ? 12 : 8, color: '#FFFF00', damage: e.isBoss ? 25 : 15 });
                }
            } else { e.x += (dx / dist) * e.speed; e.y += (dy / dist) * e.speed; }
        });
    }

    function findNearestEnemy(from, excludedIds = []) {
        let nearest = null, minDistance = Infinity;
        enemies.forEach(e => {
            if (excludedIds.includes(e.id)) return;
            const dist = Math.sqrt((e.x - from.x)**2 + (e.y - from.y)**2);
            if (dist < minDistance) { minDistance = dist; nearest = e; }
        });
        return nearest;
    }

    function updateProjectiles(deltaTime) {
        const now = performance.now();
        if (now - player.lastShotTime > player.fireRate && enemies.length > 0) {
            const nearestEnemy = findNearestEnemy(player);
            
            if (nearestEnemy) {
                player.lastShotTime = now;
                sounds.shoot();
                const dx = nearestEnemy.x - player.x; const dy = nearestEnemy.y - player.y;

                if (player.weaponType === 'shotgun') {
                    const weaponStats = WEAPON_SETTINGS['shotgun'];
                    for (let i = 0; i < weaponStats.pellets; i++) {
                        const angle = Math.atan2(dy, dx) + (Math.random() - 0.5) * weaponStats.spread;
                        const speed = 8 + (Math.random() - 0.5) * 2;
                        projectiles.push({ x: player.x, y: player.y, dx: Math.cos(angle) * speed, dy: Math.sin(angle) * speed, type: 'pellet', lifespan: 500, damage: player.projectileDamage });
                    }
                } else if (player.weaponType === 'laser') {
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const dirX = dx / dist; const dirY = dy / dist;
                    projectiles.push({ x: player.x, y: player.y, endX: player.x + dirX * 1000, endY: player.y + dirY * 1000, type: 'laser', lifespan: 100, hitEnemies: new Set(), damage: player.projectileDamage });
                } else if (player.weaponType === 'bow') {
                    const angle = Math.atan2(dy, dx);
                    const speed = 12;
                    projectiles.push({ x: player.x, y: player.y, dx: Math.cos(angle) * speed, dy: Math.sin(angle) * speed, type: 'arrow', gravity: 0.03, damage: player.projectileDamage });
                } else if (player.weaponType === 'flamethrower') {
                    for (let i = 0; i < 3; i++) {
                        const angle = Math.atan2(dy, dx) + (Math.random() - 0.5) * 0.4;
                        const speed = 6 + (Math.random() - 0.5) * 2;
                        projectiles.push({ x: player.x, y: player.y, dx: Math.cos(angle) * speed, dy: Math.sin(angle) * speed, type: 'flame', lifespan: 300, damage: player.projectileDamage, size: Math.random() * 3 + 4, hitEnemies: new Set() });
                    }
                } else if (player.weaponType === 'chain-lightning') {
                    projectiles.push({
                        type: 'lightning',
                        startX: player.x, startY: player.y,
                        endX: nearestEnemy.x, endY: nearestEnemy.y,
                        targetId: nearestEnemy.id,
                        damage: player.projectileDamage,
                        lifespan: 200, jumpsLeft: 3, hitEnemies: [nearestEnemy.id]
                    });
                } else {
                    for (let i = 0; i < player.projectiles; i++) {
                        const angleOffset = (i - (player.projectiles - 1) / 2) * 0.2;
                        const dist = Math.sqrt(dx*dx+dy*dy);
                        const dirX = dx / dist; const dirY = dy / dist;
                        const rDirX = dirX * Math.cos(angleOffset) - dirY * Math.sin(angleOffset);
                        const rDirY = dirX * Math.sin(angleOffset) + dirY * Math.cos(angleOffset);
                        let proj = { x: player.x, y: player.y, dx: rDirX * 7, dy: rDirY * 7, type: player.projectileType, damage: player.projectileDamage };
                        if (proj.type === 'missile') { proj.target = nearestEnemy; proj.speed = 6; }
                        if (proj.type === 'bomb') { proj.gravity = 0.05; proj.fuse = 1500; }
                        projectiles.push(proj);
                    }
                }
            }
        }

        projectiles.forEach((p, index) => {
            if (p.lifespan) { p.lifespan -= deltaTime; if (p.lifespan <= 0) projectiles.splice(index, 1); }
            if (p.type === 'laser' || p.type === 'lightning') return;

            if (p.type === 'missile' && p.target && p.target.hp > 0) {
                const dx = p.target.x - p.x; const dy = p.target.y - p.y; const dist = Math.sqrt(dx*dx+dy*dy);
                if (dist > 5) { p.dx = (dx / dist) * p.speed; p.dy = (dy / dist) * p.speed; }
            } else if (p.type === 'bomb' || p.type === 'arrow') {
                p.dy += p.gravity;
                if (p.type === 'bomb') {
                    p.fuse -= deltaTime;
                    if (p.fuse <= 0) {
                        explosions.push({ x: p.x, y: p.y, radius: 80, duration: 200, alpha: 1, damage: p.damage });
                        sounds.explosion();
                        projectiles.splice(index, 1);
                    }
                }
            }
            p.x += p.dx; p.y += p.dy;
        });
        projectiles = projectiles.filter(p => p.x > -10 && p.x < CANVAS_WIDTH + 10 && p.y > -10 && p.y < CANVAS_HEIGHT + 10);

        enemyProjectiles.forEach(p => { p.x += p.dx; p.y += p.dy; });
        enemyProjectiles = enemyProjectiles.filter(p => p.x > 0 && p.x < CANVAS_WIDTH && p.y > 0 && p.y < CANVAS_HEIGHT);
    }
    
    function updateXPGems() {
        xpGems.forEach(gem => {
            const dx = player.x - gem.x; const dy = player.y - gem.y; const dist = Math.sqrt(dx*dx+dy*dy);
            if (dist < player.pickupRadius) {
                gem.x += (dx / dist) * 4; gem.y += (dy / dist) * 4;
            }
        });
    }

    function updateExplosions(deltaTime) {
        explosions.forEach((exp, i) => { exp.alpha -= deltaTime / exp.duration; if (exp.alpha <= 0) explosions.splice(i, 1); });
    }
    
    function updateOrbitalShields(deltaTime) {
        orbitalShields.forEach((shield, i) => {
            shield.angle += shield.speed * (deltaTime / 1000);
            shield.x = player.x + Math.cos(shield.angle) * shield.radius;
            shield.y = player.y + Math.sin(shield.angle) * shield.radius;
        });
    }
    
    function distToSegment(p, v, w) {
        const l2 = (v.x - w.x)**2 + (v.y - w.y)**2;
        if (l2 === 0) return Math.sqrt((p.x - v.x)**2 + (p.y - v.y)**2);
        let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
        t = Math.max(0, Math.min(1, t));
        const px = v.x + t * (w.x - v.x);
        const py = v.y + t * (w.y - v.y);
        return Math.sqrt((p.x - px)**2 + (p.y - py)**2);
    }

    function handleCollisions() {
        explosiveBarrels.forEach((barrel, barrelIndex) => {
            for (let pIndex = projectiles.length - 1; pIndex >= 0; pIndex--) {
                 const p = projectiles[pIndex];
                 if (['laser', 'flame'].includes(p.type)) continue;
                 if (Math.sqrt((p.x - barrel.x)**2 + (p.y - barrel.y)**2) < barrel.size / 2) {
                    barrel.hp -= p.damage;
                    projectiles.splice(pIndex, 1);
                    if (barrel.hp <= 0) {
                        explosions.push({ 
                            x: barrel.x, y: barrel.y, radius: 100, duration: 300, 
                            alpha: 1, damage: 100, playerDamage: 25, color: 'rgba(255, 100, 0, 0.8)' 
                        });
                        sounds.explosion();
                        explosiveBarrels.splice(barrelIndex, 1);
                        setTimeout(spawnExplosiveBarrel, 10000);
                        return;
                    }
                 }
            }
        });

        projectiles.forEach((p, pIndex) => {
             for (const e of enemies) {
                let collision = false;
                if (p.type === 'laser') {
                    if (!p.hitEnemies.has(e.id) && distToSegment(e, {x:p.x, y:p.y}, {x:p.endX, y:p.endY}) < e.size / 2) {
                        e.hp -= p.damage; p.hitEnemies.add(e.id);
                    }
                } else if (p.type === 'lightning') {
                    if(e.id === p.targetId && p.lifespan > 0){
                         p.lifespan = 0; // Mark for removal
                         e.hp -= p.damage;
                         if(p.jumpsLeft > 0) {
                             const nextTarget = findNearestEnemy(e, p.hitEnemies);
                             if(nextTarget){
                                 projectiles.push({
                                     type: 'lightning', startX: e.x, startY: e.y, endX: nextTarget.x, endY: nextTarget.y,
                                     targetId: nextTarget.id, damage: p.damage * 0.8, lifespan: 200,
                                     jumpsLeft: p.jumpsLeft - 1, hitEnemies: [...p.hitEnemies, nextTarget.id]
                                 });
                             }
                         }
                    }
                } else if (Math.sqrt((p.x - e.x)**2 + (p.y - e.y)**2) < e.size / 2 + (p.size || 5)) {
                    collision = true;
                }

                if (collision) {
                    if (p.type === 'flame' || p.type === 'drone-bullet') {
                         if (!p.hitEnemies?.has(e.id)) {
                            e.hp -= p.damage; 
                            p.hitEnemies?.add(e.id);
                         }
                         if(p.type === 'drone-bullet') projectiles.splice(pIndex, 1);
                    } else {
                        e.hp -= p.damage;
                        if (player.explosiveProjectiles || p.type === 'bomb' || p.type === 'missile') {
                            explosions.push({ x: p.x, y: p.y, radius: p.type === 'bomb' || p.type === 'missile' ? 80 : 50, duration: 200, alpha: 1, damage: p.damage / 2 });
                            sounds.explosion();
                        }
                        projectiles.splice(pIndex, 1);
                        return;
                    }
                }
            }
        });

        explosions.forEach(exp => {
            enemies.forEach(e => {
                if (Math.sqrt((exp.x - e.x)**2 + (exp.y - e.y)**2) < e.size / 2 + exp.radius) {
                    e.hp -= exp.damage * exp.alpha;
                }
            });
            if(exp.playerDamage && player.invincibilityTimer <= 0 && Math.sqrt((exp.x - player.x)**2 + (exp.y - player.y)**2) < PLAYER_SIZE / 2 + exp.radius) {
                player.hp -= exp.playerDamage;
                if(player.hp > 0) sounds.hit();
            }
        });
        
        const now = performance.now();
        orbitalShields.forEach(s => {
            if (now - s.lastHitTime < 500) return;
            for (const e of enemies) {
                 if (Math.sqrt((s.x - e.x)**2 + (s.y - e.y)**2) < e.size / 2 + s.size / 2) {
                    sounds.hit(); e.hp -= s.damage; s.lastHitTime = now; break;
                 }
            }
        });
        
        let newDrops = { xp: [], hp: [], nuke: [], speed: [], fire: [], freeze: [], inv: [], blackHole: []};
        enemies = enemies.filter(e => {
            if (e.hp <= 0) {
                comboCount++;
                lastKillTime = performance.now();
                if(e.type === 'bomber') {
                    explosions.push({ x: e.x, y: e.y, radius: 80, duration: 300, alpha: 1, playerDamage: 20, damage: 50, color: 'rgba(255, 165, 0, 0.7)' });
                    sounds.explosion();
                }

                const value = e.isBoss ? 100 : (e.isElite ? 50 : (e.type === 'tank' ? 15 : (e.type === 'bomber' ? 3 : (e.type === 'shooter' ? 5 : 2))));
                newDrops.xp.push({ x: e.x, y: e.y, value });
                const dropChance = e.isElite ? 0.3 : 0.08;
                if (Math.random() < dropChance) newDrops.hp.push({ x: e.x, y: e.y });
                if (Math.random() < 0.02) newDrops.nuke.push({ x: e.x, y: e.y });
                if (Math.random() < 0.03) newDrops.speed.push({ x: e.x, y: e.y });
                if (Math.random() < 0.03) newDrops.fire.push({ x: e.x, y: e.y });
                if (Math.random() < 0.02) newDrops.freeze.push({ x: e.x, y: e.y });
                if (Math.random() < 0.015) newDrops.inv.push({ x: e.x, y: e.y });
                if (Math.random() < (e.isElite ? 0.05 : 0.005)) newDrops.blackHole.push({ x: e.x, y: e.y });
                return false;
            }
            return true;
        });
        xpGems.push(...newDrops.xp); healthPacks.push(...newDrops.hp); nukes.push(...newDrops.nuke);
        speedBoosts.push(...newDrops.speed); fireRateBoosts.push(...newDrops.fire);
        freezeBombs.push(...newDrops.freeze); invincibilityShields.push(...newDrops.inv);
        blackHoleItems.push(...newDrops.blackHole);

        if (!player.isDashing && player.invincibilityTimer <= 0) {
            enemies.forEach(e => {
                if (Math.sqrt((player.x - e.x)**2 + (player.y - e.y)**2) < PLAYER_SIZE / 2 + e.size / 2) {
                    player.hp -= 10;
                    if(player.hp > 0) sounds.hit();
                }
            });
            enemyProjectiles = enemyProjectiles.filter(p => {
                if (Math.sqrt((player.x - p.x)**2 + (player.y - p.y)**2) < PLAYER_SIZE / 2 + p.size / 2) {
                    player.hp -= p.damage; 
                    if(player.hp > 0) sounds.hit();
                    return false;
                } return true;
            });
        }
        
        xpGems = xpGems.filter(gem => {
            if (Math.sqrt((player.x - gem.x)**2 + (player.y - gem.y)**2) < PLAYER_SIZE/2+5) { 
                sounds.xp(); 
                const xpMultiplier = 1 + Math.floor(comboCount / 20) * 0.1;
                player.xp += gem.value * xpMultiplier; 
                return false; 
            } return true;
        });
        healthPacks = healthPacks.filter(pack => {
            if (Math.sqrt((player.x - pack.x)**2 + (player.y - pack.y)**2) < PLAYER_SIZE/2+10) { sounds.heal(); player.hp = Math.min(player.maxHp, player.hp + 20); return false; } return true;
        });
        nukes = nukes.filter(nuke => {
            if (Math.sqrt((player.x - nuke.x)**2 + (player.y - nuke.y)**2) < PLAYER_SIZE/2+10) {
                sounds.nuke();
                enemies.forEach(e => { if(!e.isBoss) e.hp -= 200; explosions.push({ x: e.x, y: e.y, radius: e.size * 1.5, duration: 500, alpha: 1, damage: 0 }); });
                return false;
            } return true;
        });
        speedBoosts = speedBoosts.filter(item => {
            if (Math.sqrt((player.x - item.x)**2 + (player.y - item.y)**2) < PLAYER_SIZE / 2 + 10) {
                sounds.powerup(); player.speedBoostTimer = 5000; player.speed = player.baseSpeed * 1.5; return false;
            } return true;
        });
        fireRateBoosts = fireRateBoosts.filter(item => {
            if (Math.sqrt((player.x - item.x)**2 + (player.y - item.y)**2) < PLAYER_SIZE / 2 + 10) {
                sounds.powerup(); player.fireRateBoostTimer = 5000; player.fireRate = player.baseFireRate * 0.5; return false;
            } return true;
        });
        freezeBombs = freezeBombs.filter(item => {
            if (Math.sqrt((player.x - item.x)**2 + (player.y - item.y)**2) < PLAYER_SIZE / 2 + 10) {
                sounds.freeze(); enemiesFrozen = true; enemiesFrozenTimer = 3000; return false;
            } return true;
        });
        invincibilityShields = invincibilityShields.filter(item => {
             if (Math.sqrt((player.x - item.x)**2 + (player.y - item.y)**2) < PLAYER_SIZE / 2 + 10) {
                sounds.shieldUp(); player.invincibilityTimer = 5000; return false;
            } return true;
        });
        blackHoleItems = blackHoleItems.filter(item => {
             if (Math.sqrt((player.x - item.x)**2 + (player.y - item.y)**2) < PLAYER_SIZE / 2 + 10) {
                sounds.blackHole();
                blackHoles.push({ 
                    x: player.x, y: player.y, duration: 5000, age: 0, 
                    pullRadius: 250, strength: 3, rotation: 0 
                });
                return false;
            } return true;
        });
    }

    function handleLevelUp() {
        sounds.levelUp(); isPaused = true;
        player.xp -= player.xpToNextLevel; player.level++; player.xpToNextLevel = Math.floor(player.xpToNextLevel * 1.5);
        levelUpOptionsContainer.innerHTML = '';
        const shuffled = availableUpgrades.sort(() => 0.5 - Math.random());
        let options = shuffled.slice(0, 3);
        if (player.weaponType !== 'machine-gun' && !player.explosiveProjectiles) {
            const explosiveUpgrade = UPGRADES.find(u => u.id === 'explosive');
            if(explosiveUpgrade && !options.includes(explosiveUpgrade)) options[0] = explosiveUpgrade;
        }
        options.forEach(opt => {
            const card = document.createElement('div');
            card.className = 'upgrade-card p-6 rounded-lg text-left w-64';
            card.innerHTML = `<h3 class="text-2xl font-bold text-cyan-300 mb-2">${opt.title}</h3><p class="text-lg">${opt.description}</p>`;
            card.onclick = () => selectUpgrade(opt);
            levelUpOptionsContainer.appendChild(card);
        });
        levelUpScreen.classList.remove('hidden');
    }

    function selectUpgrade(upgrade) {
        upgrade.apply(player);
        if (upgrade.id === 'drone') {
            drones = [];
            for(let i=0; i<player.drones; i++){
                drones.push({
                    angle: (i * Math.PI * 2) / player.drones,
                    radius: 70 + (i%2 * 15),
                    fireRate: 1500,
                    lastShotTime: 0,
                });
            }
        }
        if(upgrade.id === 'shield') {
             const newShield = {
                angle: (orbitalShields.length * Math.PI) / (player.shields / 2), radius: 50, speed: 3, size: 15,
                color: '#FF00FF', damage: 25, lastHitTime: 0
            }; orbitalShields.push(newShield);
        }
        if(upgrade.id === 'explosive' || (upgrade.id === 'multishot' && player.projectiles > 4)) {
            availableUpgrades = availableUpgrades.filter(u => u.id !== upgrade.id);
        }
        isPaused = false; levelUpScreen.classList.add('hidden');
        lastTime = performance.now();
        requestAnimationFrame(gameLoop);
    }
    
    function showGameOverScreen() {
        if(animationFrameId) cancelAnimationFrame(animationFrameId);

        const currentRank = getRank(timer);
        const highscoreRank = getRank(highScore);
        
        gameOverTimeUI.textContent = `생존 시간: ${formatTime(timer)}`;
        gameOverRankUI.innerHTML = `달성 랭크: <span style="color: ${currentRank.color}; text-shadow: 0 0 8px ${currentRank.color};">${currentRank.name}</span>`;
        gameOverHighscoreUI.innerHTML = `최고 기록: ${formatTime(highScore)} <span style="color: ${highscoreRank.color}; text-shadow: 0 0 5px ${highscoreRank.color};">(${highscoreRank.name})</span>`;
        
        startScreenHighscoreUI.innerHTML = `최고 기록: ${formatTime(highScore)} &bull; 랭크: <span style="color: ${highscoreRank.color}; text-shadow: 0 0 8px ${highscoreRank.color};">${highscoreRank.name}</span>`;

        gameOverScreen.classList.remove('hidden');
        pauseButton.classList.add('hidden');
    }

    init();
});
</script>
</body>
</html>
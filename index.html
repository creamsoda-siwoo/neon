
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>네온 서바이버</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      font-family: 'Orbitron', sans-serif;
      overflow: hidden;
      background-color: #0d0221;
      color: white;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      margin: 0;
      padding: 1rem;
      touch-action: none;
    }
    .game-container {
      background: #0a0a1f;
      border: 2px solid #00ffff;
      box-shadow: 0 0 20px #00ffff, inset 0 0 20px #00ffff;
      width: 90vmin;
      aspect-ratio: 4 / 3;
      touch-action: none;
    }
    #game-canvas {
      background-color: #0d0221;
      cursor: none;
      width: 100%;
      height: 100%;
      display: block;
    }
    .text-glow {
      color: #fff;
      text-shadow: 0 0 7px #fff, 0 0 10px #fff, 0 0 21px #ff00ff, 0 0 42px #ff00ff;
    }
    .button-retro {
      background-color: transparent;
      border: 2px solid #fff;
      color: #fff;
      padding: 0.75rem 1.5rem;
      text-transform: uppercase;
      letter-spacing: 2px;
      transition: all 0.2s ease-in-out;
      text-shadow: 0 0 8px #ff00ff;
      cursor: pointer;
    }
    .button-retro:hover:not(:disabled) {
      background-color: #fff;
      color: #0d0221;
      box-shadow: 0 0 20px #fff, 0 0 30px #ff00ff;
    }
    .button-retro:disabled {
        cursor: not-allowed;
        opacity: 0.5;
    }
    .selection-button {
        border-width: 2px;
        border-color: #fff;
        background-color: transparent;
        padding: 0.5rem;
        height: 100%;
        font-size: 0.875rem;
    }
    .selection-button.selected {
        background-color: #00ffff;
        color: #0d0221;
        box-shadow: 0 0 20px #00ffff;
    }
    .upgrade-card {
      border: 2px solid #00ffff;
      background: rgba(13, 2, 33, 0.8);
      transition: all 0.2s ease-in-out;
      cursor: pointer;
    }
    .upgrade-card:hover {
      background: rgba(0, 255, 255, 0.2);
      box-shadow: 0 0 15px #00ffff;
      transform: translateY(-5px);
    }
    .overlay {
        position: absolute;
        inset: 0;
        background-color: rgba(0,0,0,0.85);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
        z-index: 10;
        padding: 1rem;
    }
    .hidden {
        display: none;
    }
    #start-button {
        padding: 1rem 2rem;
        font-size: 1.25rem;
        font-weight: bold;
    }
    @keyframes pulse-glow {
        0% {
            transform: scale(1);
            box-shadow: 0 0 15px #00ffff, 0 0 25px #ff00ff;
        }
        50% {
            transform: scale(1.08);
            box-shadow: 0 0 30px #00ffff, 0 0 50px #ff00ff;
        }
        100% {
            transform: scale(1);
            box-shadow: 0 0 15px #00ffff, 0 0 25px #ff00ff;
        }
    }

    #start-button:not(:disabled) {
        border-color: #00ffff;
        color: #00ffff;
        text-shadow: 0 0 8px #00ffff;
        animation: pulse-glow 2s infinite ease-in-out;
    }
    .joystick {
        position: absolute;
        width: 80px;
        height: 80px;
        pointer-events: none;
    }
    .joystick-base {
        position: absolute;
        width: 100%;
        height: 100%;
        border-radius: 50%;
        background-color: rgba(0, 255, 255, 0.1);
        border: 2px solid rgba(0, 255, 255, 0.4);
        box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        transition: transform 0.1s ease-out, background-color 0.1s, border-color 0.1s;
    }
    .joystick-handle {
        position: absolute;
        width: 40px;
        height: 40px;
        top: 20px;
        left: 20px;
        border-radius: 50%;
        background-color: rgba(0, 255, 255, 0.3);
        border: 2px solid rgba(0, 255, 255, 0.8);
        box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
        transition: transform 0.05s linear, background-color 0.1s, border-color 0.1s;
    }
    .joystick.active .joystick-base {
        transform: scale(1.1);
        background-color: rgba(0, 255, 255, 0.2);
        border-color: rgba(0, 255, 255, 0.8);
    }
    .joystick.active .joystick-handle {
        background-color: rgba(0, 255, 255, 0.6);
        border-color: #fff;
    }
    .stat {
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }
    .stat-label {
        width: 60px;
        text-align: right;
        font-size: 0.8rem;
        color: #a7a7a7;
        flex-shrink: 0;
    }
    .stat-bar-bg {
        flex-grow: 1;
        height: 10px;
        background-color: rgba(0, 50, 50, 0.5);
        border: 1px solid #00ffff;
        border-radius: 5px;
        padding: 1px;
    }
    .stat-bar-fill {
        height: 100%;
        background: linear-gradient(90deg, #ff00ff, #00ffff);
        border-radius: 3px;
        box-shadow: 0 0 5px #00ffff;
        transition: width 0.3s ease-out;
    }
  </style>
</head>
<body>

  <main class="flex flex-col items-center">
    <div class="flex justify-between w-full mb-2 px-2 text-glow" style="max-width: 90vmin;">
        <div class="flex gap-4 items-center">
            <div id="level-ui" class="text-xl">레벨: 1</div>
            <div id="current-rank-ui" class="text-lg"></div>
        </div>
        <div class="flex flex-col items-center">
            <div id="timer-ui" class="text-2xl font-bold">00:00</div>
            <div id="combo-ui" class="text-xl font-bold text-yellow-400 h-6" style="text-shadow: 0 0 8px #facc15;"></div>
        </div>
        <div id="highscore-ui" class="text-xl text-right">최고기록: 00:00</div>
    </div>
    
    <div class="w-full h-8 mb-2 flex flex-col justify-around" style="max-width: 90vmin;">
        <div class="w-full bg-gray-700 h-3 rounded-full overflow-hidden border border-red-500">
            <div id="hp-bar" class="bg-red-500 h-full" style="width: 100%"></div>
        </div>
        <div class="w-full bg-gray-700 h-3 rounded-full overflow-hidden border border-cyan-400">
            <div id="xp-bar" class="bg-cyan-400 h-full" style="width: 0%"></div>
        </div>
    </div>

    <div id="game-wrapper" class="relative rounded-lg overflow-hidden game-container">
      <canvas id="game-canvas" width="800" height="600"></canvas>
      <button id="pause-button" class="absolute top-2 right-2 text-2xl w-12 h-12 button-retro hidden items-center justify-center" style="padding: 0;">||</button>
      
      <div id="movement-joystick" class="joystick hidden">
        <div class="joystick-base"></div>
        <div class="joystick-handle"></div>
      </div>
      
      <div id="start-screen" class="overlay">
          <div class="absolute top-4 left-4 text-xs text-gray-500">제작자: 한국인이라면</div>
          <h1 class="text-5xl md:text-6xl font-bold mb-4 text-glow">네온 서바이버</h1>
          <div id="start-screen-highscore" class="text-xl mb-8 text-glow"></div>
          
          <div class="w-full max-w-2xl">
            <h2 class="text-xl mb-2 text-glow">난이도 선택</h2>
            <div id="difficulty-selection" class="grid grid-cols-3 gap-2 mb-4">
                <button class="button-retro selection-button" data-difficulty="쉬움">쉬움</button>
                <button class="button-retro selection-button selected" data-difficulty="보통">보통</button>
                <button class="button-retro selection-button" data-difficulty="어려움">어려움</button>
            </div>
          </div>

          <div class="w-full max-w-2xl mt-4">
              <h2 class="text-xl mb-2 text-glow">무기 선택</h2>
              <div id="weapon-selection" class="grid grid-cols-4 gap-2 mb-2">
                  <button class="button-retro selection-button selected" data-weapon="machine-gun">기관총</button>
                  <button class="button-retro selection-button" data-weapon="missile">유도 미사일</button>
                  <button class="button-retro selection-button" data-weapon="bomb">폭탄</button>
                  <button class="button-retro selection-button" data-weapon="laser">레이저</button>
                  <button class="button-retro selection-button" data-weapon="bow">활</button>
                  <button class="button-retro selection-button" data-weapon="chain-lightning">연쇄 번개</button>
                  <button class="button-retro selection-button" data-weapon="black-hole-generator">블랙홀</button>
                  <button class="button-retro selection-button" data-weapon="plasma-cannon">플라즈마</button>
                  <button class="button-retro selection-button" data-weapon="ricochet-blade">리코</button>
                  <button class="button-retro selection-button" data-weapon="vortex-cannon">볼텍스 캐논</button>
                  <button class="button-retro selection-button" data-weapon="glitch-pulser">글리치 펄서</button>
                  <button class="button-retro selection-button" data-weapon="cryo-blaster">크라이오 블래스터</button>
              </div>
          </div>

          <button id="start-button" class="button-retro mt-8" disabled>게임 시작</button>
      </div>

      <div id="pause-screen" class="overlay hidden">
          <h2 class="text-6xl font-bold mb-8 text-glow">일시정지</h2>
          <div class="flex flex-col gap-4 w-64">
              <button id="resume-button" class="button-retro">계속하기</button>
              <button id="restart-pause-button" class="button-retro">다시 시작</button>
              <button id="quit-button" class="button-retro">그만하기</button>
          </div>
      </div>

      <div id="levelup-screen" class="overlay hidden">
          <h2 class="text-5xl font-bold mb-8 text-glow">레벨 업!</h2>
          <div id="levelup-options" class="grid grid-cols-1 md:grid-cols-3 gap-6">
              <!-- Upgrade cards will be injected here -->
          </div>
      </div>

      <div id="gameover-screen" class="overlay hidden">
          <h2 class="text-6xl font-bold mb-4 text-glow">게임 오버</h2>
          <p id="gameover-time" class="text-3xl mb-2">생존 시간: 00:00</p>
          <p id="gameover-rank" class="text-2xl mb-6"></p>
          <p id="gameover-highscore" class="text-xl mb-8">최고 기록: 00:00</p>
          <button id="restart-button" class="button-retro">새로 시작</button>
      </div>
    </div>
  </main>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- DOM Elements ---
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    const gameWrapper = document.getElementById('game-wrapper');
    const startScreen = document.getElementById('start-screen');
    const pauseScreen = document.getElementById('pause-screen');
    const levelUpScreen = document.getElementById('levelup-screen');
    const gameOverScreen = document.getElementById('gameover-screen');
    const startButton = document.getElementById('start-button');
    const restartButton = document.getElementById('restart-button');
    const pauseButton = document.getElementById('pause-button');
    const levelUpOptionsContainer = document.getElementById('levelup-options');
    const weaponSelection = document.getElementById('weapon-selection');
    const difficultySelection = document.getElementById('difficulty-selection');
    const resumeButton = document.getElementById('resume-button');
    const restartPauseButton = document.getElementById('restart-pause-button');
    const quitButton = document.getElementById('quit-button');

    // Joystick UI
    const movementJoystickUI = document.getElementById('movement-joystick');
    const movementJoystickHandle = movementJoystickUI.querySelector('.joystick-handle');
    
    // UI Elements
    const levelUI = document.getElementById('level-ui');
    const timerUI = document.getElementById('timer-ui');
    const comboUI = document.getElementById('combo-ui');
    const highscoreUI = document.getElementById('highscore-ui');
    const hpBar = document.getElementById('hp-bar');
    const xpBar = document.getElementById('xp-bar');
    const gameOverTimeUI = document.getElementById('gameover-time');
    const gameOverRankUI = document.getElementById('gameover-rank');
    const gameOverHighscoreUI = document.getElementById('gameover-highscore');
    const startScreenHighscoreUI = document.getElementById('start-screen-highscore');
    const currentRankUI = document.getElementById('current-rank-ui');

    // --- Game Constants ---
    const CANVAS_WIDTH = 800;
    const CANVAS_HEIGHT = 600;
    const PLAYER_SIZE = 20;
    const COMBO_TIMEOUT = 2500;
    const HEALTH_PACK_DROP_CHANCE = 0.10; // 10%

    // --- Ranking System ---
    const RANKS = [
        { name: '네온 초심자', threshold: 0, color: '#9ca3af' },
        { name: '그리드 러너', threshold: 60, color: '#6ee7b7' },
        { name: '서킷 브레이커', threshold: 120, color: '#60a5fa' },
        { name: '데이터 스트리머', threshold: 180, color: '#c084fc' },
        { name: '사이버 검투사', threshold: 240, color: '#f87171' },
        { name: '신스웨이브 파수꾼', threshold: 300, color: '#facc15' },
        { name: '디지털 오버로드', threshold: 420, color: '#f472b6' },
        { name: '코드 아크마스터', threshold: 600, color: '#00ffff' },
        { name: '매트릭스 군주', threshold: 900, color: '#ffffff' }
    ];

    function getRank(seconds) {
        let currentRank = RANKS[0];
        for (const rank of RANKS) {
            if (seconds >= rank.threshold) {
                currentRank = rank;
            } else {
                break;
            }
        }
        return currentRank;
    }
    
    // --- Enemy Types ---
    const ENEMY_TYPES = {
        'grunt': { size: 15, hp: 10, speed: 70, color: '#ff4d4d', xp: 1, shape: 'square', damage: 5 },
        'tank': { size: 30, hp: 50, speed: 40, color: '#ff8c66', xp: 5, shape: 'square', damage: 15 },
        'shooter': { size: 18, hp: 15, speed: 60, color: '#fcf003', xp: 2, shape: 'triangle', damage: 10, fireRate: 2000, projectileSpeed: 150 },
        'bomber': { size: 20, hp: 20, speed: 80, color: '#ff99cc', xp: 3, shape: 'square', damage: 20, onDeath: 'explode' },
        'summoner': { size: 25, hp: 40, speed: 50, color: '#cc99ff', xp: 8, shape: 'triangle', damage: 5, actionRate: 5000, action: 'summon' },
        'boss': { size: 50, hp: 500, speed: 60, color: '#ff0000', xp: 50, shape: 'square', damage: 25, fireRate: 1000, projectileSpeed: 200 },
    };


    // --- Game Configs ---
    const DIFFICULTY_SETTINGS = {
        '쉬움': { hp: 120, enemyHpMult: 0.7, enemySpeedMult: 0.8, spawnRateMult: 1.2 },
        '보통': { hp: 100, enemyHpMult: 1.0, enemySpeedMult: 1.0, spawnRateMult: 1.0 },
        '어려움': { hp: 80, enemyHpMult: 1.5, enemySpeedMult: 1.2, spawnRateMult: 0.8 },
    };
    const WEAPON_SETTINGS = {
        'machine-gun': { fireRate: 400, damage: 12, projectileType: 'bullet', name: '기관총', knockback: 20, description: '가장 균형잡힌 무기. 8발마다 강력한 넉백탄 발사!' },
        'missile': { fireRate: 1000, damage: 40, projectileType: 'missile', name: '유도 미사일', explosionRadius: 70, description: '가장 가까운 적을 추적하며 넓은 범위에 폭발 피해를 줍니다.' },
        'bomb': { fireRate: 800, damage: 25, projectileType: 'bomb', name: '폭탄', shrapnelCount: 5, description: '포물선으로 날아가 폭발하며 5개의 파편을 흩뿌립니다.' },
        'laser': { fireRate: 1200, damage: 45, projectileType: 'laser', name: '레이저', slowAmount: 0.5, slowDuration: 1000, description: '적을 관통하며 1초간 이동 속도를 50% 감소시킵니다.' },
        'bow': { fireRate: 600, damage: 25, projectileType: 'arrow', name: '활', critChance: 0.15, critMultiplier: 2, description: '적을 관통하며 15% 확률로 2배의 치명타 피해를 입힙니다.' },
        'chain-lightning': { fireRate: 800, damage: 30, projectileType: 'lightning', name: '연쇄 번개', bounces: 4, description: '적들 사이를 4번 튕기는 번개를 발사합니다.' },
        'black-hole-generator': { fireRate: 2000, damage: 0, projectileType: 'black-hole-orb', name: '블랙홀 생성기', description: '적을 끌어당기고 지속 피해를 주는 소형 블랙홀을 발사합니다.' },
        'plasma-cannon': { fireRate: 1800, damage: 50, projectileType: 'plasma-ball', name: '플라즈마 캐논', explosionRadius: 80, burnDamage: 10, burnDuration: 3000, description: '느리지만 강력한 플라즈마 구체를 발사합니다. 구체는 폭발하며 3초간 화상 피해를 입힙니다.' },
        'ricochet-blade': { fireRate: 750, damage: 20, projectileType: 'ricochet-blade', name: '리코셰 블레이드', bounces: 3, description: '적에게 튕기는 회전 칼날을 발사하여 최대 4명의 적을 공격합니다.' },
        'vortex-cannon': { fireRate: 2200, damage: 10, projectileType: 'vortex-orb', name: '볼텍스 캐논', description: '적을 끌어당기며 지속 피해를 주는 소용돌이를 생성하는 구체를 발사합니다.' },
        'glitch-pulser': { fireRate: 900, damage: 15, projectileType: 'glitch-pulse', name: '글리치 펄서', stunChance: 0.2, stunDuration: 1000, description: '짧은 거리의 적들을 관통하는 에너지 파동을 방출합니다. 피격된 적은 확률적으로 잠시 기절합니다.' },
        'cryo-blaster': { fireRate: 850, damage: 18, projectileType: 'cryo-shard', name: '크라이오 블래스터', slowAmount: 0.4, slowDuration: 1500, freezeOnNthShot: 5, freezeDuration: 1000, description: '적을 느리게 만드는 얼음 파편을 발사합니다. 5번째 공격마다 적을 잠시 얼립니다.'}
    };
   
    // --- Audio ---
    let audioContext;
    try { audioContext = new (window.AudioContext || window.webkitAudioContext)(); }
    catch (e) { console.error("Web Audio API is not supported in this browser"); }

    function playSound(type, frequency, duration, volume = 0.3) {
        if (!audioContext) return;
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        oscillator.type = type;
        oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
        gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.00001, audioContext.currentTime + duration);
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + duration);
    }
    const sounds = {
        hit: () => playSound('square', 150, 0.1, 0.2),
        shoot: () => playSound('triangle', 440, 0.05, 0.1),
        xp: () => playSound('sine', 600, 0.1, 0.2),
        levelUp: () => playSound('sine', 880, 0.4),
        heal: () => playSound('sine', 700, 0.3),
        dash: () => playSound('sine', 300, 0.2, 0.4),
        explosion: () => playSound('sine', 50, 0.3, 0.5),
        nuke: () => playSound('sine', 100, 1.0, 0.8),
        powerup: () => playSound('sine', 900, 0.2),
        freeze: () => playSound('sawtooth', 200, 0.5, 0.4),
        shieldUp: () => playSound('sine', 1000, 0.2, 0.5),
        shieldDown: () => playSound('square', 100, 0.2, 0.5),
        blackHole: () => playSound('noise', 100, 2, 0.4),
        summon: () => playSound('sine', 500, 0.3, 0.2),
    };
    
    // --- Game State ---
    let gameState = 'start';
    let isPaused = false;
    let player, enemies, projectiles, enemyProjectiles, xpGems, healthPacks, nukes, explosions;
    let orbitalShields, speedBoosts, fireRateBoosts, freezeBombs, invincibilityShields, blackHoleItems;
    let drones, explosiveBarrels, blackHoles, vortexes;
    let holographicDecoys, decoys;
    let magnets, xpBombs;
    let damageTexts;
    let screenShake = { duration: 0, magnitude: 0 };
    let timer, gameTime, lastTime, animationFrameId;
    let lastSpawnTime, spawnInterval;
    let bossSpawned, enemiesFrozen, enemiesFrozenTimer;
    let keysPressed = {};
    let highScore = Number(localStorage.getItem('neonSurvivorHighScore') || 0);
    let comboCount, lastKillTime;
    let activeTouchCount = 0;
    
    // Selection and Game-wide states
    let selectedDifficulty, selectedWeapon;
    let gameDifficulty;

    // Joystick State
    const JOYSTICK_BASE_RADIUS = 40;
    const JOYSTICK_MAX_OFFSET = JOYSTICK_BASE_RADIUS - 20;
    const JOYSTICK_DEAD_ZONE = 5;
    let movementJoystickState = { active: false, x: 0, y: 0, dx: 0, dy: 0, touchId: null };


    // --- Upgrades ---
    const UPGRADES = [
        { id: 'firerate', title: "연사력 강화", description: "공격 속도 20% 증가", apply: p => { p.baseFireRate *= 0.8; p.fireRate = p.baseFireRate;} },
        { id: 'damage', title: "강화 탄환", description: "공격력 25% 증가", apply: p => p.projectileDamage *= 1.25 },
        { id: 'multishot', title: "멀티샷", description: "발사체 수 +1", apply: p => p.projectiles++ },
        { id: 'hp', title: "나노 수리봇", description: "최대 체력 20 증가 및 모두 회복", apply: p => { p.maxHp += 20; p.hp = p.maxHp; } },
        { id: 'speed', title: "고속 추진기", description: "이동 속도 10% 증가", apply: p => { p.baseSpeed *= 1.1; p.speed = p.baseSpeed; } },
        { id: 'shield', title: '궤도 방패', description: '주위를 도는 방패 추가', apply: p => p.shields++ },
        { id: 'explosive', title: '폭발탄', description: '탄환이 명중 시 폭발합니다', apply: p => p.explosiveProjectiles = true },
        { id: 'magnet', title: '경험치 자석', description: '경험치 획득 범위 50% 증가', apply: p => p.pickupRadius *= 1.5 },
        { id: 'drone', title: '컴패니언 드론', description: '플레이어를 돕는 공격 드론을 추가합니다.', apply: p => p.drones = (p.drones || 0) + 1 },
        { id: 'regeneration', title: '나노 재생 갑옷', description: '초당 최대 체력의 1%를 회복합니다.', apply: p => p.regeneration = (p.regeneration || 0) + (p.maxHp * 0.01) },
        { id: 'thorns', title: '에너지 가시', description: '플레이어에게 닿는 적에게 20의 피해를 입힙니다.', apply: p => p.thornsDamage = (p.thornsDamage || 0) + 20 },
        { id: 'chain-reaction', title: '연쇄 폭발', description: '적이 죽을 때 15% 확률로 폭발하여 주변에 피해를 줍니다.', apply: p => p.chainReactionChance = (p.chainReactionChance || 0) + 0.15 }
    ];
    let availableUpgrades = [...UPGRADES];
    
    function createInitialPlayer(difficulty, weapon) {
        const difficultySettings = DIFFICULTY_SETTINGS[difficulty];
        const weaponSettings = WEAPON_SETTINGS[weapon];
        
        return {
            x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2,
            hp: difficultySettings.hp, maxHp: difficultySettings.hp,
            xp: 0, level: 1, xpToNextLevel: 10,
            weaponType: weapon,
            fireRate: weaponSettings.fireRate, baseFireRate: weaponSettings.fireRate,
            projectiles: 1, projectileDamage: weaponSettings.damage, projectileType: weaponSettings.projectileType,
            lastShotTime: 0, speed: 220, baseSpeed: 220, pickupRadius: 100,
            dashCooldown: 2000, lastDashTime: 0, isDashing: false, dashDuration: 150, dashSpeed: 750,
            shields: 1, // Start with 1 shield by default
            explosiveProjectiles: false,
            speedBoostTimer: 0, fireRateBoostTimer: 0, invincibilityTimer: 0, magnetTimer: 0,
            drones: 0,
            machineGunShotCount: 0,
            decoyCharges: 0,
            regeneration: 0,
            thornsDamage: 0,
            chainReactionChance: 0,
        };
    }

    function formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
    }

    function updateStartButtonState() {
        startButton.disabled = !(selectedDifficulty && selectedWeapon);
    }

    function togglePause() {
        if (gameState !== 'playing' || levelUpScreen.style.display === 'flex') return;
        isPaused = !isPaused;
        pauseScreen.classList.toggle('hidden', !isPaused);
        if (isPaused) {
            cancelAnimationFrame(animationFrameId);
            screenShake = { duration: 0, magnitude: 0 };
        } else {
            lastTime = performance.now();
            animationFrameId = requestAnimationFrame(gameLoop);
        }
    }

    function selectUpgrade(upgrade) {
        upgrade.apply(player);
        availableUpgrades = availableUpgrades.filter(u => u.id !== upgrade.id && u.id !== 'multishot');
        levelUpScreen.classList.add('hidden');
        isPaused = false;
        gameState = 'playing';
        lastTime = performance.now();
        animationFrameId = requestAnimationFrame(gameLoop);
    }

    function levelUp() {
        isPaused = true;
        gameState = 'levelup';
        sounds.levelUp();
        cancelAnimationFrame(animationFrameId);
        screenShake = { duration: 0, magnitude: 0 };
        
        levelUpOptionsContainer.innerHTML = '';
        const selectedUpgrades = [];
        const tempUpgrades = [...availableUpgrades];
        
        for (let i = 0; i < 3 && tempUpgrades.length > 0; i++) {
            const randomIndex = Math.floor(Math.random() * tempUpgrades.length);
            selectedUpgrades.push(tempUpgrades[randomIndex]);
            tempUpgrades.splice(randomIndex, 1);
        }

        selectedUpgrades.forEach(upgrade => {
            const card = document.createElement('div');
            card.className = 'upgrade-card p-4 rounded-lg flex flex-col items-center justify-center text-center';
            card.innerHTML = `
                <h3 class="text-xl font-bold mb-2 text-glow">${upgrade.title}</h3>
                <p>${upgrade.description}</p>
            `;
            card.onclick = () => selectUpgrade(upgrade);
            levelUpOptionsContainer.appendChild(card);
        });

        levelUpScreen.classList.remove('hidden');
    }
    
    function collectXP(amount) {
        sounds.xp();
        player.xp += amount;
        if (player.xp >= player.xpToNextLevel) {
            player.level++;
            player.xp -= player.xpToNextLevel;
            player.xpToNextLevel = Math.floor(player.xpToNextLevel * 1.5);
            levelUI.textContent = `레벨: ${player.level}`;
            levelUp();
        }
    }
    
    function createDamageText(text, x, y, isCrit = false) {
        damageTexts.push({
            text, x, y,
            alpha: 1,
            timer: 0,
            color: isCrit ? '255, 255, 0' : '255, 255, 255'
        });
    }

    function takeDamage(entity, amount, isCrit = false) {
        entity.hp -= amount;
        if (entity.hp <= 0) {
            entity.hp = 0;
        }

        if (entity === player) {
             if (player.invincibilityTimer > 0) return;
             
             if (player.shields > 0) {
                 player.shields--;
                 player.invincibilityTimer = 1000;
                 sounds.shieldDown();
                 return;
             }
            sounds.hit();
            screenShake = { duration: 200, magnitude: 4 };
        } else {
            createDamageText(String(Math.floor(amount)), entity.x, entity.y, isCrit);
        }
    }
    
    function getSpawnPosition() {
        let x, y;
        const edge = Math.floor(Math.random() * 4);
        if (edge === 0) { // Top
            x = Math.random() * CANVAS_WIDTH;
            y = -30;
        } else if (edge === 1) { // Right
            x = CANVAS_WIDTH + 30;
            y = Math.random() * CANVAS_HEIGHT;
        } else if (edge === 2) { // Bottom
            x = Math.random() * CANVAS_WIDTH;
            y = CANVAS_HEIGHT + 30;
        } else { // Left
            x = -30;
            y = Math.random() * CANVAS_HEIGHT;
        }
        return { x, y };
    }

    function spawnEnemy() {
        if (enemies.length > 150) return;
        
        const { x, y } = getSpawnPosition();
        let enemyType = 'grunt';
        
        const timeFactor = Math.min(gameTime / 180, 1); // Cap difficulty increase at 3 minutes
        const rand = Math.random();
        
        if (gameTime > 60 && rand < 0.1 + timeFactor * 0.2) {
            enemyType = 'summoner';
        } else if (gameTime > 45 && rand < 0.2 + timeFactor * 0.2) {
            enemyType = 'bomber';
        } else if (gameTime > 30 && rand < 0.4 + timeFactor * 0.2) {
            enemyType = 'shooter';
        } else if (gameTime > 15 && rand < 0.6 + timeFactor * 0.2) {
            enemyType = 'tank';
        }

        const base = ENEMY_TYPES[enemyType];
        const finalHp = base.hp * DIFFICULTY_SETTINGS[gameDifficulty].enemyHpMult * (1 + gameTime / 120);
        const finalSpeed = base.speed * DIFFICULTY_SETTINGS[gameDifficulty].enemySpeedMult;
        
        enemies.push({ 
            ...base, 
            x, y, 
            hp: finalHp, 
            maxHp: finalHp, 
            speed: finalSpeed, 
            lastActionTime: 0,
            slowTimer: 0,
            freezeTimer: 0,
            burnTimer: 0,
            burnDamage: 0
        });
    }

    function spawnBoss() {
        if (bossSpawned) return;
        bossSpawned = true;
        const { x, y } = getSpawnPosition();
        const base = ENEMY_TYPES['boss'];
        const finalHp = base.hp * DIFFICULTY_SETTINGS[gameDifficulty].enemyHpMult;
        enemies.push({ ...base, x, y, hp: finalHp, maxHp: finalHp, lastActionTime: 0 });
    }
    
    function shoot(targetX, targetY) {
        if (performance.now() - player.lastShotTime < player.fireRate) return;
        player.lastShotTime = performance.now();
        sounds.shoot();

        const weapon = WEAPON_SETTINGS[player.weaponType];
        
        for (let i = 0; i < player.projectiles; i++) {
            let angle = Math.atan2(targetY - player.y, targetX - player.x);
            if (player.projectiles > 1) {
                angle += (i - (player.projectiles - 1) / 2) * 0.2;
            }
            
            let projectileSpeed = 300;
            let lifetime = 2000;
            
            const projectile = {
                x: player.x,
                y: player.y,
                damage: player.projectileDamage,
                type: player.projectileType,
                owner: 'player',
                lifetime: lifetime,
                explosive: player.explosiveProjectiles,
                explosionRadius: 50,
            };
            
            switch (player.projectileType) {
                case 'missile':
                    projectile.vx = Math.cos(angle) * 150;
                    projectile.vy = Math.sin(angle) * 150;
                    projectile.target = enemies.length > 0 ? enemies.reduce((closest, e) => {
                        const dist = Math.hypot(e.x - player.x, e.y - player.y);
                        return dist < closest.dist ? { dist, e } : closest;
                    }, { dist: Infinity, e: null }).e : null;
                    projectile.explosionRadius = weapon.explosionRadius;
                    break;
                case 'laser':
                    projectile.vx = Math.cos(angle) * 600;
                    projectile.vy = Math.sin(angle) * 600;
                    projectile.lifetime = 1200;
                    projectile.pierce = true;
                    projectile.slowAmount = weapon.slowAmount;
                    projectile.slowDuration = weapon.slowDuration;
                    break;
                case 'arrow':
                    projectile.vx = Math.cos(angle) * 450;
                    projectile.vy = Math.sin(angle) * 450;
                    projectile.pierce = true;
                    projectile.critChance = weapon.critChance;
                    projectile.critMultiplier = weapon.critMultiplier;
                    break;
                case 'lightning':
                    projectile.target = enemies.length > 0 ? enemies[Math.floor(Math.random() * enemies.length)] : null;
                    projectile.bouncesLeft = weapon.bounces;
                    projectile.bounceRange = 150;
                    if (!projectile.target) return;
                    break;
                 case 'black-hole-orb':
                    projectile.vx = Math.cos(angle) * 100;
                    projectile.vy = Math.sin(angle) * 100;
                    projectile.lifetime = 3000;
                    break;
                case 'plasma-ball':
                    projectile.vx = Math.cos(angle) * 120;
                    projectile.vy = Math.sin(angle) * 120;
                    projectile.lifetime = 4000;
                    projectile.explosionRadius = weapon.explosionRadius;
                    projectile.burnDamage = weapon.burnDamage;
                    projectile.burnDuration = weapon.burnDuration;
                    break;
                 case 'ricochet-blade':
                    projectile.vx = Math.cos(angle) * 250;
                    projectile.vy = Math.sin(angle) * 250;
                    projectile.angularVelocity = 10;
                    projectile.rotation = 0;
                    projectile.bouncesLeft = weapon.bounces;
                    projectile.bounceRange = 200;
                    projectile.hitEnemies = new Set();
                    break;
                case 'vortex-orb':
                    projectile.vx = Math.cos(angle) * 150;
                    projectile.vy = Math.sin(angle) * 150;
                    projectile.lifetime = 2500;
                    break;
                case 'glitch-pulse':
                    projectile.vx = Math.cos(angle) * 400;
                    projectile.vy = Math.sin(angle) * 400;
                    projectile.lifetime = 250;
                    projectile.pierce = true;
                    projectile.width = 40;
                    projectile.stunChance = weapon.stunChance;
                    projectile.stunDuration = weapon.stunDuration;
                    break;
                case 'cryo-shard':
                    player.machineGunShotCount = (player.machineGunShotCount || 0) + 1;
                    projectile.vx = Math.cos(angle) * 400;
                    projectile.vy = Math.sin(angle) * 400;
                    projectile.slowAmount = weapon.slowAmount;
                    projectile.slowDuration = weapon.slowDuration;
                    if (player.machineGunShotCount % weapon.freezeOnNthShot === 0) {
                        projectile.shouldFreeze = true;
                        projectile.freezeDuration = weapon.freezeDuration;
                    }
                    break;
                case 'bullet':
                default:
                    player.machineGunShotCount = (player.machineGunShotCount || 0) + 1;
                    let knockback = 0;
                    if(player.machineGunShotCount % 8 === 0) {
                        knockback = weapon.knockback;
                    }
                    projectile.knockback = knockback;
                    projectile.vx = Math.cos(angle) * projectileSpeed;
                    projectile.vy = Math.sin(angle) * projectileSpeed;
                    break;
            }
            projectiles.push(projectile);
        }
    }
    
    function createExplosion(x, y, radius, damage) {
        explosions.push({ x, y, radius, maxRadius: radius, duration: 200, timer: 0, damage: damage });
        sounds.explosion();
        screenShake.duration = 100;
        screenShake.magnitude = 5;
    }
    
    function resetCombo() {
        comboCount = 0;
        comboUI.textContent = '';
    }

    // --- Update Functions ---
    
    function updatePlayer(deltaTime) {
        if (player.isDashing) return;

        // Movement
        let dx = 0;
        let dy = 0;

        if (movementJoystickState.active) {
            dx = movementJoystickState.dx;
            dy = movementJoystickState.dy;
        } else {
            if (keysPressed.w || keysPressed.ArrowUp) dy -= 1;
            if (keysPressed.s || keysPressed.ArrowDown) dy += 1;
            if (keysPressed.a || keysPressed.ArrowLeft) dx -= 1;
            if (keysPressed.d || keysPressed.ArrowRight) dx += 1;
        }

        const len = Math.hypot(dx, dy);
        if (len > 0) {
            dx /= len;
            dy /= len;
            player.x += dx * player.speed * deltaTime;
            player.y += dy * player.speed * deltaTime;
        }

        player.x = Math.max(PLAYER_SIZE / 2, Math.min(CANVAS_WIDTH - PLAYER_SIZE / 2, player.x));
        player.y = Math.max(PLAYER_SIZE / 2, Math.min(CANVAS_HEIGHT - PLAYER_SIZE / 2, player.y));

        // Auto-shooting
        let closestEnemy = null;
        let minDistance = Infinity;
        enemies.forEach(enemy => {
            const distance = Math.hypot(enemy.x - player.x, enemy.y - player.y);
            if (distance < minDistance) {
                minDistance = distance;
                closestEnemy = enemy;
            }
        });

        if (closestEnemy) {
            shoot(closestEnemy.x, closestEnemy.y);
        }
        
        // Boost Timers
        if (player.speedBoostTimer > 0) {
            player.speedBoostTimer -= deltaTime * 1000;
            if(player.speedBoostTimer <= 0) player.speed = player.baseSpeed;
        }
        if (player.fireRateBoostTimer > 0) {
            player.fireRateBoostTimer -= deltaTime * 1000;
            if(player.fireRateBoostTimer <= 0) player.fireRate = player.baseFireRate;
        }
        if (player.invincibilityTimer > 0) {
            player.invincibilityTimer -= deltaTime * 1000;
        }
        if (player.magnetTimer > 0) {
            player.magnetTimer -= deltaTime * 1000;
        }
        
        // Regeneration
        if (player.regeneration > 0) {
            player.hp = Math.min(player.maxHp, player.hp + player.regeneration * deltaTime);
        }
    }
    
    function updateEnemies(deltaTime) {
        enemies.forEach(enemy => {
            if (enemy.freezeTimer > 0) {
                enemy.freezeTimer -= deltaTime * 1000;
                return;
            }
            if (enemy.stunTimer > 0) {
                enemy.stunTimer -= deltaTime * 1000;
                return;
            }

            let currentSpeed = enemy.speed;
            if (enemy.slowTimer > 0) {
                enemy.slowTimer -= deltaTime * 1000;
                currentSpeed *= enemy.slowAmount;
            }
            if (enemy.burnTimer > 0) {
                enemy.burnTimer -= deltaTime * 1000;
                takeDamage(enemy, enemy.burnDamage * deltaTime);
            }

            const dx = player.x - enemy.x;
            const dy = player.y - enemy.y;
            const dist = Math.hypot(dx, dy);
            
            if (dist > 1) {
                enemy.x += (dx / dist) * currentSpeed * deltaTime;
                enemy.y += (dy / dist) * currentSpeed * deltaTime;
            }

            if (dist < PLAYER_SIZE / 2 + enemy.size / 2) {
                takeDamage(player, enemy.damage);
                if (player.thornsDamage > 0) {
                    takeDamage(enemy, player.thornsDamage);
                }
            }
            
            // Enemy actions
            if (enemy.fireRate && performance.now() - enemy.lastActionTime > enemy.fireRate) {
                enemy.lastActionTime = performance.now();
                const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                enemyProjectiles.push({
                    x: enemy.x, y: enemy.y,
                    vx: Math.cos(angle) * enemy.projectileSpeed,
                    vy: Math.sin(angle) * enemy.projectileSpeed,
                    size: 8, lifetime: 3000, damage: enemy.damage,
                    owner: 'enemy'
                });
            }
            if (enemy.action === 'summon' && performance.now() - enemy.lastActionTime > enemy.actionRate) {
                enemy.lastActionTime = performance.now();
                sounds.summon();
                for (let i = 0; i < 2; i++) {
                    const gruntBase = ENEMY_TYPES['grunt'];
                    const finalHp = gruntBase.hp * DIFFICULTY_SETTINGS[gameDifficulty].enemyHpMult * (1 + gameTime / 120);
                    enemies.push({ 
                        ...gruntBase, 
                        x: enemy.x + (Math.random() - 0.5) * 50, 
                        y: enemy.y + (Math.random() - 0.5) * 50, 
                        hp: finalHp, 
                        maxHp: finalHp,
                        speed: gruntBase.speed * DIFFICULTY_SETTINGS[gameDifficulty].enemySpeedMult,
                        lastActionTime: 0
                    });
                }
            }
        });
    }

    function updateProjectiles(deltaTime) {
        // Player projectiles
        for (let i = projectiles.length - 1; i >= 0; i--) {
            const p = projectiles[i];
            p.x += p.vx * deltaTime;
            p.y += p.vy * deltaTime;
            p.lifetime -= deltaTime * 1000;

            if (p.type === 'missile' && p.target && p.target.hp > 0) {
                const angle = Math.atan2(p.target.y - p.y, p.target.x - p.x);
                p.vx += Math.cos(angle) * 300 * deltaTime;
                p.vy += Math.sin(angle) * 300 * deltaTime;
                const speed = Math.hypot(p.vx, p.vy);
                if (speed > 250) {
                    p.vx = (p.vx / speed) * 250;
                    p.vy = (p.vy / speed) * 250;
                }
            }
            if (p.type === 'ricochet-blade') {
                p.rotation += p.angularVelocity * deltaTime;
            }

            if (p.x < 0 || p.x > CANVAS_WIDTH || p.y < 0 || p.y > CANVAS_HEIGHT || p.lifetime <= 0) {
                if (p.type === 'missile' || p.type === 'plasma-ball' || p.explosive) {
                    createExplosion(p.x, p.y, p.explosionRadius, p.damage);
                } else if (p.type === 'black-hole-orb' || p.type === 'vortex-orb') {
                    // Logic for creating black holes/vortexes can be added here
                }
                projectiles.splice(i, 1);
                continue;
            }
            
            let hit = false;
            for (let j = enemies.length - 1; j >= 0; j--) {
                const e = enemies[j];
                const dist = Math.hypot(p.x - e.x, p.y - e.y);

                if (dist < e.size / 2 + 5) { // 5 is projectile radius
                    hit = true;
                    
                    let damage = p.damage;
                    let isCrit = false;
                    if (p.critChance && Math.random() < p.critChance) {
                        damage *= p.critMultiplier;
                        isCrit = true;
                    }

                    takeDamage(e, damage, isCrit);

                    if (p.knockback) {
                        const angle = Math.atan2(e.y - p.y, e.x - p.x);
                        e.x += Math.cos(angle) * p.knockback;
                        e.y += Math.sin(angle) * p.knockback;
                    }
                    if (p.slowAmount) {
                        e.slowTimer = p.slowDuration;
                        e.slowAmount = 1 - p.slowAmount;
                    }
                     if (p.shouldFreeze) {
                        e.freezeTimer = p.freezeDuration;
                        sounds.freeze();
                    }
                    if (p.stunChance && Math.random() < p.stunChance) {
                        e.stunTimer = p.stunDuration;
                    }

                    if (e.hp <= 0) {
                        // Enemy death
                        xpGems.push({ x: e.x, y: e.y, value: e.xp });
                        if (Math.random() < HEALTH_PACK_DROP_CHANCE) {
                           healthPacks.push({
                               x: e.x, y: e.y, size: 15,
                               healAmount: player.maxHp * 0.20
                           });
                        }
                        if (player.chainReactionChance > 0 && Math.random() < player.chainReactionChance) {
                            createExplosion(e.x, e.y, 60, 25);
                        }
                        if (e.onDeath === 'explode') {
                            createExplosion(e.x, e.y, 80, e.damage);
                        }
                        enemies.splice(j, 1);
                        comboCount++;
                        lastKillTime = performance.now();
                    }

                    if (p.type === 'missile' || p.type === 'plasma-ball' || p.explosive) {
                         createExplosion(p.x, p.y, p.explosionRadius, p.damage);
                    }
                    
                    if (!p.pierce) {
                        projectiles.splice(i, 1);
                        break;
                    }
                }
            }
        }

        // Enemy projectiles
        for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
            const p = enemyProjectiles[i];
            p.x += p.vx * deltaTime;
            p.y += p.vy * deltaTime;
            p.lifetime -= deltaTime * 1000;

            if (p.x < 0 || p.x > CANVAS_WIDTH || p.y < 0 || p.y > CANVAS_HEIGHT || p.lifetime <= 0) {
                enemyProjectiles.splice(i, 1);
                continue;
            }

            const dist = Math.hypot(p.x - player.x, p.y - player.y);
            if (dist < PLAYER_SIZE / 2 + p.size / 2) {
                takeDamage(player, p.damage);
                enemyProjectiles.splice(i, 1);
            }
        }
    }
    
    function updateXpGems(deltaTime) {
        for (let i = xpGems.length - 1; i >= 0; i--) {
            const gem = xpGems[i];
            const dist = Math.hypot(player.x - gem.x, player.y - gem.y);
            const currentPickupRadius = player.pickupRadius * (player.magnetTimer > 0 ? 2 : 1);

            if (dist < currentPickupRadius) {
                const angle = Math.atan2(player.y - gem.y, player.x - gem.x);
                gem.x += Math.cos(angle) * 300 * deltaTime;
                gem.y += Math.sin(angle) * 300 * deltaTime;

                if (dist < PLAYER_SIZE / 2) {
                    collectXP(gem.value);
                    xpGems.splice(i, 1);
                }
            }
        }
    }
    
    function updateHealthPacks(deltaTime) {
        for (let i = healthPacks.length - 1; i >= 0; i--) {
            const pack = healthPacks[i];
            const dist = Math.hypot(player.x - pack.x, player.y - pack.y);
            if (dist < PLAYER_SIZE / 2 + pack.size / 2) {
                player.hp = Math.min(player.maxHp, player.hp + pack.healAmount);
                sounds.heal();
                healthPacks.splice(i, 1);
            }
        }
    }

    function updateExplosions(deltaTime) {
        for (let i = explosions.length - 1; i >= 0; i--) {
            const exp = explosions[i];
            exp.timer += deltaTime * 1000;
            if (exp.timer >= exp.duration) {
                explosions.splice(i, 1);
                // Damage enemies at the end of explosion
                enemies.forEach(e => {
                    if (Math.hypot(exp.x - e.x, exp.y - e.y) < exp.maxRadius) {
                        takeDamage(e, exp.damage);
                    }
                });
            }
        }
    }

    function updateDamageTexts(deltaTime) {
        for (let i = damageTexts.length - 1; i >= 0; i--) {
            const dt = damageTexts[i];
            dt.timer += deltaTime * 1000;
            dt.y -= 30 * deltaTime;
            dt.alpha -= 1.5 * deltaTime;
            if (dt.timer >= 500) {
                damageTexts.splice(i, 1);
            }
        }
    }
    
    // --- Draw Functions ---

    function drawPlayer() {
        ctx.save();
        ctx.translate(player.x, player.y);
        
        if (player.invincibilityTimer > 0 && Math.floor(player.invincibilityTimer / 100) % 2 === 0) {
            ctx.globalAlpha = 0.5;
        }

        // Body
        ctx.fillStyle = '#00ffff';
        ctx.shadowColor = '#00ffff';
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.rect(-PLAYER_SIZE / 2, -PLAYER_SIZE / 2, PLAYER_SIZE, PLAYER_SIZE);
        ctx.fill();

        // Shields
        if (player.shields > 0) {
            const orbitRadius = 40;
            const shieldSize = 8;
            for (let i = 0; i < player.shields; i++) {
                const angle = (gameTime * 1.5) + (i * (2 * Math.PI / player.shields));
                const sx = Math.cos(angle) * orbitRadius;
                const sy = Math.sin(angle) * orbitRadius;
                ctx.fillStyle = '#f0f';
                ctx.shadowColor = '#f0f';
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.rect(sx - shieldSize / 2, sy - shieldSize / 2, shieldSize, shieldSize);
                ctx.fill();
            }
        }
        
        ctx.restore();
    }
    
    function drawEnemies() {
        enemies.forEach(e => {
            ctx.save();
            ctx.translate(e.x, e.y);
            
            if(e.freezeTimer > 0) {
                ctx.fillStyle = '#67e8f9';
                ctx.shadowColor = '#06b6d4';
            } else if (e.burnTimer > 0) {
                ctx.fillStyle = '#fb923c';
                ctx.shadowColor = '#f97316';
            } else {
                ctx.fillStyle = e.color;
                ctx.shadowColor = e.color;
            }

            ctx.shadowBlur = 10;

            if (e.shape === 'triangle') {
                ctx.beginPath();
                ctx.moveTo(0, -e.size / 2);
                ctx.lineTo(-e.size / 2, e.size / 2);
                ctx.lineTo(e.size / 2, e.size / 2);
                ctx.closePath();
                ctx.fill();
            } else { // square
                ctx.fillRect(-e.size / 2, -e.size / 2, e.size, e.size);
            }
            
            // Health bar
            if (e.hp < e.maxHp) {
                ctx.fillStyle = '#555';
                ctx.fillRect(-e.size / 2, e.size / 2 + 5, e.size, 5);
                ctx.fillStyle = '#f00';
                ctx.fillRect(-e.size / 2, e.size / 2 + 5, e.size * (e.hp / e.maxHp), 5);
            }
            
            ctx.restore();
        });
    }
    
    function drawProjectiles() {
        // Player projectiles
        projectiles.forEach(p => {
            ctx.save();
            ctx.translate(p.x, p.y);
            ctx.fillStyle = '#fff';
            ctx.shadowColor = '#fff';
            ctx.shadowBlur = 10;
            
            switch(p.type) {
                case 'laser':
                case 'arrow':
                    ctx.fillStyle = '#f0f'; ctx.shadowColor = '#f0f';
                    ctx.fillRect(-15, -2, 30, 4);
                    break;
                case 'missile':
                    ctx.fillStyle = '#ff9900'; ctx.shadowColor = '#ff9900';
                    ctx.beginPath(); ctx.arc(0, 0, 6, 0, 2 * Math.PI); ctx.fill();
                    break;
                case 'ricochet-blade':
                    ctx.rotate(p.rotation);
                    ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.arc(0, 0, 8, 0, Math.PI * 1.5); ctx.stroke();
                    break;
                default:
                    ctx.beginPath(); ctx.arc(0, 0, 4, 0, 2 * Math.PI); ctx.fill();
            }
            
            ctx.restore();
        });
        // Enemy projectiles
        enemyProjectiles.forEach(p => {
            ctx.save();
            ctx.fillStyle = '#ff5555';
            ctx.shadowColor = '#ff5555';
            ctx.shadowBlur = 8;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size / 2, 0, 2 * Math.PI);
            ctx.fill();
            ctx.restore();
        });
    }
    
    function drawXpGems() {
        xpGems.forEach(gem => {
            ctx.save();
            ctx.fillStyle = '#00ffff';
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.moveTo(gem.x, gem.y - 5);
            ctx.lineTo(gem.x - 5, gem.y);
            ctx.lineTo(gem.x, gem.y + 5);
            ctx.lineTo(gem.x + 5, gem.y);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        });
    }

    function drawHealthPacks() {
        healthPacks.forEach(pack => {
            ctx.save();
            ctx.translate(pack.x, pack.y);
            ctx.shadowColor = '#4ade80';
            ctx.shadowBlur = 15;
            ctx.fillStyle = '#166534';
            ctx.fillRect(-pack.size / 2, -pack.size / 2, pack.size, pack.size);
            ctx.fillStyle = '#86efac';
            ctx.fillRect(-pack.size * 0.4, -pack.size * 0.15, pack.size * 0.8, pack.size * 0.3);
            ctx.fillRect(-pack.size * 0.15, -pack.size * 0.4, pack.size * 0.3, pack.size * 0.8);
            ctx.restore();
        });
    }

    function drawExplosions() {
        explosions.forEach(exp => {
            const progress = exp.timer / exp.duration;
            const currentRadius = exp.maxRadius * progress;
            ctx.save();
            ctx.globalAlpha = 1 - progress;
            ctx.beginPath();
            ctx.arc(exp.x, exp.y, currentRadius, 0, 2 * Math.PI);
            ctx.fillStyle = `rgba(255, 255, 150, ${1 - progress})`;
            ctx.shadowColor = 'white';
            ctx.shadowBlur = 20;
            ctx.fill();
            ctx.restore();
        });
    }
    
    function drawDamageTexts() {
        damageTexts.forEach(dt => {
            ctx.save();
            ctx.fillStyle = `rgba(${dt.color}, ${dt.alpha})`;
            ctx.font = dt.color === '255, 255, 0' ? 'bold 18px Orbitron' : '16px Orbitron';
            ctx.textAlign = 'center';
            ctx.fillText(dt.text, dt.x, dt.y);
            ctx.restore();
        });
    }

    function drawUI() {
        hpBar.style.width = `${(player.hp / player.maxHp) * 100}%`;
        xpBar.style.width = `${(player.xp / player.xpToNextLevel) * 100}%`;
        timerUI.textContent = formatTime(gameTime);
        comboUI.textContent = comboCount > 1 ? `x${comboCount} COMBO` : '';
        
        const rank = getRank(gameTime);
        currentRankUI.textContent = rank.name;
        currentRankUI.style.color = rank.color;
        currentRankUI.style.textShadow = `0 0 8px ${rank.color}`;
    }
    
    // --- Game Loop ---
    
    function gameLoop(timestamp) {
        if (isPaused || gameState !== 'playing') return;
        
        const deltaTime = (timestamp - lastTime) / 1000;
        lastTime = timestamp;
        gameTime += deltaTime;

        update(deltaTime);
        draw();

        animationFrameId = requestAnimationFrame(gameLoop);
    }
    
    function update(deltaTime) {
        updatePlayer(deltaTime);
        updateEnemies(deltaTime);
        updateProjectiles(deltaTime);
        updateXpGems(deltaTime);
        updateHealthPacks(deltaTime);
        updateExplosions(deltaTime);
        updateDamageTexts(deltaTime);
        
        if (performance.now() - lastKillTime > COMBO_TIMEOUT) {
            resetCombo();
        }
        
        lastSpawnTime += deltaTime * 1000;
        if (lastSpawnTime > spawnInterval) {
            lastSpawnTime = 0;
            const waveSize = 1 + Math.floor(gameTime / 10);
            for (let i = 0; i < waveSize; i++) {
                spawnEnemy();
            }
            spawnInterval = Math.max(200, spawnInterval * 0.99);
        }

        if (player.hp <= 0) {
            gameOver();
        }
    }

    function draw() {
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        
        const shakeX = (Math.random() - 0.5) * screenShake.magnitude * (screenShake.duration > 0 ? 1 : 0);
        const shakeY = (Math.random() - 0.5) * screenShake.magnitude * (screenShake.duration > 0 ? 1 : 0);
        ctx.save();
        ctx.translate(shakeX, shakeY);
        
        if(screenShake.duration > 0) screenShake.duration -= 16;
        else screenShake.magnitude = 0;

        drawXpGems();
        drawHealthPacks();
        drawProjectiles();
        drawEnemies();
        drawPlayer();
        drawExplosions();
        drawDamageTexts();
        
        ctx.restore();
        drawUI();
    }
    
    // --- Game State Management ---

    function startGame() {
        const difficulty = selectedDifficulty;
        const weapon = selectedWeapon;

        if (!difficulty || !weapon) {
             console.error("Attempted to start game with invalid selections.");
             return;
        }

        gameDifficulty = difficulty;
        player = createInitialPlayer(difficulty, weapon);
        enemies = [];
        projectiles = [];
        enemyProjectiles = [];
        xpGems = [];
        healthPacks = [];
        explosions = [];
        damageTexts = [];
        
        gameTime = 0;
        lastSpawnTime = 0;
        spawnInterval = 1500 * DIFFICULTY_SETTINGS[gameDifficulty].spawnRateMult;
        bossSpawned = false;
        resetCombo();
        
        startScreen.classList.add('hidden');
        gameOverScreen.classList.add('hidden');
        pauseButton.classList.remove('hidden');

        gameState = 'playing';
        isPaused = false;
        lastTime = performance.now();
        animationFrameId = requestAnimationFrame(gameLoop);
    }

    function gameOver() {
        gameState = 'gameover';
        cancelAnimationFrame(animationFrameId);
        
        if (gameTime > highScore) {
            highScore = gameTime;
            localStorage.setItem('neonSurvivorHighScore', highScore);
            updateHighscoreUI();
        }
        
        gameOverTimeUI.textContent = `생존 시간: ${formatTime(gameTime)}`;
        gameOverRankUI.textContent = `달성 랭크: ${getRank(gameTime).name}`;
        gameOverHighscoreUI.textContent = `최고 기록: ${formatTime(highScore)}`;
        gameOverScreen.classList.remove('hidden');
        pauseButton.classList.add('hidden');
    }
    
    function resetGame() {
        startScreen.classList.remove('hidden');
        gameOverScreen.classList.add('hidden');
        pauseScreen.classList.add('hidden');
        levelUpScreen.classList.add('hidden');
        pauseButton.classList.add('hidden');
        gameState = 'start';
    }

    function updateHighscoreUI() {
        const formattedTime = formatTime(highScore);
        highscoreUI.textContent = `최고기록: ${formattedTime}`;
        startScreenHighscoreUI.textContent = `최고 기록: ${formattedTime}`;
    }
    
    // --- Event Listeners ---
    
    function setupEventListeners() {
        difficultySelection.addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON' && e.target.dataset.difficulty) {
                selectedDifficulty = e.target.dataset.difficulty;
                Array.from(difficultySelection.children).forEach(child => child.classList.remove('selected'));
                e.target.classList.add('selected');
                updateStartButtonState();
            }
        });
        
        weaponSelection.addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON' && e.target.dataset.weapon) {
                selectedWeapon = e.target.dataset.weapon;
                Array.from(weaponSelection.children).forEach(child => child.classList.remove('selected'));
                e.target.classList.add('selected');
                updateStartButtonState();
            }
        });

        startButton.onclick = startGame;
        restartButton.onclick = resetGame;
        restartPauseButton.onclick = () => {
             pauseScreen.classList.add('hidden');
             startGame();
        }
        resumeButton.onclick = togglePause;
        pauseButton.onclick = togglePause;
        quitButton.onclick = () => {
            isPaused = false;
            resetGame();
        }

        window.addEventListener('keydown', (e) => {
            keysPressed[e.key.toLowerCase()] = true;
            if (e.key === 'Escape') togglePause();
        });
        window.addEventListener('keyup', (e) => {
            keysPressed[e.key.toLowerCase()] = false;
        });

        // Touch controls for joystick
        let isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        if (isMobile) {
            gameWrapper.addEventListener('touchstart', handleTouchStart, { passive: false });
            gameWrapper.addEventListener('touchmove', handleTouchMove, { passive: false });
            gameWrapper.addEventListener('touchend', handleTouchEnd, { passive: false });
            gameWrapper.addEventListener('touchcancel', handleTouchEnd, { passive: false });
        }
    }
    
    function handleTouchStart(e) {
        e.preventDefault();
        if (movementJoystickState.active) return;
        
        const touch = e.changedTouches[0];
        movementJoystickState.touchId = touch.identifier;
        movementJoystickState.active = true;
        movementJoystickState.x = touch.clientX;
        movementJoystickState.y = touch.clientY;

        const rect = gameWrapper.getBoundingClientRect();
        movementJoystickUI.style.left = `${touch.clientX - rect.left - JOYSTICK_BASE_RADIUS}px`;
        movementJoystickUI.style.top = `${touch.clientY - rect.top - JOYSTICK_BASE_RADIUS}px`;
        movementJoystickUI.classList.remove('hidden');
        movementJoystickUI.classList.add('active');
    }

    function handleTouchMove(e) {
        e.preventDefault();
        if (!movementJoystickState.active) return;
        
        let touch = null;
        for (let t of e.changedTouches) {
            if (t.identifier === movementJoystickState.touchId) {
                touch = t;
                break;
            }
        }
        if (!touch) return;
        
        let dx = touch.clientX - movementJoystickState.x;
        let dy = touch.clientY - movementJoystickState.y;
        const dist = Math.hypot(dx, dy);

        if (dist > JOYSTICK_MAX_OFFSET) {
            dx = (dx / dist) * JOYSTICK_MAX_OFFSET;
            dy = (dy / dist) * JOYSTICK_MAX_OFFSET;
        }
        
        movementJoystickHandle.style.transform = `translate(${dx}px, ${dy}px)`;

        const moveDist = Math.hypot(dx, dy);
        if (moveDist > JOYSTICK_DEAD_ZONE) {
            movementJoystickState.dx = dx / JOYSTICK_MAX_OFFSET;
            movementJoystickState.dy = dy / JOYSTICK_MAX_OFFSET;
        } else {
            movementJoystickState.dx = 0;
            movementJoystickState.dy = 0;
        }
    }

    function handleTouchEnd(e) {
        e.preventDefault();
        if (!movementJoystickState.active) return;

        let touchEnded = false;
        for (let t of e.changedTouches) {
            if (t.identifier === movementJoystickState.touchId) {
                touchEnded = true;
                break;
            }
        }

        if (touchEnded) {
            movementJoystickState.active = false;
            movementJoystickState.dx = 0;
            movementJoystickState.dy = 0;
            movementJoystickState.touchId = null;

            movementJoystickUI.classList.add('hidden');
            movementJoystickUI.classList.remove('active');
            movementJoystickHandle.style.transform = 'translate(0, 0)';
        }
    }
    
    // --- Initialization ---
    function init() {
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;
        updateHighscoreUI();
        
        selectedDifficulty = difficultySelection.querySelector('.selected')?.dataset.difficulty;
        selectedWeapon = weaponSelection.querySelector('.selected')?.dataset.weapon;
        
        setupEventListeners();
        updateStartButtonState();
    }

    init();
});
</script>
</body>
</html>

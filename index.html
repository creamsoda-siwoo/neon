
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>네온 서바이버</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      font-family: 'Orbitron', sans-serif;
      overflow: hidden;
      background-color: #0d0221;
      color: white;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      margin: 0;
      padding: 1rem;
      touch-action: none;
    }
    .game-container {
      background: #0a0a1f;
      border: 2px solid #00ffff;
      box-shadow: 0 0 20px #00ffff, inset 0 0 20px #00ffff;
      width: 90vmin;
      aspect-ratio: 4 / 3;
      touch-action: none;
    }
    #game-canvas {
      background-color: #0d0221;
      cursor: none;
      width: 100%;
      height: 100%;
      display: block;
    }
    .text-glow {
      color: #fff;
      text-shadow: 0 0 7px #fff, 0 0 10px #fff, 0 0 21px #ff00ff, 0 0 42px #ff00ff;
    }
    .button-retro {
      background-color: transparent;
      border: 2px solid #fff;
      color: #fff;
      padding: 0.75rem 1.5rem;
      text-transform: uppercase;
      letter-spacing: 2px;
      transition: all 0.2s ease-in-out;
      text-shadow: 0 0 8px #ff00ff;
      cursor: pointer;
    }
    .button-retro:hover:not(:disabled) {
      background-color: #fff;
      color: #0d0221;
      box-shadow: 0 0 20px #fff, 0 0 30px #ff00ff;
    }
    .button-retro:disabled {
        cursor: not-allowed;
        opacity: 0.5;
    }
    .selection-button {
        border-width: 2px;
        border-color: #fff;
        background-color: transparent;
        padding: 0.5rem;
        height: 100%;
        font-size: 0.875rem;
    }
    .selection-button.selected {
        background-color: #00ffff;
        color: #0d0221;
        box-shadow: 0 0 20px #00ffff;
    }
    .upgrade-card {
      border: 2px solid #00ffff;
      background: rgba(13, 2, 33, 0.8);
      transition: all 0.2s ease-in-out;
      cursor: pointer;
    }
    .upgrade-card:hover {
      background: rgba(0, 255, 255, 0.2);
      box-shadow: 0 0 15px #00ffff;
      transform: translateY(-5px);
    }
    .overlay {
        position: absolute;
        inset: 0;
        background-color: rgba(0,0,0,0.85);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
        z-index: 10;
        padding: 1rem;
    }
    .hidden {
        display: none;
    }
    #start-button {
        padding: 1rem 2rem;
        font-size: 1.25rem;
        font-weight: bold;
    }
    @keyframes pulse-glow {
        0% {
            transform: scale(1);
            box-shadow: 0 0 15px #00ffff, 0 0 25px #ff00ff;
        }
        50% {
            transform: scale(1.08);
            box-shadow: 0 0 30px #00ffff, 0 0 50px #ff00ff;
        }
        100% {
            transform: scale(1);
            box-shadow: 0 0 15px #00ffff, 0 0 25px #ff00ff;
        }
    }

    #start-button:not(:disabled) {
        border-color: #00ffff;
        color: #00ffff;
        text-shadow: 0 0 8px #00ffff;
        animation: pulse-glow 2s infinite ease-in-out;
    }
    .joystick {
        position: absolute;
        width: 120px;
        height: 120px;
        pointer-events: none;
    }
    .joystick-base {
        position: absolute;
        width: 100%;
        height: 100%;
        border-radius: 50%;
        background-color: rgba(0, 255, 255, 0.1);
        border: 2px solid rgba(0, 255, 255, 0.4);
        box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        transition: transform 0.1s ease-out, background-color 0.1s, border-color 0.1s;
    }
    .joystick-handle {
        position: absolute;
        width: 60px;
        height: 60px;
        top: 30px;
        left: 30px;
        border-radius: 50%;
        background-color: rgba(0, 255, 255, 0.3);
        border: 2px solid rgba(0, 255, 255, 0.8);
        box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
        transition: transform 0.05s linear, background-color 0.1s, border-color 0.1s;
    }
    .joystick.active .joystick-base {
        transform: scale(1.1);
        background-color: rgba(0, 255, 255, 0.2);
        border-color: rgba(0, 255, 255, 0.8);
    }
    .joystick.active .joystick-handle {
        background-color: rgba(0, 255, 255, 0.6);
        border-color: #fff;
    }
    .stat {
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }
    .stat-label {
        width: 60px;
        text-align: right;
        font-size: 0.8rem;
        color: #a7a7a7;
        flex-shrink: 0;
    }
    .stat-bar-bg {
        flex-grow: 1;
        height: 10px;
        background-color: rgba(0, 50, 50, 0.5);
        border: 1px solid #00ffff;
        border-radius: 5px;
        padding: 1px;
    }
    .stat-bar-fill {
        height: 100%;
        background: linear-gradient(90deg, #ff00ff, #00ffff);
        border-radius: 3px;
        box-shadow: 0 0 5px #00ffff;
        transition: width 0.3s ease-out;
    }
  </style>
</head>
<body>

  <main class="flex flex-col items-center">
    <div class="flex justify-between w-full mb-2 px-2 text-glow" style="max-width: 90vmin;">
        <div class="flex gap-4 items-center">
            <div id="level-ui" class="text-xl">레벨: 1</div>
            <div id="current-rank-ui" class="text-lg"></div>
        </div>
        <div class="flex flex-col items-center">
            <div id="timer-ui" class="text-2xl font-bold">00:00</div>
            <div id="combo-ui" class="text-xl font-bold text-yellow-400 h-6" style="text-shadow: 0 0 8px #facc15;"></div>
        </div>
        <div id="highscore-ui" class="text-xl text-right">최고기록: 00:00</div>
    </div>
    
    <div class="w-full h-8 mb-2 flex flex-col justify-around" style="max-width: 90vmin;">
        <div class="w-full bg-gray-700 h-3 rounded-full overflow-hidden border border-red-500">
            <div id="hp-bar" class="bg-red-500 h-full" style="width: 100%"></div>
        </div>
        <div class="w-full bg-gray-700 h-3 rounded-full overflow-hidden border border-cyan-400">
            <div id="xp-bar" class="bg-cyan-400 h-full" style="width: 0%"></div>
        </div>
    </div>

    <div id="game-wrapper" class="relative rounded-lg overflow-hidden game-container">
      <canvas id="game-canvas" width="800" height="600"></canvas>
      <button id="pause-button" class="absolute top-2 right-2 text-2xl w-12 h-12 button-retro hidden items-center justify-center" style="padding: 0;">||</button>
      
      <div id="movement-joystick" class="joystick hidden">
        <div class="joystick-base"></div>
        <div class="joystick-handle"></div>
      </div>
      <div id="attack-joystick" class="joystick hidden">
        <div class="joystick-base"></div>
        <div class="joystick-handle"></div>
      </div>
      
      <div id="start-screen" class="overlay">
          <div class="absolute top-4 left-4 text-xs text-gray-500">제작자: 한국인이라면</div>
          <h1 class="text-5xl md:text-6xl font-bold mb-4 text-glow">네온 서바이버</h1>
          <div id="start-screen-highscore" class="text-xl mb-8 text-glow"></div>
          
          <div class="w-full max-w-2xl">
            <h2 class="text-xl mb-2 text-glow">난이도 선택</h2>
            <div id="difficulty-selection" class="grid grid-cols-3 gap-2 mb-4">
                <button class="button-retro selection-button" data-difficulty="쉬움">쉬움</button>
                <button class="button-retro selection-button selected" data-difficulty="보통">보통</button>
                <button class="button-retro selection-button" data-difficulty="어려움">어려움</button>
            </div>
          </div>

          <div class="w-full max-w-2xl mt-4">
              <h2 class="text-xl mb-2 text-glow">무기 선택</h2>
              <div id="weapon-selection" class="grid grid-cols-3 gap-2 mb-2">
                  <button class="button-retro selection-button" data-weapon="machine-gun">기관총</button>
                  <button class="button-retro selection-button" data-weapon="missile">유도 미사일</button>
                  <button class="button-retro selection-button" data-weapon="bomb">폭탄</button>
                  <button class="button-retro selection-button" data-weapon="shotgun">샷건</button>
                  <button class="button-retro selection-button" data-weapon="laser">레이저</button>
                  <button class="button-retro selection-button" data-weapon="bow">활</button>
                  <button class="button-retro selection-button" data-weapon="chain-lightning">연쇄 번개</button>
                  <button class="button-retro selection-button" data-weapon="black-hole-generator">블랙홀</button>
                  <button class="button-retro selection-button" data-weapon="plasma-cannon">플라즈마</button>
                  <button class="button-retro selection-button" data-weapon="ricochet-blade">리코</button>
                  <button class="button-retro selection-button" data-weapon="vortex-cannon">볼텍스 캐논</button>
                  <button class="button-retro selection-button" data-weapon="glitch-pulser">글리치 펄서</button>
              </div>
          </div>

          <button id="start-button" class="button-retro mt-8" disabled>게임 시작</button>
      </div>

      <div id="pause-screen" class="overlay hidden">
          <h2 class="text-6xl font-bold mb-8 text-glow">일시정지</h2>
          <div class="flex flex-col gap-4 w-64">
              <button id="resume-button" class="button-retro">계속하기</button>
              <button id="restart-pause-button" class="button-retro">다시 시작</button>
              <button id="quit-button" class="button-retro">그만하기</button>
          </div>
      </div>

      <div id="levelup-screen" class="overlay hidden">
          <h2 class="text-5xl font-bold mb-8 text-glow">레벨 업!</h2>
          <div id="levelup-options" class="grid grid-cols-1 md:grid-cols-3 gap-6">
              <!-- Upgrade cards will be injected here -->
          </div>
      </div>

      <div id="gameover-screen" class="overlay hidden">
          <h2 class="text-6xl font-bold mb-4 text-glow">게임 오버</h2>
          <p id="gameover-time" class="text-3xl mb-2">생존 시간: 00:00</p>
          <p id="gameover-rank" class="text-2xl mb-6"></p>
          <p id="gameover-highscore" class="text-xl mb-8">최고 기록: 00:00</p>
          <button id="restart-button" class="button-retro">새로 시작</button>
      </div>
    </div>
  </main>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- DOM Elements ---
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    const gameWrapper = document.getElementById('game-wrapper');
    const startScreen = document.getElementById('start-screen');
    const pauseScreen = document.getElementById('pause-screen');
    const levelUpScreen = document.getElementById('levelup-screen');
    const gameOverScreen = document.getElementById('gameover-screen');
    const startButton = document.getElementById('start-button');
    const restartButton = document.getElementById('restart-button');
    const pauseButton = document.getElementById('pause-button');
    const levelUpOptionsContainer = document.getElementById('levelup-options');
    const weaponSelection = document.getElementById('weapon-selection');
    const difficultySelection = document.getElementById('difficulty-selection');
    const resumeButton = document.getElementById('resume-button');
    const restartPauseButton = document.getElementById('restart-pause-button');
    const quitButton = document.getElementById('quit-button');

    // Joystick UI
    const movementJoystickUI = document.getElementById('movement-joystick');
    const movementJoystickHandle = movementJoystickUI.querySelector('.joystick-handle');
    const attackJoystickUI = document.getElementById('attack-joystick');
    const attackJoystickHandle = attackJoystickUI.querySelector('.joystick-handle');
    
    // UI Elements
    const levelUI = document.getElementById('level-ui');
    const timerUI = document.getElementById('timer-ui');
    const comboUI = document.getElementById('combo-ui');
    const highscoreUI = document.getElementById('highscore-ui');
    const hpBar = document.getElementById('hp-bar');
    const xpBar = document.getElementById('xp-bar');
    const gameOverTimeUI = document.getElementById('gameover-time');
    const gameOverRankUI = document.getElementById('gameover-rank');
    const gameOverHighscoreUI = document.getElementById('gameover-highscore');
    const startScreenHighscoreUI = document.getElementById('start-screen-highscore');
    const currentRankUI = document.getElementById('current-rank-ui');

    // --- Game Constants ---
    const CANVAS_WIDTH = 800;
    const CANVAS_HEIGHT = 600;
    const PLAYER_SIZE = 20;
    const COMBO_TIMEOUT = 2500;

    // --- Ranking System ---
    const RANKS = [
        { name: '네온 초심자', threshold: 0, color: '#9ca3af' },
        { name: '그리드 러너', threshold: 60, color: '#6ee7b7' },
        { name: '서킷 브레이커', threshold: 120, color: '#60a5fa' },
        { name: '데이터 스트리머', threshold: 180, color: '#c084fc' },
        { name: '사이버 검투사', threshold: 240, color: '#f87171' },
        { name: '신스웨이브 파수꾼', threshold: 300, color: '#facc15' },
        { name: '디지털 오버로드', threshold: 420, color: '#f472b6' },
        { name: '코드 아크마스터', threshold: 600, color: '#00ffff' },
        { name: '매트릭스 군주', threshold: 900, color: '#ffffff' }
    ];

    function getRank(seconds) {
        let currentRank = RANKS[0];
        for (const rank of RANKS) {
            if (seconds >= rank.threshold) {
                currentRank = rank;
            } else {
                break;
            }
        }
        return currentRank;
    }
    
    // --- Enemy Types ---
    const ENEMY_TYPES = {
        'grunt': { size: 15, hp: 10, speed: 70, color: '#ff4d4d', xp: 1, shape: 'square', damage: 5 },
        'tank': { size: 30, hp: 50, speed: 40, color: '#ff8c66', xp: 5, shape: 'square', damage: 15 },
        'shooter': { size: 18, hp: 15, speed: 60, color: '#fcf003', xp: 2, shape: 'triangle', damage: 10, fireRate: 2000, projectileSpeed: 150 },
        'bomber': { size: 20, hp: 20, speed: 80, color: '#ff99cc', xp: 3, shape: 'square', damage: 20, onDeath: 'explode' },
        'summoner': { size: 25, hp: 40, speed: 50, color: '#cc99ff', xp: 8, shape: 'triangle', damage: 5, actionRate: 5000, action: 'summon' },
        'boss': { size: 50, hp: 500, speed: 60, color: '#ff0000', xp: 50, shape: 'square', damage: 25, fireRate: 1000, projectileSpeed: 200 },
    };


    // --- Game Configs ---
    const DIFFICULTY_SETTINGS = {
        '쉬움': { hp: 120, enemyHpMult: 0.7, enemySpeedMult: 0.8, spawnRateMult: 1.2 },
        '보통': { hp: 100, enemyHpMult: 1.0, enemySpeedMult: 1.0, spawnRateMult: 1.0 },
        '어려움': { hp: 80, enemyHpMult: 1.5, enemySpeedMult: 1.2, spawnRateMult: 0.8 },
    };
    const WEAPON_SETTINGS = {
        'machine-gun': { fireRate: 400, damage: 12, projectileType: 'bullet', name: '기관총', knockback: 20, description: '가장 균형잡힌 무기. 8발마다 강력한 넉백탄 발사!' },
        'missile': { fireRate: 1000, damage: 40, projectileType: 'missile', name: '유도 미사일', explosionRadius: 70, description: '가장 가까운 적을 추적하며 넓은 범위에 폭발 피해를 줍니다.' },
        'bomb': { fireRate: 800, damage: 25, projectileType: 'bomb', name: '폭탄', shrapnelCount: 5, description: '포물선으로 날아가 폭발하며 5개의 파편을 흩뿌립니다.' },
        'shotgun': { fireRate: 700, damage: 10, projectileType: 'pellet', name: '샷건', pellets: 5, spread: 0.5, knockback: 5, description: '근거리의 적들을 밀쳐내며 강력한 피해를 줍니다.' },
        'laser': { fireRate: 1200, damage: 45, projectileType: 'laser', name: '레이저', slowAmount: 0.5, slowDuration: 1000, description: '적을 관통하며 1초간 이동 속도를 50% 감소시킵니다.' },
        'bow': { fireRate: 600, damage: 25, projectileType: 'arrow', name: '활', critChance: 0.15, critMultiplier: 2, description: '적을 관통하며 15% 확률로 2배의 치명타 피해를 입힙니다.' },
        'chain-lightning': { fireRate: 800, damage: 30, projectileType: 'lightning', name: '연쇄 번개', bounces: 4, description: '적들 사이를 4번 튕기는 번개를 발사합니다.' },
        'black-hole-generator': { fireRate: 2000, damage: 0, projectileType: 'black-hole-orb', name: '블랙홀 생성기', description: '적을 끌어당기고 지속 피해를 주는 소형 블랙홀을 발사합니다.' },
        'plasma-cannon': { fireRate: 1800, damage: 50, projectileType: 'plasma-ball', name: '플라즈마 캐논', explosionRadius: 80, burnDamage: 10, burnDuration: 3000, description: '느리지만 강력한 플라즈마 구체를 발사합니다. 구체는 폭발하며 3초간 화상 피해를 입힙니다.' },
        'ricochet-blade': { fireRate: 750, damage: 20, projectileType: 'ricochet-blade', name: '리코셰 블레이드', bounces: 3, description: '적에게 튕기는 회전 칼날을 발사하여 최대 4명의 적을 공격합니다.' },
        'vortex-cannon': { fireRate: 2200, damage: 10, projectileType: 'vortex-orb', name: '볼텍스 캐논', description: '적을 끌어당기며 지속 피해를 주는 소용돌이를 생성하는 구체를 발사합니다.' },
        'glitch-pulser': { fireRate: 900, damage: 15, projectileType: 'glitch-pulse', name: '글리치 펄서', stunChance: 0.2, stunDuration: 1000, description: '짧은 거리의 적들을 관통하는 에너지 파동을 방출합니다. 피격된 적은 확률적으로 잠시 기절합니다.' }
    };
   
    // --- Audio ---
    let audioContext;
    try { audioContext = new (window.AudioContext || window.webkitAudioContext)(); }
    catch (e) { console.error("Web Audio API is not supported in this browser"); }

    function playSound(type, frequency, duration, volume = 0.3) {
        if (!audioContext) return;
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        oscillator.type = type;
        oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
        gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.00001, audioContext.currentTime + duration);
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + duration);
    }
    const sounds = {
        hit: () => playSound('square', 150, 0.1, 0.2),
        shoot: () => playSound('triangle', 440, 0.05, 0.1),
        xp: () => playSound('sine', 600, 0.1, 0.2),
        levelUp: () => playSound('sine', 880, 0.4),
        heal: () => playSound('sine', 700, 0.3),
        dash: () => playSound('sine', 300, 0.2, 0.4),
        explosion: () => playSound('sine', 50, 0.3, 0.5),
        nuke: () => playSound('sine', 100, 1.0, 0.8),
        powerup: () => playSound('sine', 900, 0.2),
        freeze: () => playSound('sawtooth', 200, 0.5, 0.4),
        shieldUp: () => playSound('sine', 1000, 0.2, 0.5),
        shieldDown: () => playSound('square', 100, 0.2, 0.5),
        blackHole: () => playSound('noise', 100, 2, 0.4),
        summon: () => playSound('sine', 500, 0.3, 0.2),
    };
    
    // --- Game State ---
    let gameState = 'start';
    let isPaused = false;
    let selectedDifficulty, selectedWeapon;
    let player, enemies, projectiles, enemyProjectiles, xpGems, healthPacks, nukes, explosions;
    let orbitalShields, speedBoosts, fireRateBoosts, freezeBombs, invincibilityShields, blackHoleItems;
    let drones, explosiveBarrels, blackHoles, vortexes;
    let holographicDecoys, decoys;
    let magnets, xpBombs;
    let damageTexts;
    let timer, gameTime, lastTime, animationFrameId;
    let lastSpawnTime, spawnInterval;
    let bossSpawned, enemiesFrozen, enemiesFrozenTimer;
    let mousePos = { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2 };
    let keysPressed = {};
    let highScore = Number(localStorage.getItem('neonSurvivorHighScore') || 0);
    let comboCount, lastKillTime;
    let activeTouchCount = 0;

    // Joystick State
    const JOYSTICK_BASE_RADIUS = 60;
    const JOYSTICK_MAX_OFFSET = JOYSTICK_BASE_RADIUS - 30;
    const JOYSTICK_DEAD_ZONE = 10;
    let movementJoystickState = { active: false, x: 0, y: 0, dx: 0, dy: 0, touchId: null, startTime: 0, startX: 0, startY: 0 };
    let attackJoystickState = { active: false, x: 0, y: 0, dx: 0, dy: 0, touchId: null };


    // --- Upgrades ---
    const UPGRADES = [
        { id: 'firerate', title: "연사력 강화", description: "공격 속도 20% 증가", apply: p => { p.baseFireRate *= 0.8; p.fireRate = p.baseFireRate;} },
        { id: 'damage', title: "강화 탄환", description: "공격력 25% 증가", apply: p => p.projectileDamage *= 1.25 },
        { id: 'multishot', title: "멀티샷", description: "발사체 수 +1", apply: p => p.projectiles++ },
        { id: 'hp', title: "나노 수리봇", description: "최대 체력 20 증가 및 모두 회복", apply: p => { p.maxHp += 20; p.hp = p.maxHp; } },
        { id: 'speed', title: "고속 추진기", description: "이동 속도 10% 증가", apply: p => { p.baseSpeed *= 1.1; p.speed = p.baseSpeed; } },
        { id: 'shield', title: '궤도 방패', description: '주위를 도는 방패 추가', apply: p => p.shields++ },
        { id: 'explosive', title: '폭발탄', description: '탄환이 명중 시 폭발합니다', apply: p => p.explosiveProjectiles = true },
        { id: 'magnet', title: '경험치 자석', description: '경험치 획득 범위 50% 증가', apply: p => p.pickupRadius *= 1.5 },
        { id: 'drone', title: '컴패니언 드론', description: '플레이어를 돕는 공격 드론을 추가합니다.', apply: p => p.drones = (p.drones || 0) + 1 },
        { id: 'regeneration', title: '나노 재생 갑옷', description: '초당 최대 체력의 1%를 회복합니다.', apply: p => p.regeneration = (p.regeneration || 0) + (p.maxHp * 0.01) },
        { id: 'thorns', title: '에너지 가시', description: '플레이어에게 닿는 적에게 20의 피해를 입힙니다.', apply: p => p.thornsDamage = (p.thornsDamage || 0) + 20 },
        { id: 'chain-reaction', title: '연쇄 폭발', description: '적이 죽을 때 15% 확률로 폭발하여 주변에 피해를 줍니다.', apply: p => p.chainReactionChance = (p.chainReactionChance || 0) + 0.15 }
    ];
    let availableUpgrades = [...UPGRADES];
    
    function createInitialPlayer(difficulty, weapon) {
        const difficultySettings = DIFFICULTY_SETTINGS[difficulty];
        const weaponSettings = WEAPON_SETTINGS[weapon];
        
        return {
            x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2,
            hp: difficultySettings.hp, maxHp: difficultySettings.hp,
            xp: 0, level: 1, xpToNextLevel: 10,
            weaponType: weapon,
            fireRate: weaponSettings.fireRate, baseFireRate: weaponSettings.fireRate,
            projectiles: 1, projectileDamage: weaponSettings.damage, projectileType: weaponSettings.projectileType,
            lastShotTime: 0, speed: 220, baseSpeed: 220, pickupRadius: 100,
            dashCooldown: 2000, lastDashTime: 0, isDashing: false, dashDuration: 150, dashSpeed: 750,
            shields: 1, // Start with 1 shield by default
            explosiveProjectiles: false,
            speedBoostTimer: 0, fireRateBoostTimer: 0, invincibilityTimer: 0, magnetTimer: 0,
            drones: 0,
            machineGunShotCount: 0,
            decoyCharges: 0,
            regeneration: 0,
            thornsDamage: 0,
            chainReactionChance: 0,
        };
    }

    function formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
    }

    function togglePause() {
        if (gameState !== 'playing' || levelUpScreen.classList.contains('hidden') === false) return;
        isPaused = !isPaused;
        pauseScreen.classList.toggle('hidden', !isPaused);
        if (!isPaused) {
            lastTime = performance.now();
            requestAnimationFrame(gameLoop);
        } else {
            movementJoystickUI.classList.add('hidden');
            attackJoystickUI.classList.add('hidden');
            movementJoystickHandle.style.transform = 'translate(0, 0)';
            attackJoystickHandle.style.transform = 'translate(0, 0)';
            movementJoystickState.active = false;
            movementJoystickState.touchId = null;
            attackJoystickState.active = false;
            attackJoystickState.touchId = null;
        }
    }
    
    function triggerDash() {
        if (gameState !== 'playing' || isPaused) return;
        const now = performance.now();
        if (now - player.lastDashTime > player.dashCooldown) {
            if (player.decoyCharges > 0) {
                player.decoyCharges--;
                decoys.push({ x: player.x, y: player.y, lifespan: 4000 });
                playSound('sine', 200, 0.2, 0.3);
            }
            player.isDashing = true;
            player.lastDashTime = now;
            sounds.dash();
            setTimeout(() => player.isDashing = false, player.dashDuration);
        }
    }

    // --- Input Handling ---
    function getCanvasCoordinates(clientX, clientY) {
         const rect = canvas.getBoundingClientRect();
         const scaleX = canvas.width / rect.width;
         const scaleY = canvas.height / rect.height;
         return {
             x: (clientX - rect.left) * scaleX,
             y: (clientY - rect.top) * scaleY
         };
    }

    function handleTouchStart(e) {
        if (e.target.closest('button, .upgrade-card')) return;
        if (gameState !== 'playing' || isPaused) return;
        e.preventDefault();
        const rect = gameWrapper.getBoundingClientRect();
        const now = e.timeStamp;

        for (const touch of e.changedTouches) {
            const isLeftHalf = touch.clientX < window.innerWidth / 2;

            if (isLeftHalf && !movementJoystickState.active) {
                const state = movementJoystickState;
                state.active = true;
                state.touchId = touch.identifier;
                state.x = touch.clientX;
                state.y = touch.clientY;
                state.startX = touch.clientX;
                state.startY = touch.clientY;
                state.startTime = now;
                state.dx = 0;
                state.dy = 0;
                
                movementJoystickUI.style.left = `${touch.clientX - rect.left - JOYSTICK_BASE_RADIUS}px`;
                movementJoystickUI.style.top = `${touch.clientY - rect.top - JOYSTICK_BASE_RADIUS}px`;
                movementJoystickUI.classList.remove('hidden');
                movementJoystickUI.classList.add('active');

            } else if (!isLeftHalf && !attackJoystickState.active) {
                const state = attackJoystickState;
                state.active = true;
                state.touchId = touch.identifier;
                state.x = touch.clientX;
                state.y = touch.clientY;
                state.dx = 0;
                state.dy = 0;
                
                attackJoystickUI.style.left = `${touch.clientX - rect.left - JOYSTICK_BASE_RADIUS}px`;
                attackJoystickUI.style.top = `${touch.clientY - rect.top - JOYSTICK_BASE_RADIUS}px`;
                attackJoystickUI.classList.remove('hidden');
                attackJoystickUI.classList.add('active');
            }
        }
        activeTouchCount = e.touches.length;
    }

    function handleTouchMove(e) {
        let isJoystickMove = false;
        for (const touch of e.changedTouches) {
            if (touch.identifier === movementJoystickState.touchId || touch.identifier === attackJoystickState.touchId) {
                isJoystickMove = true;
                break;
            }
        }
        
        if (!isJoystickMove) {
            return; // Not a joystick touch, let browser handle it.
        }
    
        e.preventDefault(); // It's a joystick touch, prevent default actions.
    
        if (gameState !== 'playing' || isPaused) {
            return; // Game is paused, don't update joystick visuals/state.
        }

        for (const touch of e.changedTouches) {
            let state = null;
            let handle = null;
            if (touch.identifier === movementJoystickState.touchId) {
                state = movementJoystickState;
                handle = movementJoystickHandle;
            } else if (touch.identifier === attackJoystickState.touchId) {
                state = attackJoystickState;
                handle = attackJoystickHandle;
            }

            if (state && handle) {
                const deltaX = touch.clientX - state.x;
                const deltaY = touch.clientY - state.y;
                const dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                
                if (dist < JOYSTICK_DEAD_ZONE) {
                    state.dx = 0;
                    state.dy = 0;
                    handle.style.transform = `translate(0px, 0px)`;
                } else {
                    const angle = Math.atan2(deltaY, deltaX);
                    
                    // For game logic, map the range [DEAD_ZONE, MAX_OFFSET] to [0, 1] for magnitude
                    const effectiveDist = dist - JOYSTICK_DEAD_ZONE;
                    const effectiveMax = JOYSTICK_MAX_OFFSET - JOYSTICK_DEAD_ZONE;
                    const magnitude = Math.min(1.0, effectiveDist / effectiveMax);

                    state.dx = Math.cos(angle) * magnitude;
                    state.dy = Math.sin(angle) * magnitude;
                    
                    // For visuals, clamp the handle to the joystick's edge
                    const visualDist = Math.min(dist, JOYSTICK_MAX_OFFSET);
                    handle.style.transform = `translate(${Math.cos(angle) * visualDist}px, ${Math.sin(angle) * visualDist}px)`;
                }
            }
        }
    }

    function handleTouchEnd(e) {
        if (gameState !== 'playing' || isPaused) {
            if (movementJoystickState.touchId !== null || attackJoystickState.touchId !== null) {
                movementJoystickUI.classList.add('hidden');
                attackJoystickUI.classList.add('hidden');
            }
            return;
        };

        const now = e.timeStamp;
        for (const touch of e.changedTouches) {
            if (touch.identifier === movementJoystickState.touchId) {
                const state = movementJoystickState;
                const duration = now - state.startTime;
                const dist = Math.sqrt((touch.clientX - state.startX)**2 + (touch.clientY - state.startY)**2);

                if (duration < 200 && dist < 20) { // Tap detection
                    triggerDash();
                }

                state.active = false;
                state.touchId = null;
                state.dx = 0;
                state.dy = 0;
                movementJoystickUI.classList.add('hidden');
                movementJoystickUI.classList.remove('active');
                movementJoystickHandle.style.transform = 'translate(0, 0)';
            } else if (touch.identifier === attackJoystickState.touchId) {
                const state = attackJoystickState;
                state.active = false;
                state.touchId = null;
                state.dx = 0;
                state.dy = 0;
                attackJoystickUI.classList.add('hidden');
                attackJoystickUI.classList.remove('active');
                attackJoystickHandle.style.transform = 'translate(0, 0)';
            }
        }
        activeTouchCount = e.touches.length;
    }

    function init() {
        const rank = getRank(highScore);
        highscoreUI.innerHTML = `최고기록: ${formatTime(highScore)} <span style="color: ${rank.color}; text-shadow: 0 0 5px ${rank.color};">(${rank.name})</span>`;
        startScreenHighscoreUI.innerHTML = `최고 기록: ${formatTime(highScore)} &bull; 랭크: <span style="color: ${rank.color}; text-shadow: 0 0 8px ${rank.color};">${rank.name}</span>`;
        
        difficultySelection.addEventListener('click', e => {
            const target = e.target.closest('button');
            if (target && target.dataset.difficulty) {
                selectedDifficulty = target.dataset.difficulty;
                [...difficultySelection.children].forEach(btn => btn.classList.remove('selected'));
                target.classList.add('selected');
            }
        });

        weaponSelection.addEventListener('click', e => {
            const target = e.target.closest('button');
            if (target && target.dataset.weapon) {
                selectedWeapon = target.dataset.weapon;
                [...weaponSelection.children].forEach(btn => btn.classList.remove('selected'));
                target.classList.add('selected');
                checkSelections();
            }
        });
        
        selectedDifficulty = '보통';
        const defaultWeapon = weaponSelection.querySelector('[data-weapon="machine-gun"]');
        if(defaultWeapon) defaultWeapon.click();

        startButton.onclick = startGame;
        restartButton.onclick = () => {
            gameOverScreen.classList.add('hidden');
            pauseButton.classList.add('hidden');
            startScreen.classList.remove('hidden');
        };
        pauseButton.onclick = togglePause;
        
        resumeButton.onclick = togglePause;
        restartPauseButton.onclick = () => {
            pauseScreen.classList.add('hidden');
            isPaused = false;
            startGame();
        };
        quitButton.onclick = () => {
            pauseScreen.classList.add('hidden');
            isPaused = false;
            gameState = 'start';
            if(animationFrameId) cancelAnimationFrame(animationFrameId);
            startScreen.classList.remove('hidden');
            pauseButton.classList.add('hidden');
        };
        
        // Input Listeners
        window.addEventListener('keydown', e => {
            keysPressed[e.code] = true;
            if (e.key === "Escape") togglePause();
            if (e.code === 'Space') {
                triggerDash();
            }
        });
        window.addEventListener('keyup', e => { keysPressed[e.code] = false; });
        
        canvas.addEventListener('mousemove', e => {
            if (activeTouchCount === 0) {
                 mousePos = getCanvasCoordinates(e.clientX, e.clientY);
            }
        });
        gameWrapper.addEventListener('touchstart', handleTouchStart, { passive: false });
        gameWrapper.addEventListener('touchmove', handleTouchMove, { passive: false });
        gameWrapper.addEventListener('touchend', handleTouchEnd, { passive: false });
        gameWrapper.addEventListener('touchcancel', handleTouchEnd, { passive: false });

        function checkSelections() {
            startButton.disabled = !selectedWeapon;
        }

        checkSelections();
    }

    // --- Game Logic ---
    function startGame() {
        startScreen.classList.add('hidden');
        pauseButton.classList.remove('hidden');
        gameState = 'playing';
        isPaused = false;
        
        player = createInitialPlayer(selectedDifficulty, selectedWeapon);
        enemies = [];
        projectiles = [];
        enemyProjectiles = [];
        xpGems = [];
        healthPacks = [];
        nukes = [];
        explosions = [];
        damageTexts = [];
        orbitalShields = [];
        drones = [];
        decoys = [];
        blackHoles = [];
        vortexes = [];
        magnets = [];
        xpBombs = [];

        gameTime = 0;
        lastSpawnTime = 0;
        spawnInterval = 3000;
        bossSpawned = false;
        comboCount = 0;
        lastKillTime = 0;

        levelUI.textContent = `레벨: 1`;
        hpBar.style.width = '100%';
        xpBar.style.width = '0%';
        comboUI.textContent = '';
        currentRankUI.textContent = '';
        
        if (animationFrameId) cancelAnimationFrame(animationFrameId);
        lastTime = performance.now();
        gameLoop();
    }

    function gameOver() {
        gameState = 'gameover';
        if (gameTime > highScore) {
            highScore = gameTime;
            localStorage.setItem('neonSurvivorHighScore', highScore);
        }
        const rank = getRank(gameTime);
        const highscoreRank = getRank(highScore);
        
        gameOverTimeUI.textContent = `생존 시간: ${formatTime(gameTime)}`;
        gameOverRankUI.innerHTML = `달성 랭크: <span style="color:${rank.color}">${rank.name}</span>`;
        gameOverHighscoreUI.innerHTML = `최고 기록: ${formatTime(highScore)} (<span style="color:${highscoreRank.color}">${highscoreRank.name}</span>)`;
        
        init();
        gameOverScreen.classList.remove('hidden');
        pauseButton.classList.add('hidden');
    }
    
    function checkLevelUp() {
        while (player.xp >= player.xpToNextLevel) {
            player.xp -= player.xpToNextLevel;
            player.level++;
            player.xpToNextLevel = Math.floor(player.xpToNextLevel * 1.5);
            levelUI.textContent = `레벨: ${player.level}`;
            sounds.levelUp();
            handleLevelUp();
        }
    }

    function handleLevelUp() {
        isPaused = true;
        
        movementJoystickUI.classList.add('hidden');
        attackJoystickUI.classList.add('hidden');

        levelUpOptionsContainer.innerHTML = '';
        const shuffledUpgrades = [...availableUpgrades].sort(() => 0.5 - Math.random());
        const options = shuffledUpgrades.slice(0, 3);
        
        options.forEach(upgrade => {
            const card = document.createElement('div');
            card.className = 'upgrade-card p-4 flex flex-col items-center justify-center space-y-2';
            card.innerHTML = `<h3 class="text-xl font-bold text-cyan-300">${upgrade.title}</h3><p class="text-sm text-gray-300">${upgrade.description}</p>`;
            card.onclick = () => {
                upgrade.apply(player);
                levelUpScreen.classList.add('hidden');
                isPaused = false;
                lastTime = performance.now();
                gameLoop();
            };
            levelUpOptionsContainer.appendChild(card);
        });

        levelUpScreen.classList.remove('hidden');
    }

    function spawnEnemy() {
        const edge = Math.floor(Math.random() * 4);
        let x, y;
        if (edge === 0) { x = -20; y = Math.random() * CANVAS_HEIGHT; } // left
        else if (edge === 1) { x = CANVAS_WIDTH + 20; y = Math.random() * CANVAS_HEIGHT; } // right
        else if (edge === 2) { x = Math.random() * CANVAS_WIDTH; y = -20; } // top
        else { x = Math.random() * CANVAS_WIDTH; y = CANVAS_HEIGHT + 20; } // bottom
        
        let enemyTypeKey;
        const random = Math.random();
        if (gameTime > 120 && random < 0.05) enemyTypeKey = 'summoner';
        else if (gameTime > 90 && random < 0.15) enemyTypeKey = 'bomber';
        else if (gameTime > 60 && random < 0.25) enemyTypeKey = 'tank';
        else if (gameTime > 30 && random < 0.40) enemyTypeKey = 'shooter';
        else enemyTypeKey = 'grunt';
        
        const type = ENEMY_TYPES[enemyTypeKey];
        const hpMultiplier = 1 + Math.floor(gameTime / 30) * 0.2;

        enemies.push({ 
            x, y, ...type, 
            hp: type.hp * hpMultiplier, 
            maxHp: type.hp * hpMultiplier,
            lastActionTime: 0
        });
    }

    function update(deltaTime) {
        updatePlayer(deltaTime);
        updateEnemies(deltaTime);
        updateProjectiles(deltaTime);
        updateVortexes(deltaTime);
        updateItems(deltaTime);
        updateExplosions(deltaTime);
        checkCollisions(deltaTime);
        updateDamageTexts(deltaTime);

        const now = performance.now();
        if (now - lastSpawnTime > spawnInterval) {
            lastSpawnTime = now;
            const spawnCount = 1 + Math.floor(gameTime / 15);
            for(let i=0; i<spawnCount; i++) spawnEnemy();
            if (spawnInterval > 500) spawnInterval *= 0.98;
        }

        if (now - lastKillTime > COMBO_TIMEOUT && comboCount > 0) {
            comboCount = 0;
            comboUI.textContent = '';
        }
    }

    function draw() {
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        drawPlayer();
        drawEnemies();
        drawVortexes();
        drawProjectiles();
        drawXpGems();
        drawItems();
        drawExplosions();
        drawDamageTexts();

        // Mouse cursor
        if (!isPaused && activeTouchCount === 0) {
            ctx.fillStyle = '#00ffff';
            ctx.beginPath();
            ctx.arc(mousePos.x, mousePos.y, 5, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    function gameLoop(currentTime) {
        if (isPaused) return;

        const deltaTime = (currentTime - lastTime) / 1000;
        lastTime = currentTime;
        gameTime += deltaTime;

        update(deltaTime);
        draw();
        
        // Update UI
        timerUI.textContent = formatTime(gameTime);
        hpBar.style.width = `${Math.max(0, (player.hp / player.maxHp) * 100)}%`;
        xpBar.style.width = `${(player.xp / player.xpToNextLevel) * 100}%`;
        
        const currentRank = getRank(gameTime);
        const currentRankIndex = RANKS.findIndex(r => r.name === currentRank.name);
        let rankProgressText = '';
        if (currentRankIndex < RANKS.length - 1) {
            const nextRank = RANKS[currentRankIndex + 1];
            const progress = Math.max(0, (gameTime - currentRank.threshold)) / (nextRank.threshold - currentRank.threshold) * 100;
            rankProgressText = ` (${progress.toFixed(0)}%)`;
        }
        currentRankUI.innerHTML = `<span style="color: ${currentRank.color}; text-shadow: 0 0 5px ${currentRank.color};">${currentRank.name}</span>${rankProgressText}`;

        if (player.hp <= 0) {
            gameOver();
            return;
        }
        
        animationFrameId = requestAnimationFrame(gameLoop);
    }
    
    // --- Update Functions ---
    function updatePlayer(deltaTime) {
        if (player.isDashing) return;

        let dx = 0, dy = 0;
        if (keysPressed['KeyW'] || keysPressed['ArrowUp']) dy -= 1;
        if (keysPressed['KeyS'] || keysPressed['ArrowDown']) dy += 1;
        if (keysPressed['KeyA'] || keysPressed['ArrowLeft']) dx -= 1;
        if (keysPressed['KeyD'] || keysPressed['ArrowRight']) dx += 1;
        
        if (movementJoystickState.active) {
            dx = movementJoystickState.dx;
            dy = movementJoystickState.dy;
        }

        const length = Math.sqrt(dx * dx + dy * dy);
        if (length > 0) {
            dx /= length;
            dy /= length;
        }

        player.x += dx * player.speed * deltaTime;
        player.y += dy * player.speed * deltaTime;

        player.x = Math.max(PLAYER_SIZE / 2, Math.min(CANVAS_WIDTH - PLAYER_SIZE / 2, player.x));
        player.y = Math.max(PLAYER_SIZE / 2, Math.min(CANVAS_HEIGHT - PLAYER_SIZE / 2, player.y));
        
        // Handle shooting
        const now = performance.now();
        if (now - player.lastShotTime > player.fireRate) {
             let shoot = false;
             let targetX = mousePos.x, targetY = mousePos.y;
             if(attackJoystickState.active && (attackJoystickState.dx !== 0 || attackJoystickState.dy !== 0)){
                 shoot = true;
                 targetX = player.x + attackJoystickState.dx;
                 targetY = player.y + attackJoystickState.dy;
             } else if (activeTouchCount === 0 && (keysPressed['KeyW'] || keysPressed['KeyA'] || keysPressed['KeyS'] || keysPressed['KeyD'] || keysPressed['ArrowUp'] || keysPressed['ArrowDown'] || keysPressed['ArrowLeft'] || keysPressed['ArrowRight'])) {
                 shoot = true;
             } else if (activeTouchCount === 0 && !Object.values(keysPressed).some(v => v)){
                 // Auto-shoot at nearest enemy when idle on desktop
                 const nearestEnemy = enemies.reduce((closest, enemy) => {
                     const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);
                     return !closest || dist < closest.dist ? { enemy, dist } : closest;
                 }, null);
                 if (nearestEnemy && nearestEnemy.dist < 400) {
                     shoot = true;
                     targetX = nearestEnemy.enemy.x;
                     targetY = nearestEnemy.enemy.y;
                 }
             }

            if (shoot) {
                const angle = Math.atan2(targetY - player.y, targetX - player.x);
                for(let i=0; i<player.projectiles; i++){
                    const spread = (i - (player.projectiles - 1) / 2) * 0.2;
                    const proj = {
                        x: player.x, y: player.y, 
                        vx: Math.cos(angle + spread) * 400,
                        vy: Math.sin(angle + spread) * 400,
                        damage: player.projectileDamage,
                        type: player.projectileType,
                        hitEnemies: new Set(),
                    };
                    
                    let pierce = 1;
                    if (proj.type === 'glitch-pulse' || proj.type === 'laser' || proj.type === 'arrow') {
                        pierce = 999;
                    }
                    proj.pierce = pierce;

                    if (proj.type === 'glitch-pulse') {
                        proj.lifespan = 250;
                    }

                    projectiles.push(proj);
                }
                player.lastShotTime = now;
                sounds.shoot();
            }
        }
        
        // Regeneration
        if (player.regeneration > 0) {
            player.hp = Math.min(player.maxHp, player.hp + player.regeneration * deltaTime);
        }
    }

    function updateEnemies(deltaTime) {
        enemies.forEach(enemy => {
            if (enemy.stunnedUntil && performance.now() < enemy.stunnedUntil) return;
            const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
            enemy.x += Math.cos(angle) * enemy.speed * deltaTime;
            enemy.y += Math.sin(angle) * enemy.speed * deltaTime;
        });
    }

    function updateProjectiles(deltaTime) {
        for (let i = projectiles.length - 1; i >= 0; i--) {
            const p = projectiles[i];
            p.x += p.vx * deltaTime;
            p.y += p.vy * deltaTime;
            
            if (p.lifespan) {
                p.lifespan -= deltaTime * 1000;
            }

            if (p.x < 0 || p.x > CANVAS_WIDTH || p.y < 0 || p.y > CANVAS_HEIGHT || (p.lifespan && p.lifespan <= 0)) {
                projectiles.splice(i, 1);
            }
        }
    }

    function updateVortexes(deltaTime) {
        const now = performance.now();
        for (let i = vortexes.length - 1; i >= 0; i--) {
            const vortex = vortexes[i];
            vortex.duration -= deltaTime * 1000;
            if (vortex.duration <= 0) {
                vortexes.splice(i, 1);
                continue;
            }
            
            // Apply damage over time
            if (now - vortex.lastDamageTime > 500) { // every 0.5s
                enemies.forEach(enemy => {
                    if (enemy.stunnedUntil && performance.now() < enemy.stunnedUntil) return;
                    const dist = Math.hypot(vortex.x - enemy.x, vortex.y - enemy.y);
                    if (dist < vortex.radius) {
                        enemy.hp -= vortex.damage;
                        damageTexts.push({ x: enemy.x, y: enemy.y, text: vortex.damage.toFixed(0), duration: 500, color: '#c084fc' });
                    }
                });
                vortex.lastDamageTime = now;
            }

            // Pull enemies
            enemies.forEach(enemy => {
                if (enemy.stunnedUntil && performance.now() < enemy.stunnedUntil) return;
                const dist = Math.hypot(vortex.x - enemy.x, vortex.y - enemy.y);
                if (dist < vortex.radius && dist > 10) { // Don't pull if too close
                    const angle = Math.atan2(vortex.y - enemy.y, vortex.x - enemy.x);
                    const pullStrength = 150;
                    enemy.x += Math.cos(angle) * pullStrength * deltaTime;
                    enemy.y += Math.sin(angle) * pullStrength * deltaTime;
                }
            });
        }
    }

    function updateItems(deltaTime) {
        if (player.magnetTimer > 0) {
            player.magnetTimer -= deltaTime * 1000;
        }
        // Update other timers for powerups
    }

    function updateXpGems(deltaTime) {
         for (let i = xpGems.length - 1; i >= 0; i--) {
            const gem = xpGems[i];
            const dist = Math.hypot(player.x - gem.x, player.y - gem.y);
            
            const effectivePickupRadius = player.magnetTimer > 0 ? player.pickupRadius * 3 : player.pickupRadius;

            if (dist < effectivePickupRadius) {
                const angle = Math.atan2(player.y - gem.y, player.x - gem.x);
                gem.x += Math.cos(angle) * 300 * deltaTime;
                gem.y += Math.sin(angle) * 300 * deltaTime;
            }
            if (dist < PLAYER_SIZE / 2) {
                player.xp += gem.value;
                xpGems.splice(i, 1);
                sounds.xp();
                checkLevelUp();
            }
        }
    }

    function updateExplosions(deltaTime) {
        for (let i = explosions.length - 1; i >= 0; i--) {
            const exp = explosions[i];
            exp.duration -= deltaTime * 1000;
            if (exp.duration <= 0) {
                explosions.splice(i, 1);
            }
        }
    }
    
    function updateDamageTexts(deltaTime) {
        for (let i = damageTexts.length - 1; i >= 0; i--) {
            const dt = damageTexts[i];
            dt.y -= 30 * deltaTime;
            dt.duration -= deltaTime * 1000;
            if (dt.duration <= 0) {
                damageTexts.splice(i, 1);
            }
        }
    }

    function checkCollisions(deltaTime) {
        // Projectiles vs Enemies
        for (let i = projectiles.length - 1; i >= 0; i--) {
            for (let j = enemies.length - 1; j >= 0; j--) {
                const p = projectiles[i];
                const e = enemies[j];
                if (!p || !e || p.hitEnemies.has(e)) continue;

                const dist = Math.hypot(p.x - e.x, p.y - e.y);
                if (dist < e.size / 2) {
                    e.hp -= p.damage;
                    damageTexts.push({ x: e.x, y: e.y, text: p.damage.toFixed(0), duration: 500, color: '#fff' });

                    if (p.type === 'vortex-orb') {
                        vortexes.push({ x: p.x, y: p.y, radius: 100, duration: 3000, damage: WEAPON_SETTINGS['vortex-cannon'].damage, lastDamageTime: 0 });
                        sounds.blackHole();
                        projectiles.splice(i, 1);
                        break;
                    }
                    
                    if (p.type === 'glitch-pulse') {
                        const settings = WEAPON_SETTINGS['glitch-pulser'];
                        if (Math.random() < settings.stunChance) {
                            e.stunnedUntil = performance.now() + settings.stunDuration;
                        }
                    }

                    p.hitEnemies.add(e);

                    if (p.hitEnemies.size >= p.pierce) {
                        projectiles.splice(i, 1);
                        break; // Projectile is gone
                    }
                }
            }
        }

        // Enemies vs Player and death logic
        for (let i = enemies.length - 1; i >= 0; i--) {
            const enemy = enemies[i];
            
            // Death check
            if (enemy.hp <= 0) {
                for (let k = 0; k < enemy.xp; k++) {
                    xpGems.push({ x: enemy.x + Math.random()*10-5, y: enemy.y + Math.random()*10-5, value: 1 });
                }
                
                if (player.chainReactionChance > 0 && Math.random() < player.chainReactionChance) {
                    explosions.push({ x: enemy.x, y: enemy.y, radius: 60, damage: 25, duration: 200, color: 'orange' });
                    sounds.explosion();
                }

                const dropRoll = Math.random();
                if (dropRoll < 0.02) {
                    magnets.push({ x: enemy.x, y: enemy.y });
                } else if (dropRoll < 0.04) { 
                    xpBombs.push({ x: enemy.x, y: enemy.y });
                }

                enemies.splice(i, 1);
                comboCount++;
                lastKillTime = performance.now();
                comboUI.textContent = `${comboCount} COMBO`;
                continue;
            }

            // Player vs Enemy Collision
            const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);
            if (dist < PLAYER_SIZE / 2 + enemy.size / 2 && !player.isDashing) {
                player.hp -= enemy.damage;
                sounds.hit();
                damageTexts.push({ x: player.x, y: player.y - 15, text: enemy.damage, duration: 500, color: 'red'});

                if (player.thornsDamage > 0) {
                    enemy.hp -= player.thornsDamage;
                    damageTexts.push({ x: enemy.x, y: enemy.y, text: player.thornsDamage, duration: 500, color: 'purple'});
                }
            }
        }
        
        checkItemCollisions();

        // Explosion vs Enemies
        explosions.forEach(exp => {
            if (exp.damagedEnemies) return;
            exp.damagedEnemies = new Set();
            enemies.forEach(enemy => {
                if (exp.damagedEnemies.has(enemy)) return;
                const dist = Math.hypot(exp.x - enemy.x, exp.y - enemy.y);
                if (dist < exp.radius + enemy.size / 2) {
                    enemy.hp -= exp.damage;
                    exp.damagedEnemies.add(enemy);
                }
            });
        });
        
        updateXpGems(deltaTime);
    }
    
    function checkItemCollisions() {
        // Magnets
        for (let i = magnets.length - 1; i >= 0; i--) {
            const magnet = magnets[i];
            if (Math.hypot(player.x - magnet.x, player.y - magnet.y) < PLAYER_SIZE / 2 + 15) {
                player.magnetTimer = 10000; // 10 seconds
                sounds.powerup();
                magnets.splice(i, 1);
            }
        }

        // XP Bombs
        for (let i = xpBombs.length - 1; i >= 0; i--) {
            const bomb = xpBombs[i];
            if (Math.hypot(player.x - bomb.x, player.y - bomb.y) < PLAYER_SIZE / 2 + 15) {
                player.xp += player.xpToNextLevel * 0.25;
                checkLevelUp();
                sounds.xp();
                xpBombs.splice(i, 1);
            }
        }
    }

    // --- Draw Functions ---
    function drawPlayer() {
        ctx.fillStyle = player.isDashing ? '#00ffff' : '#fff';
        ctx.shadowBlur = 10;
        ctx.shadowColor = player.isDashing ? '#00ffff' : '#ff00ff';
        ctx.fillRect(player.x - PLAYER_SIZE / 2, player.y - PLAYER_SIZE / 2, PLAYER_SIZE, PLAYER_SIZE);
        ctx.shadowBlur = 0;
    }

    function drawEnemies() {
        enemies.forEach(enemy => {
            const isStunned = enemy.stunnedUntil && performance.now() < enemy.stunnedUntil;
            ctx.fillStyle = isStunned && Math.floor(performance.now() / 100) % 2 === 0 ? '#ffffff' : (isStunned ? '#8888ff' : enemy.color);
            ctx.shadowBlur = 10;
            ctx.shadowColor = enemy.color;
            ctx.fillRect(enemy.x - enemy.size / 2, enemy.y - enemy.size / 2, enemy.size, enemy.size);
            
            // Health bar
            if (enemy.hp < enemy.maxHp) {
                ctx.fillStyle = 'red';
                ctx.fillRect(enemy.x - enemy.size / 2, enemy.y - enemy.size / 2 - 8, enemy.size, 4);
                ctx.fillStyle = 'lime';
                ctx.fillRect(enemy.x - enemy.size / 2, enemy.y - enemy.size / 2 - 8, enemy.size * (enemy.hp / enemy.maxHp), 4);
            }
            
            ctx.shadowBlur = 0;
        });
    }

    function drawProjectiles() {
        projectiles.forEach(p => {
             if (p.type === 'glitch-pulse') {
                ctx.fillStyle = 'rgba(136, 136, 255, 0.7)';
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#8888ff';
                const angle = Math.atan2(p.vy, p.vx);
                ctx.save();
                ctx.translate(p.x, p.y);
                ctx.rotate(angle);
                ctx.beginPath();
                ctx.arc(0, 0, 30, -Math.PI / 4, Math.PI / 4);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
                ctx.shadowBlur = 0;
            } else {
                ctx.fillStyle = '#00ffff';
                ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
            }
        });
    }

    function drawVortexes() {
        vortexes.forEach(v => {
            const gradient = ctx.createRadialGradient(v.x, v.y, 5, v.x, v.y, v.radius);
            gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
            gradient.addColorStop(0.5, 'rgba(192, 132, 252, 0.5)');
            gradient.addColorStop(1, 'rgba(192, 132, 252, 0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(v.x, v.y, v.radius, 0, Math.PI * 2);
            ctx.fill();
        });
    }

    function drawXpGems() {
        xpGems.forEach(gem => {
            ctx.fillStyle = '#00ffff';
            ctx.shadowBlur = 5;
            ctx.shadowColor = '#00ffff';
            ctx.fillRect(gem.x - 3, gem.y - 3, 6, 6);
            ctx.shadowBlur = 0;
        });
    }

    function drawItems() {
        ctx.font = "24px sans-serif";
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        magnets.forEach(magnet => {
            ctx.fillText('🧲', magnet.x, magnet.y);
        });
        xpBombs.forEach(bomb => {
            ctx.fillText('⭐', bomb.x, bomb.y);
        });
    }

    function drawExplosions() {
        explosions.forEach(exp => {
            ctx.fillStyle = `rgba(255, 165, 0, ${exp.duration / 200})`;
            ctx.beginPath();
            ctx.arc(exp.x, exp.y, exp.radius, 0, Math.PI * 2);
            ctx.fill();
        });
    }

    function drawDamageTexts() {
        damageTexts.forEach(dt => {
            ctx.font = "bold 16px Orbitron";
            ctx.fillStyle = dt.color;
            ctx.textAlign = 'center';
            ctx.fillText(dt.text, dt.x, dt.y);
        });
    }
    
    init();
});
</script>
</body>
</html>

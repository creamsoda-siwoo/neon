
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>네온 서바이버</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      font-family: 'Orbitron', sans-serif;
      overflow: hidden;
      background-color: #0d0221;
      color: white;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      margin: 0;
      padding: 1rem;
    }
    .game-container {
      background: #0a0a1f;
      border: 2px solid #00ffff;
      box-shadow: 0 0 20px #00ffff, inset 0 0 20px #00ffff;
      width: 90vmin;
      aspect-ratio: 4 / 3;
    }
    #game-canvas {
      background-color: #0d0221;
      cursor: none;
      width: 100%;
      height: 100%;
      display: block;
    }
    .text-glow {
      color: #fff;
      text-shadow: 0 0 7px #fff, 0 0 10px #fff, 0 0 21px #ff00ff, 0 0 42px #ff00ff;
    }
    .button-retro {
      background-color: transparent;
      border: 2px solid #fff;
      color: #fff;
      padding: 0.75rem 1.5rem;
      text-transform: uppercase;
      letter-spacing: 2px;
      transition: all 0.2s ease-in-out;
      text-shadow: 0 0 8px #ff00ff;
      cursor: pointer;
    }
    .button-retro:hover:not(:disabled) {
      background-color: #fff;
      color: #0d0221;
      box-shadow: 0 0 20px #fff, 0 0 30px #ff00ff;
    }
    .button-retro:disabled {
        cursor: not-allowed;
        opacity: 0.5;
    }
    .selection-button {
        border-width: 2px;
        border-color: #fff;
        background-color: transparent;
        padding: 0.5rem;
        height: 100%;
        font-size: 0.875rem;
    }
    .selection-button.selected {
        background-color: #00ffff;
        color: #0d0221;
        box-shadow: 0 0 20px #00ffff;
    }
    .upgrade-card {
      border: 2px solid #00ffff;
      background: rgba(13, 2, 33, 0.8);
      transition: all 0.2s ease-in-out;
      cursor: pointer;
    }
    .upgrade-card:hover {
      background: rgba(0, 255, 255, 0.2);
      box-shadow: 0 0 15px #00ffff;
      transform: translateY(-5px);
    }
    .overlay {
        position: absolute;
        inset: 0;
        background-color: rgba(0,0,0,0.85);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
        z-index: 10;
        padding: 1rem;
    }
    .hidden {
        display: none;
    }
    #start-button {
        padding: 1rem 2rem;
        font-size: 1.25rem;
        font-weight: bold;
    }
    @keyframes pulse-glow {
        0% {
            transform: scale(1);
            box-shadow: 0 0 15px #00ffff, 0 0 25px #ff00ff;
        }
        50% {
            transform: scale(1.08);
            box-shadow: 0 0 30px #00ffff, 0 0 50px #ff00ff;
        }
        100% {
            transform: scale(1);
            box-shadow: 0 0 15px #00ffff, 0 0 25px #ff00ff;
        }
    }

    #start-button:not(:disabled) {
        border-color: #00ffff;
        color: #00ffff;
        text-shadow: 0 0 8px #00ffff;
        animation: pulse-glow 2s infinite ease-in-out;
    }
  </style>
</head>
<body>

  <main class="flex flex-col items-center">
    <div class="flex justify-between w-full mb-2 px-2 text-glow" style="max-width: 90vmin;">
        <div class="flex gap-4 items-center">
            <div id="level-ui" class="text-xl">레벨: 1</div>
            <div id="current-rank-ui" class="text-lg"></div>
        </div>
        <div class="flex flex-col items-center">
            <div id="timer-ui" class="text-2xl font-bold">00:00</div>
            <div id="combo-ui" class="text-xl font-bold text-yellow-400 h-6" style="text-shadow: 0 0 8px #facc15;"></div>
        </div>
        <div id="highscore-ui" class="text-xl text-right">최고기록: 00:00</div>
    </div>
    
    <div class="w-full h-8 mb-2 flex flex-col justify-around" style="max-width: 90vmin;">
        <div class="w-full bg-gray-700 h-3 rounded-full overflow-hidden border border-red-500">
            <div id="hp-bar" class="bg-red-500 h-full" style="width: 100%"></div>
        </div>
        <div class="w-full bg-gray-700 h-3 rounded-full overflow-hidden border border-cyan-400">
            <div id="xp-bar" class="bg-cyan-400 h-full" style="width: 0%"></div>
        </div>
    </div>

    <div id="game-wrapper" class="relative rounded-lg overflow-hidden game-container">
      <canvas id="game-canvas" width="800" height="600"></canvas>
      <button id="pause-button" class="absolute top-2 right-2 text-2xl w-12 h-12 button-retro hidden items-center justify-center" style="padding: 0;">||</button>
      
      <div id="start-screen" class="overlay">
          <h1 class="text-5xl md:text-6xl font-bold mb-4 text-glow">네온 서바이버</h1>
          <div id="start-screen-highscore" class="text-xl mb-8 text-glow"></div>
          
          <div class="mb-6">
              <h2 class="text-xl mb-2 text-glow">난이도 선택</h2>
              <div id="difficulty-selection" class="flex justify-center gap-4">
                  <button class="button-retro selection-button" data-difficulty="쉬움">쉬움</button>
                  <button class="button-retro selection-button" data-difficulty="보통">보통</button>
                  <button class="button-retro selection-button" data-difficulty="어려움">어려움</button>
              </div>
          </div>
          
          <div class="w-full max-w-2xl">
              <h2 class="text-xl mb-2 text-glow">무기 선택</h2>
              <div id="weapon-selection" class="grid grid-cols-3 gap-2 mb-2">
                  <button class="button-retro selection-button" data-weapon="machine-gun">기관총</button>
                  <button class="button-retro selection-button" data-weapon="missile">유도 미사일</button>
                  <button class="button-retro selection-button" data-weapon="bomb">폭탄</button>
                  <button class="button-retro selection-button" data-weapon="shotgun">샷건</button>
                  <button class="button-retro selection-button" data-weapon="laser">레이저</button>
                  <button class="button-retro selection-button" data-weapon="bow">활</button>
                  <button class="button-retro selection-button" data-weapon="flamethrower">화염방사기</button>
                  <button class="button-retro selection-button" data-weapon="chain-lightning">연쇄 번개</button>
                  <button class="button-retro selection-button" data-weapon="black-hole-generator">블랙홀 생성기</button>
              </div>
              <div id="weapon-stats" class="text-sm h-20 p-2 border-2 border-cyan-400 rounded-lg text-left bg-black bg-opacity-25">
                  <p>무기 위로 마우스를 올려 능력치를 확인하세요.</p>
              </div>
          </div>

          <button id="start-button" class="button-retro mt-8" disabled>게임 시작</button>
      </div>

      <div id="pause-screen" class="overlay hidden">
          <h2 class="text-6xl font-bold mb-8 text-glow">일시정지</h2>
          <div class="flex flex-col gap-4 w-64">
              <button id="resume-button" class="button-retro">계속하기</button>
              <button id="restart-pause-button" class="button-retro">다시 시작</button>
              <button id="quit-button" class="button-retro">그만하기</button>
          </div>
      </div>

      <div id="levelup-screen" class="overlay hidden">
          <h2 class="text-5xl font-bold mb-8 text-glow">레벨 업!</h2>
          <div id="levelup-options" class="grid grid-cols-1 md:grid-cols-3 gap-6">
              <!-- Upgrade cards will be injected here -->
          </div>
      </div>

      <div id="gameover-screen" class="overlay hidden">
          <h2 class="text-6xl font-bold mb-4 text-glow">게임 오버</h2>
          <p id="gameover-time" class="text-3xl mb-2">생존 시간: 00:00</p>
          <p id="gameover-rank" class="text-2xl mb-6"></p>
          <p id="gameover-highscore" class="text-xl mb-8">최고 기록: 00:00</p>
          <button id="restart-button" class="button-retro">새로 시작</button>
      </div>
    </div>
  </main>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- DOM Elements ---
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    const startScreen = document.getElementById('start-screen');
    const pauseScreen = document.getElementById('pause-screen');
    const levelUpScreen = document.getElementById('levelup-screen');
    const gameOverScreen = document.getElementById('gameover-screen');
    const startButton = document.getElementById('start-button');
    const restartButton = document.getElementById('restart-button');
    const pauseButton = document.getElementById('pause-button');
    const levelUpOptionsContainer = document.getElementById('levelup-options');
    const difficultySelection = document.getElementById('difficulty-selection');
    const weaponSelection = document.getElementById('weapon-selection');
    const weaponStatsUI = document.getElementById('weapon-stats');
    const resumeButton = document.getElementById('resume-button');
    const restartPauseButton = document.getElementById('restart-pause-button');
    const quitButton = document.getElementById('quit-button');

    // UI Elements
    const levelUI = document.getElementById('level-ui');
    const timerUI = document.getElementById('timer-ui');
    const comboUI = document.getElementById('combo-ui');
    const highscoreUI = document.getElementById('highscore-ui');
    const hpBar = document.getElementById('hp-bar');
    const xpBar = document.getElementById('xp-bar');
    const gameOverTimeUI = document.getElementById('gameover-time');
    const gameOverRankUI = document.getElementById('gameover-rank');
    const gameOverHighscoreUI = document.getElementById('gameover-highscore');
    const startScreenHighscoreUI = document.getElementById('start-screen-highscore');
    const currentRankUI = document.getElementById('current-rank-ui');

    // --- Game Constants ---
    const CANVAS_WIDTH = 800;
    const CANVAS_HEIGHT = 600;
    const PLAYER_SIZE = 20;
    const COMBO_TIMEOUT = 2500;

    // --- Ranking System ---
    const RANKS = [
        { name: '네온 초심자', threshold: 0, color: '#9ca3af' },
        { name: '그리드 러너', threshold: 60, color: '#6ee7b7' },
        { name: '서킷 브레이커', threshold: 120, color: '#60a5fa' },
        { name: '데이터 스트리머', threshold: 180, color: '#c084fc' },
        { name: '사이버 검투사', threshold: 240, color: '#f87171' },
        { name: '신스웨이브 파수꾼', threshold: 300, color: '#facc15' },
        { name: '디지털 오버로드', threshold: 420, color: '#f472b6' }
    ];

    function getRank(seconds) {
        let currentRank = RANKS[0];
        for (const rank of RANKS) {
            if (seconds >= rank.threshold) {
                currentRank = rank;
            } else {
                break;
            }
        }
        return currentRank;
    }
    
    // --- Enemy Types ---
    const ENEMY_TYPES = {
        'grunt': { size: 15, hp: 10, speed: 70, color: '#ff4d4d', xp: 1, shape: 'square', damage: 5 },
        'tank': { size: 30, hp: 50, speed: 40, color: '#ff8c66', xp: 5, shape: 'square', damage: 15 },
        'shooter': { size: 18, hp: 15, speed: 60, color: '#fcf003', xp: 2, shape: 'triangle', damage: 10, fireRate: 2000, projectileSpeed: 150 },
        'bomber': { size: 20, hp: 20, speed: 80, color: '#ff99cc', xp: 3, shape: 'square', damage: 20, onDeath: 'explode' },
        'summoner': { size: 25, hp: 40, speed: 50, color: '#cc99ff', xp: 8, shape: 'triangle', damage: 5, actionRate: 5000, action: 'summon' },
        'boss': { size: 50, hp: 500, speed: 60, color: '#ff0000', xp: 50, shape: 'square', damage: 25, fireRate: 1000, projectileSpeed: 200 },
    };


    // --- Game Configs ---
    const DIFFICULTY_SETTINGS = {
        '쉬움': { hp: 120, enemyHpMult: 0.7, enemySpeedMult: 0.8, spawnRateMult: 1.2 },
        '보통': { hp: 100, enemyHpMult: 1.0, enemySpeedMult: 1.0, spawnRateMult: 1.0 },
        '어려움': { hp: 80, enemyHpMult: 1.5, enemySpeedMult: 1.2, spawnRateMult: 0.8 },
    };
    const WEAPON_SETTINGS = {
        'machine-gun': { fireRate: 400, damage: 12, projectileType: 'bullet', name: '기관총', knockback: 20, description: '가장 균형잡힌 무기. 8발마다 강력한 넉백탄 발사!' },
        'missile': { fireRate: 1000, damage: 40, projectileType: 'missile', name: '유도 미사일', explosionRadius: 70, description: '가장 가까운 적을 추적하며 더 넓은 범위에 폭발 피해를 줍니다.' },
        'bomb': { fireRate: 800, damage: 25, projectileType: 'bomb', name: '폭탄', shrapnelCount: 5, description: '포물선으로 날아가 폭발하며 5개의 파편을 흩뿌립니다.' },
        'shotgun': { fireRate: 700, damage: 10, projectileType: 'pellet', name: '샷건', pellets: 5, spread: 0.5, knockback: 5, description: '근거리의 적들을 밀쳐내며 강력한 피해를 줍니다.' },
        'laser': { fireRate: 1200, damage: 45, projectileType: 'laser', name: '레이저', slowAmount: 0.5, slowDuration: 1000, description: '적을 관통하며 1초간 이동 속도를 50% 감소시킵니다.' },
        'bow': { fireRate: 600, damage: 25, projectileType: 'arrow', name: '활', critChance: 0.15, critMultiplier: 2, description: '적을 관통하며 15% 확률로 2배의 치명타 피해를 입힙니다.' },
        'flamethrower': { fireRate: 50, damage: 3, projectileType: 'flame', name: '화염방사기', burnDamage: 10, burnDuration: 2000, description: '짧은 거리의 적들을 불태워 2초간 지속 피해를 줍니다.' },
        'chain-lightning': { fireRate: 800, damage: 30, projectileType: 'lightning', name: '연쇄 번개', bounces: 4, description: '적들 사이를 4번 튕기는 번개를 발사합니다.' },
        'black-hole-generator': { fireRate: 2000, damage: 0, projectileType: 'black-hole-orb', name: '블랙홀 생성기', description: '적을 끌어당기고 지속 피해를 주는 소형 블랙홀을 발사합니다.' }
    };
   
    // --- Audio ---
    let audioContext;
    try { audioContext = new (window.AudioContext || window.webkitAudioContext)(); }
    catch (e) { console.error("Web Audio API is not supported in this browser"); }

    function playSound(type, frequency, duration, volume = 0.3) {
        if (!audioContext) return;
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        oscillator.type = type;
        oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
        gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.00001, audioContext.currentTime + duration);
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + duration);
    }
    const sounds = {
        hit: () => playSound('square', 150, 0.1, 0.2),
        shoot: () => playSound('triangle', 440, 0.05, 0.1),
        xp: () => playSound('sine', 600, 0.1, 0.2),
        levelUp: () => playSound('sine', 880, 0.4),
        heal: () => playSound('sine', 700, 0.3),
        dash: () => playSound('sine', 300, 0.2, 0.4),
        explosion: () => playSound('sine', 50, 0.3, 0.5),
        nuke: () => playSound('sine', 100, 1.0, 0.8),
        powerup: () => playSound('sine', 900, 0.2),
        freeze: () => playSound('sawtooth', 200, 0.5, 0.4),
        shieldUp: () => playSound('sine', 1000, 0.2, 0.5),
        shieldDown: () => playSound('square', 100, 0.2, 0.5),
        blackHole: () => playSound('noise', 100, 2, 0.4),
    };
    
    // --- Game State ---
    let gameState = 'start';
    let isPaused = false;
    let selectedDifficulty, selectedWeapon;
    let player, enemies, projectiles, enemyProjectiles, xpGems, healthPacks, nukes, explosions;
    let orbitalShields, speedBoosts, fireRateBoosts, freezeBombs, invincibilityShields, blackHoleItems;
    let drones, explosiveBarrels, blackHoles;
    let damageTexts;
    let timer, gameTime, lastTime, animationFrameId;
    let lastSpawnTime, spawnInterval;
    let bossSpawned, enemiesFrozen, enemiesFrozenTimer;
    let mousePos = { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2 };
    let keysPressed = {};
    let isTouching = false;
    let highScore = Number(localStorage.getItem('neonSurvivorHighScore') || 0);
    let comboCount, lastKillTime;

    // --- Upgrades ---
    const UPGRADES = [
        { id: 'firerate', title: "연사력 강화", description: "공격 속도 20% 증가", apply: p => { p.baseFireRate *= 0.8; p.fireRate = p.baseFireRate;} },
        { id: 'damage', title: "강화 탄환", description: "공격력 25% 증가", apply: p => p.projectileDamage *= 1.25 },
        { id: 'multishot', title: "멀티샷", description: "발사체 수 +1", apply: p => p.projectiles++ },
        { id: 'hp', title: "나노 수리봇", description: "최대 체력 20 증가 및 모두 회복", apply: p => { p.maxHp += 20; p.hp = p.maxHp; } },
        { id: 'speed', title: "고속 추진기", description: "이동 속도 10% 증가", apply: p => { p.baseSpeed *= 1.1; p.speed = p.baseSpeed; } },
        { id: 'shield', title: '궤도 방패', description: '주위를 도는 방패 추가', apply: p => p.shields++ },
        { id: 'explosive', title: '폭발탄', description: '탄환이 명중 시 폭발합니다', apply: p => p.explosiveProjectiles = true },
        { id: 'magnet', title: '경험치 자석', description: '경험치 획득 범위 50% 증가', apply: p => p.pickupRadius *= 1.5 },
        { id: 'drone', title: '컴패니언 드론', description: '플레이어를 돕는 공격 드론을 추가합니다.', apply: p => p.drones = (p.drones || 0) + 1 },
    ];
    let availableUpgrades = [...UPGRADES];
    
    function createInitialPlayer(difficulty, weapon) {
        const difficultySettings = DIFFICULTY_SETTINGS[difficulty];
        const weaponSettings = WEAPON_SETTINGS[weapon];
        
        return {
            x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2,
            hp: difficultySettings.hp, maxHp: difficultySettings.hp,
            xp: 0, level: 1, xpToNextLevel: 10,
            weaponType: weapon,
            fireRate: weaponSettings.fireRate, baseFireRate: weaponSettings.fireRate,
            projectiles: 1, projectileDamage: weaponSettings.damage, projectileType: weaponSettings.projectileType,
            lastShotTime: 0, speed: 200, baseSpeed: 200, pickupRadius: 100,
            dashCooldown: 2000, lastDashTime: 0, isDashing: false, dashDuration: 150, dashSpeed: 700,
            shields: 1, // Start with 1 shield by default
            explosiveProjectiles: false,
            speedBoostTimer: 0, fireRateBoostTimer: 0, invincibilityTimer: 0,
            drones: 0,
            machineGunShotCount: 0,
        };
    }

    function formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
    }

    function togglePause() {
        if (gameState !== 'playing' || levelUpScreen.classList.contains('hidden') === false) return;
        isPaused = !isPaused;
        pauseScreen.classList.toggle('hidden', !isPaused);
        if (!isPaused) {
            lastTime = performance.now();
            requestAnimationFrame(gameLoop);
        }
    }

    function init() {
        const rank = getRank(highScore);
        highscoreUI.innerHTML = `최고기록: ${formatTime(highScore)} <span style="color: ${rank.color}; text-shadow: 0 0 5px ${rank.color};">(${rank.name})</span>`;
        startScreenHighscoreUI.innerHTML = `최고 기록: ${formatTime(highScore)} &bull; 랭크: <span style="color: ${rank.color}; text-shadow: 0 0 8px ${rank.color};">${rank.name}</span>`;
        
        // Auto-select default options to enable start button
        const defaultDifficulty = difficultySelection.querySelector('[data-difficulty="보통"]');
        if (defaultDifficulty) defaultDifficulty.click();
        
        const defaultWeapon = weaponSelection.querySelector('[data-weapon="machine-gun"]');
        if(defaultWeapon) defaultWeapon.click();

        difficultySelection.addEventListener('click', e => {
            if (e.target.tagName === 'BUTTON') {
                selectedDifficulty = e.target.dataset.difficulty;
                [...difficultySelection.children].forEach(btn => btn.classList.remove('selected'));
                e.target.classList.add('selected');
                checkSelections();
            }
        });
        weaponSelection.addEventListener('mouseover', e => {
            if (e.target.tagName === 'BUTTON' && e.target.dataset.weapon) {
                const weaponId = e.target.dataset.weapon;
                const stats = WEAPON_SETTINGS[weaponId];
                const rpm = Math.round(60000 / stats.fireRate); 
                weaponStatsUI.innerHTML = `
                    <h3 class="text-lg text-cyan-300 font-bold">${stats.name}</h3>
                    <p>데미지: ${stats.damage || '특수'}${stats.pellets ? ' x ' + stats.pellets : ''} / 연사속도: ${rpm} RPM</p>
                    <p>특징: ${stats.description}</p>
                `;
            }
        });
        weaponSelection.addEventListener('click', e => {
            if (e.target.tagName === 'BUTTON') {
                selectedWeapon = e.target.dataset.weapon;
                [...weaponSelection.children].forEach(btn => btn.classList.remove('selected'));
                e.target.classList.add('selected');
                checkSelections();
            }
        });

        startButton.onclick = startGame;
        restartButton.onclick = () => {
            gameOverScreen.classList.add('hidden');
            pauseButton.classList.add('hidden');
            startScreen.classList.remove('hidden');
        };
        pauseButton.onclick = togglePause;
        
        resumeButton.onclick = togglePause;
        restartPauseButton.onclick = () => {
            pauseScreen.classList.add('hidden');
            isPaused = false;
            startGame();
        };
        quitButton.onclick = () => {
            pauseScreen.classList.add('hidden');
            isPaused = false;
            gameState = 'start';
            if(animationFrameId) cancelAnimationFrame(animationFrameId);
            startScreen.classList.remove('hidden');
            pauseButton.classList.add('hidden');
        };
        
        // Input Listeners
        window.addEventListener('keydown', e => {
            keysPressed[e.code] = true;
            if (e.key === "Escape") togglePause();
            if (e.code === 'Space' && gameState === 'playing' && !isPaused) {
                const now = performance.now();
                if (now - player.lastDashTime > player.dashCooldown) {
                    player.isDashing = true;
                    player.lastDashTime = now;
                    sounds.dash();
                    setTimeout(() => player.isDashing = false, player.dashDuration);
                }
            }
        });
        window.addEventListener('keyup', e => { keysPressed[e.code] = false; });
        
        const getMousePos = (e) => {
             const rect = canvas.getBoundingClientRect();
             const scaleX = canvas.width / rect.width;
             const scaleY = canvas.height / rect.height;
             const clientX = e.touches ? e.touches[0].clientX : e.clientX;
             const clientY = e.touches ? e.touches[0].clientY : e.clientY;
             return {
                 x: (clientX - rect.left) * scaleX,
                 y: (clientY - rect.top) * scaleY
             };
        }
        canvas.addEventListener('mousemove', e => { if (!isTouching) mousePos = getMousePos(e); });
        canvas.addEventListener('touchstart', e => { isTouching = true; mousePos = getMousePos(e); e.preventDefault(); }, { passive: false });
        canvas.addEventListener('touchmove', e => { mousePos = getMousePos(e); e.preventDefault(); }, { passive: false });
        canvas.addEventListener('touchend', () => { isTouching = false; });

        // Auto-pause when tab is hidden
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && gameState === 'playing' && !isPaused) {
                togglePause();
            }
        });
    }

    function checkSelections() {
        startButton.disabled = !(selectedDifficulty && selectedWeapon);
    }
    
    function spawnExplosiveBarrel() {
        const size = 30;
        const x = Math.random() * (CANVAS_WIDTH - size) + size / 2;
        const y = Math.random() * (CANVAS_HEIGHT - size) + size / 2;
        const distToPlayer = Math.sqrt((x - player.x)**2 + (y-player.y)**2);
        if(distToPlayer < 150) { // Don't spawn too close
            spawnExplosiveBarrel();
            return;
        }
        explosiveBarrels.push({ x, y, size, hp: 10, color: '#cc3300' });
    }

    function startGame() {
        player = createInitialPlayer(selectedDifficulty, selectedWeapon);
        
        enemies = [];
        projectiles = [];
        enemyProjectiles = [];
        xpGems = [];
        healthPacks = [];
        nukes = [];
        explosions = [];
        orbitalShields = [];
        speedBoosts = [];
        fireRateBoosts = [];
        freezeBombs = [];
        invincibilityShields = [];
        blackHoleItems = [];
        drones = [];
        explosiveBarrels = [];
        blackHoles = [];
        damageTexts = [];
        availableUpgrades = [...UPGRADES];

        if (player.shields > 0) {
            for(let i=0; i<player.shields; i++){
                 orbitalShields.push({
                    angle: (i * Math.PI * 2) / player.shields, radius: 50, speed: 3, size: 15,
                    color: '#FF00FF', damage: 25, lastHitTime: 0
                });
            }
        }
        
        timer = 0;
        gameTime = 0;
        lastSpawnTime = 0;
        spawnInterval = 4000 * DIFFICULTY_SETTINGS[selectedDifficulty].spawnRateMult;
        bossSpawned = false;
        enemiesFrozen = false;
        enemiesFrozenTimer = 0;
        comboCount = 0;
        lastKillTime = 0;
        lastTime = performance.now();
        gameState = 'playing';
        isPaused = false;

        startScreen.classList.add('hidden');
        gameOverScreen.classList.add('hidden');
        levelUpScreen.classList.add('hidden');
        pauseScreen.classList.add('hidden');
        pauseButton.classList.remove('hidden');
        
        updateUI();
        if (animationFrameId) cancelAnimationFrame(animationFrameId);
        gameLoop(performance.now());
    }
    
    function updateDrones(deltaTime) {
        const now = performance.now();
        const dt = deltaTime / 1000;
        
        // Add new drones if player upgraded
        while(drones.length < player.drones) {
            drones.push({
                x: player.x, y: player.y, angle: Math.random() * Math.PI * 2,
                radius: 70, size: 10, fireRate: 1000, lastShotTime: 0,
            });
        }

        drones.forEach(drone => {
            drone.angle += 2 * dt;
            drone.x = player.x + Math.cos(drone.angle) * drone.radius;
            drone.y = player.y + Math.sin(drone.angle) * drone.radius;

            if (now - drone.lastShotTime > drone.fireRate) {
                const nearestEnemy = findNearestEnemy(drone);
                if (nearestEnemy) {
                    drone.lastShotTime = now;
                    const dx = nearestEnemy.x - drone.x;
                    const dy = nearestEnemy.y - drone.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    projectiles.push({
                        x: drone.x, y: drone.y,
                        dx: (dx/dist) * 360, dy: (dy/dist) * 360,
                        type: 'drone-bullet', damage: 8, lifespan: 1000, color: '#f0f0f0'
                    });
                }
            }
        });
    }

    function updateBlackHoles(deltaTime) {
        const dt = deltaTime / 1000;
        const now = performance.now();
        blackHoles.forEach((bh, index) => {
            bh.age += deltaTime;
            bh.rotation += 5 * dt;
            if (bh.age >= bh.duration) {
                explosions.push({ x: bh.x, y: bh.y, radius: bh.pullRadius * 1.2, duration: 400, alpha: 1, damage: 200 });
                sounds.explosion();
                blackHoles.splice(index, 1);
                return;
            }

            const doDamage = bh.damage && now - (bh.lastDamageTime || 0) > 500; // damage every 0.5s
            if (doDamage) bh.lastDamageTime = now;

            enemies.forEach(e => {
                if (e.isBoss) return;
                const dx = bh.x - e.x;
                const dy = bh.y - e.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < bh.pullRadius) {
                    if (dist > 10) {
                        const pullForce = (1 - (dist / bh.pullRadius)) * bh.strength;
                        e.x += (dx / dist) * pullForce * dt;
                        e.y += (dy / dist) * pullForce * dt;
                    }
                    if (doDamage) {
                        e.hp -= bh.damage;
                        createDamageText(e.x, e.y, bh.damage);
                    }
                }
            });
        });
    }

    function update(deltaTime) {
        if (isPaused || gameState !== 'playing') return;
        const now = performance.now();
        gameTime += deltaTime;
        timer = Math.floor(gameTime / 1000);
        
        if(now - lastKillTime > COMBO_TIMEOUT && comboCount > 0) {
            comboCount = 0;
        }

        // Update Timers
        if (player.speedBoostTimer > 0) { player.speedBoostTimer -= deltaTime; if (player.speedBoostTimer <= 0) player.speed = player.baseSpeed; }
        if (player.fireRateBoostTimer > 0) { player.fireRateBoostTimer -= deltaTime; if (player.fireRateBoostTimer <= 0) player.fireRate = player.baseFireRate; }
        if (player.invincibilityTimer > 0) { player.invincibilityTimer -= deltaTime; }
        if (enemiesFrozenTimer > 0) { enemiesFrozenTimer -= deltaTime; if (enemiesFrozenTimer <= 0) enemiesFrozen = false; }
        
        const dt = deltaTime / 1000;

        // Player Movement
        let moveX = 0, moveY = 0;
        if (keysPressed['KeyW'] || keysPressed['ArrowUp']) moveY -= 1;
        if (keysPressed['KeyS'] || keysPressed['ArrowDown']) moveY += 1;
        if (keysPressed['KeyA'] || keysPressed['ArrowLeft']) moveX -= 1;
        if (keysPressed['KeyD'] || keysPressed['ArrowRight']) moveX += 1;
        
        let currentSpeed = player.isDashing ? player.dashSpeed : player.speed;
        
        if (moveX !== 0 || moveY !== 0) {
            const mag = Math.sqrt(moveX * moveX + moveY * moveY);
            player.x += (moveX / mag) * currentSpeed * dt;
            player.y += (moveY / mag) * currentSpeed * dt;
        } else if(isTouching) {
            const dx = mousePos.x - player.x;
            const dy = mousePos.y - player.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist > 1) {
                const moveAmount = currentSpeed * dt;
                if (dist > moveAmount) {
                    player.x += (dx / dist) * moveAmount;
                    player.y += (dy / dist) * moveAmount;
                } else {
                    player.x = mousePos.x;
                    player.y = mousePos.y;
                }
            }
        }

        player.x = Math.max(PLAYER_SIZE / 2, Math.min(CANVAS_WIDTH - PLAYER_SIZE / 2, player.x));
        player.y = Math.max(PLAYER_SIZE / 2, Math.min(CANVAS_HEIGHT - PLAYER_SIZE / 2, player.y));
        
        updateEnemySpawning(gameTime);
        if (!enemiesFrozen) {
            updateEnemies(dt, deltaTime);
        }
        updateProjectiles(deltaTime);
        updateXPGems(dt);
        updateExplosions(dt);
        updateOrbitalShields(dt);
        updateDrones(deltaTime);
        updateBlackHoles(deltaTime);
        updateDamageText(deltaTime);


        handleCollisions();

        // Cleanup dead enemies from various damage sources (DoT, blackholes)
        for(let i = enemies.length - 1; i >= 0; i--) {
            if (enemies[i].hp <= 0) {
                onEnemyKilled(enemies[i]);
                enemies.splice(i, 1);
            }
        }

        if (player.hp <= 0) {
            if (timer > highScore) {
                highScore = timer;
                localStorage.setItem('neonSurvivorHighScore', timer);
            }
            gameState = 'gameOver';
            showGameOverScreen();
        }

        if (player.xp >= player.xpToNextLevel) {
            handleLevelUp();
        }
        
        updateUI();
    }
    
    function draw() {
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        ctx.shadowBlur = 10;

        explosiveBarrels.forEach(barrel => {
            ctx.fillStyle = barrel.color;
            ctx.shadowColor = barrel.color;
            ctx.fillRect(barrel.x - barrel.size / 2, barrel.y - barrel.size / 2, barrel.size, barrel.size);
            ctx.strokeStyle = '#ff6633';
            ctx.strokeRect(barrel.x - barrel.size / 2, barrel.y - barrel.size / 2, barrel.size, barrel.size);
        });

        blackHoles.forEach(bh => {
            const pullProgress = bh.age / bh.duration;
            ctx.save();
            ctx.translate(bh.x, bh.y);
            ctx.beginPath();
            ctx.arc(0, 0, 20 + pullProgress * 20, 0, Math.PI * 2);
            ctx.fillStyle = 'black';
            ctx.fill();
            ctx.shadowColor = '#c084fc';
            ctx.lineWidth = 3;
            for(let i=0; i < 3; i++) {
                ctx.beginPath();
                const startAngle = bh.rotation + (i * Math.PI * 2 / 3);
                const endAngle = startAngle + Math.PI * 0.8;
                ctx.arc(0, 0, 40 + i * 15 + pullProgress * 50, startAngle, endAngle);
                ctx.strokeStyle = `rgba(192, 132, 252, ${1 - pullProgress})`;
                ctx.stroke();
            }
            ctx.restore();
        });

        const itemFont = 'bold 20px sans-serif';
        const drawItem = (item, text, color) => {
            ctx.font = itemFont; ctx.fillStyle = color; ctx.shadowColor = color;
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(text, item.x, item.y);
        };
        healthPacks.forEach(pack => drawItem(pack, '+', '#FF4444'));
        nukes.forEach(nuke => drawItem(nuke, 'N', '#FFFF00'));
        speedBoosts.forEach(item => drawItem(item, 'S', '#00FFFF'));
        fireRateBoosts.forEach(item => drawItem(item, 'F', '#FFA500'));
        freezeBombs.forEach(item => drawItem(item, '❄️', '#87CEEB'));
        invincibilityShields.forEach(item => drawItem(item, '✨', '#F0E68C'));
        blackHoleItems.forEach(item => drawItem(item, '◎', '#c084fc'));
        
        xpGems.forEach(gem => {
            ctx.beginPath(); ctx.arc(gem.x, gem.y, 5, 0, Math.PI * 2);
            ctx.fillStyle = '#39FF14'; ctx.shadowColor = '#39FF14'; ctx.fill();
        });

        // Player Invincibility Shield
        if (player.invincibilityTimer > 0) {
            ctx.beginPath();
            ctx.arc(player.x, player.y, PLAYER_SIZE, 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(255, 255, 0, ${0.5 + Math.sin(Date.now()/100)*0.2})`;
            ctx.lineWidth = 3;
            ctx.stroke();
        }

        ctx.fillStyle = player.isDashing ? '#FFFFFF' : '#00FFFF';
        ctx.shadowColor = player.isDashing ? '#FFFFFF' : '#00FFFF';
        ctx.fillRect(player.x - PLAYER_SIZE / 2, player.y - PLAYER_SIZE / 2, PLAYER_SIZE, PLAYER_SIZE);
        
        orbitalShields.forEach(s => {
            ctx.beginPath(); ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
            ctx.fillStyle = s.color; ctx.shadowColor = s.color; ctx.fill();
        });
        
        drones.forEach(drone => {
            ctx.fillStyle = '#f0f0f0';
            ctx.shadowColor = '#f0f0f0';
            ctx.beginPath();
            ctx.arc(drone.x, drone.y, drone.size, 0, Math.PI * 2);
            ctx.fill();
        });
        
        projectiles.forEach(p => {
            ctx.shadowColor = p.color;
            if (p.type === 'lightning') {
                ctx.strokeStyle = '#9400D3';
                ctx.lineWidth = 3;
                ctx.beginPath();
                let lastPos = { x: player.x, y: player.y };
                if (p.bounceHistory.length > 0) {
                    p.bounceHistory.forEach(enemy => {
                        ctx.moveTo(lastPos.x, lastPos.y);
                        ctx.lineTo(enemy.x, enemy.y);
                        lastPos = { x: enemy.x, y: enemy.y };
                    });
                } else if (p.target) {
                     ctx.moveTo(player.x, player.y);
                     ctx.lineTo(p.target.x, p.target.y);
                }
                ctx.stroke();
                return;
            }
            if (p.type === 'flame') {
                const angle = Math.atan2(p.dy, p.dx);
                const length = 40;
                const width = 20;
                ctx.save();
                ctx.translate(p.x, p.y);
                ctx.rotate(angle);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(length, -width / 2);
                ctx.lineTo(length, width / 2);
                ctx.closePath();
                const grad = ctx.createLinearGradient(0, 0, length, 0);
                grad.addColorStop(0, `rgba(255,165,0,${p.lifespan/200})`);
                grad.addColorStop(1, 'rgba(255,69,0,0)');
                ctx.fillStyle = grad;
                ctx.shadowColor = 'orange';
                ctx.fill();
                ctx.restore();
            } else if (p.type === 'laser' || p.type === 'arrow') {
                ctx.strokeStyle = p.color;
                ctx.lineWidth = p.type === 'laser' ? 4 : 2;
                ctx.beginPath();
                const angle = Math.atan2(p.dy, p.dx);
                const length = p.type === 'laser' ? 15 : 10;
                ctx.moveTo(p.x - Math.cos(angle) * length, p.y - Math.sin(angle) * length);
                ctx.lineTo(p.x + Math.cos(angle) * length, p.y + Math.sin(angle) * length);
                ctx.stroke();
            } else {
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size || 5, 0, Math.PI * 2);
                ctx.fill();
            }
        });

        enemies.forEach(e => {
            ctx.fillStyle = enemiesFrozen ? '#ADD8E6' : e.color;
            ctx.shadowColor = enemiesFrozen ? '#ADD8E6' : e.color;
            ctx.beginPath();
            if (e.shape === 'triangle') {
                const side = e.size * 1.5;
                ctx.moveTo(e.x, e.y - side * 0.58);
                ctx.lineTo(e.x - side / 2, e.y + side * 0.29);
                ctx.lineTo(e.x + side / 2, e.y + side * 0.29);
                ctx.closePath();
            } else { // square
                ctx.rect(e.x - e.size / 2, e.y - e.size / 2, e.size, e.size);
            }
            ctx.fill();
            
            // Health bar for tank/boss
            if(e.type === 'tank' || e.isBoss) {
                const hpPercentage = e.hp / (ENEMY_TYPES[e.type].hp * DIFFICULTY_SETTINGS[selectedDifficulty].enemyHpMult);
                ctx.fillStyle = '#444';
                ctx.fillRect(e.x - e.size/2, e.y - e.size/2 - 10, e.size, 5);
                ctx.fillStyle = '#f00';
                ctx.fillRect(e.x - e.size/2, e.y - e.size/2 - 10, e.size * hpPercentage, 5);
            }
        });

        enemyProjectiles.forEach(p => {
            ctx.fillStyle = p.color;
            ctx.shadowColor = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fill();
        });

        explosions.forEach(exp => {
            ctx.beginPath();
            ctx.arc(exp.x, exp.y, exp.radius * (1 - exp.alpha), 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255, 165, 0, ${exp.alpha})`;
            ctx.shadowColor = 'orange';
            ctx.fill();
        });

        damageTexts.forEach(dt => {
            ctx.font = dt.crit ? 'bold 20px Orbitron' : 'bold 16px Orbitron';
            ctx.fillStyle = `rgba(255, ${dt.crit ? 100 : 255}, 102, ${dt.alpha})`;
            ctx.shadowColor = dt.crit ? 'orange' : 'yellow';
            ctx.textAlign = 'center';
            ctx.fillText(dt.text, dt.x, dt.y);
        });

        // Cursor
        if (gameState === 'playing' && !isPaused && !isTouching) {
            ctx.strokeStyle = '#FFF';
            ctx.shadowColor = '#FFF';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(mousePos.x - 10, mousePos.y);
            ctx.lineTo(mousePos.x + 10, mousePos.y);
            ctx.moveTo(mousePos.x, mousePos.y - 10);
            ctx.lineTo(mousePos.x, mousePos.y + 10);
            ctx.stroke();
        }
        ctx.shadowBlur = 0;
    }
    
    function findNearestEnemy(from, excludeList = []) {
        let nearest = null;
        let nearestDist = Infinity;
        enemies.forEach(e => {
            if (excludeList.includes(e)) return;
            const dist = Math.sqrt((from.x - e.x) ** 2 + (from.y - e.y) ** 2);
            if (dist < nearestDist) {
                nearest = e;
                nearestDist = dist;
            }
        });
        return nearest;
    }

    function createDamageText(x, y, amount, isCrit = false) {
        damageTexts.push({ x, y, text: Math.round(amount), alpha: 1, duration: 500, startTime: performance.now(), crit: isCrit });
    }
    
    function updateDamageText(deltaTime) {
        damageTexts.forEach((dt, index) => {
            dt.y -= 30 * (deltaTime / 1000);
            dt.alpha = 1 - (performance.now() - dt.startTime) / dt.duration;
            if (dt.alpha <= 0) {
                damageTexts.splice(index, 1);
            }
        });
    }

    function updateEnemySpawning(gameTime) {
        const now = performance.now();
        if (now - lastSpawnTime > spawnInterval) {
            lastSpawnTime = now;
            spawnInterval = Math.max(500, spawnInterval * 0.98);
            const waveSize = 1 + Math.floor(timer / 10);
            for (let i = 0; i < waveSize; i++) {
                const angle = Math.random() * Math.PI * 2;
                const x = player.x + Math.cos(angle) * (CANVAS_WIDTH / 2 + 50);
                const y = player.y + Math.sin(angle) * (CANVAS_HEIGHT / 2 + 50);

                let enemyType = 'grunt';
                if (timer > 20 && Math.random() < 0.3) enemyType = 'shooter';
                if (timer > 40 && Math.random() < 0.2) enemyType = 'tank';
                if (timer > 60 && Math.random() < 0.2) enemyType = 'bomber';
                if (timer > 90 && Math.random() < 0.1) enemyType = 'summoner';
                
                const baseStats = ENEMY_TYPES[enemyType];
                const difficultyMult = DIFFICULTY_SETTINGS[selectedDifficulty];

                enemies.push({
                    x, y, ...baseStats,
                    hp: baseStats.hp * difficultyMult.enemyHpMult * (1 + timer / 60),
                    speed: baseStats.speed * difficultyMult.enemySpeedMult,
                    lastActionTime: 0,
                    type: enemyType
                });
            }
        }
        // Boss spawn
        if (timer > 180 && !bossSpawned) {
             bossSpawned = true;
             const baseStats = ENEMY_TYPES['boss'];
             const difficultyMult = DIFFICULTY_SETTINGS[selectedDifficulty];
             enemies.push({
                 x: CANVAS_WIDTH / 2, y: 50, ...baseStats,
                 hp: baseStats.hp * difficultyMult.enemyHpMult,
                 speed: baseStats.speed * difficultyMult.enemySpeedMult,
                 isBoss: true, lastActionTime: 0, type: 'boss'
             });
        }

        // Player Shooting
        if (now - player.lastShotTime > player.fireRate) {
            player.lastShotTime = now;
            sounds.shoot();
            
            const dx = mousePos.x - player.x;
            const dy = mousePos.y - player.y;
            const dist = Math.sqrt(dx * dx + dy * dy) || 1;

            for (let i = 0; i < player.projectiles; i++) {
                let angleOffset = 0;
                if(player.projectiles > 1) {
                    angleOffset = (i - (player.projectiles - 1) / 2) * 0.15; // 0.15 radians spread
                }
                const angle = Math.atan2(dy, dx) + angleOffset;
                createProjectile(player.x, player.y, Math.cos(angle), Math.sin(angle), player.projectileType);
            }
        }
    }

    function createProjectile(x, y, dx, dy, type) {
        const weaponStats = WEAPON_SETTINGS[player.weaponType];
        const baseProjectile = { x, y, dx, dy, damage: player.projectileDamage, lifespan: 1000, color: '#FFD700', size: 5, owner: 'player'};
        let speed = 400;

        switch (type) {
            case 'bullet':
                player.machineGunShotCount = (player.machineGunShotCount + 1) % 8;
                const isEnhanced = player.machineGunShotCount === 0;
                projectiles.push({
                    ...baseProjectile, type,
                    dx: dx * speed, dy: dy * speed,
                    damage: isEnhanced ? baseProjectile.damage * 2 : baseProjectile.damage,
                    size: isEnhanced ? 8 : 5,
                    color: isEnhanced ? '#ff8c00' : '#FFD700',
                    knockback: isEnhanced ? weaponStats.knockback : 0,
                });
                break;
            case 'missile':
                projectiles.push({ ...baseProjectile, type, dx: dx * 150, dy: dy * 150, lifespan: 3000, turnSpeed: 5, speed: 150 });
                break;
            case 'bomb':
                projectiles.push({ ...baseProjectile, type, dx: dx * 200, dy: dy * 200 - 150, gravity: 400, lifespan: 2000 });
                break;
            case 'pellet':
                for(let i=0; i<weaponStats.pellets; i++) {
                    const spreadAngle = (Math.random() - 0.5) * weaponStats.spread;
                    const angle = Math.atan2(dy, dx) + spreadAngle;
                    projectiles.push({
                        ...baseProjectile, type,
                        dx: Math.cos(angle) * speed, dy: Math.sin(angle) * speed,
                        lifespan: 400,
                        knockback: weaponStats.knockback,
                    });
                }
                break;
            case 'laser':
                 projectiles.push({ ...baseProjectile, type, dx: dx * 800, dy: dy * 800, lifespan: 1200, color: '#ff00ff', pierced: [], slowAmount: weaponStats.slowAmount, slowDuration: weaponStats.slowDuration });
                 break;
            case 'arrow':
                projectiles.push({ ...baseProjectile, type, dx: dx * 800, dy: dy * 800, lifespan: 1200, color: '#add8e6', pierced: [], critChance: weaponStats.critChance, critMultiplier: weaponStats.critMultiplier });
                break;
            case 'flame':
                projectiles.push({ ...baseProjectile, type, dx, dy, lifespan: 200, color: 'orange', pierced: [], burnDamage: weaponStats.burnDamage, burnDuration: weaponStats.burnDuration });
                break;
            case 'lightning':
                const nearestEnemy = findNearestEnemy(player);
                if (nearestEnemy) {
                    projectiles.push({
                        ...baseProjectile, type,
                        target: nearestEnemy,
                        bounces: weaponStats.bounces,
                        bounceHistory: [], // Will be populated in collision check
                        lifespan: 250, // Longer lifespan to be visible
                        processed: false,
                    });
                }
                break;
            case 'black-hole-orb':
                projectiles.push({ ...baseProjectile, type, dx: dx * 150, dy: dy * 150, lifespan: 2000, color: '#5a008a', size: 8 });
                break;
        }
    }

    function updateEnemies(dt, deltaTime) {
        const now = performance.now();
        enemies.forEach((e, index) => {
            let currentSpeed = e.speed;
            
            // Handle slow
            if (e.slowTimer > 0) {
                e.slowTimer -= deltaTime;
                currentSpeed *= (1 - e.slowAmount);
                if (e.slowTimer <= 0) {
                    delete e.slowTimer;
                    delete e.slowAmount;
                }
            }
            
            // Handle burn
            if (e.burnTimer > 0) {
                e.burnTimer -= deltaTime;
                if (now - (e.lastBurnTick || 0) > 500) { // burn tick every 500ms
                    e.hp -= e.burnDamage;
                    createDamageText(e.x, e.y, e.burnDamage);
                    e.lastBurnTick = now;
                }
                if (e.burnTimer <= 0) {
                    delete e.burnTimer;
                    delete e.burnDamage;
                    delete e.lastBurnTick;
                }
            }

            const dx = player.x - e.x;
            const dy = player.y - e.y;
            const dist = Math.sqrt(dx * dx + dy * dy) || 1;
            e.x += (dx / dist) * currentSpeed * dt;
            e.y += (dy / dist) * currentSpeed * dt;

            // Enemy actions
            if (now - e.lastActionTime > (e.fireRate || e.actionRate)) {
                 e.lastActionTime = now;
                 if (e.type === 'shooter' || e.isBoss) {
                     enemyProjectiles.push({
                         x: e.x, y: e.y,
                         dx: (dx/dist) * e.projectileSpeed, dy: (dy/dist) * e.projectileSpeed,
                         damage: e.damage, size: 8, color: '#f08080', lifespan: 3000
                     });
                 }
                 if (e.action === 'summon') {
                    for(let i=0; i<2; i++){
                       const spawnX = e.x + (Math.random() - 0.5) * 50;
                       const spawnY = e.y + (Math.random() - 0.5) * 50;
                       const baseStats = ENEMY_TYPES['grunt'];
                       enemies.push({ ...baseStats, x: spawnX, y: spawnY, hp: baseStats.hp/2, type: 'grunt'});
                    }
                 }
            }
        });
    }

    function updateProjectiles(deltaTime) {
        const dt = deltaTime / 1000;
        projectiles.forEach((p, index) => {
            p.lifespan -= deltaTime;
            if (p.lifespan <= 0 || p.x < -10 || p.x > CANVAS_WIDTH + 10 || p.y < -10 || p.y > CANVAS_HEIGHT + 10) {
                if (p.type === 'missile' || p.type === 'bomb') {
                    const weaponId = p.type === 'missile' ? 'missile' : 'bomb';
                    const weaponStats = WEAPON_SETTINGS[weaponId];
                    explosions.push({ x: p.x, y: p.y, radius: weaponStats.explosionRadius || 40, duration: 300, alpha: 1, damage: p.damage });
                    sounds.explosion();

                     if (p.type === 'bomb' && weaponStats.shrapnelCount > 0) {
                        for(let i=0; i < weaponStats.shrapnelCount; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            projectiles.push({
                                x: p.x, y: p.y,
                                dx: Math.cos(angle) * 300, dy: Math.sin(angle) * 300,
                                type: 'pellet', damage: 5, lifespan: 300, color: '#FFA500', size: 3,
                                knockback: 0
                            });
                        }
                    }
                }
                if (p.type === 'black-hole-orb') {
                    blackHoles.push({ x: p.x, y: p.y, pullRadius: 150, strength: 200, duration: 3000, age: 0, rotation: 0, damage: 5, lastDamageTime: 0});
                    sounds.blackHole();
                }

                projectiles.splice(index, 1);
                return;
            }

            if (p.type === 'missile') {
                const nearest = findNearestEnemy(p);
                if (nearest) {
                    const dx = nearest.x - p.x;
                    const dy = nearest.y - p.y;
                    const angle = Math.atan2(dy, dx);
                    const pAngle = Math.atan2(p.dy, p.dx);
                    let angleDiff = angle - pAngle;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

                    const newAngle = pAngle + Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), p.turnSpeed * dt);
                    p.dx = Math.cos(newAngle) * p.speed;
                    p.dy = Math.sin(newAngle) * p.speed;
                }
                p.speed = Math.min(p.speed + 100 * dt, 400);
            }
            if (p.type === 'bomb') {
                p.dy += p.gravity * dt;
            }
            if (p.type !== 'flame' && p.type !== 'lightning') { // Flames have static position relative to player
                 p.x += p.dx * dt;
                 p.y += p.dy * dt;
            } else if (p.type === 'flame') {
                const angle = Math.atan2(p.dy, p.dx);
                p.x = player.x + Math.cos(angle) * 20;
                p.y = player.y + Math.sin(angle) * 20;
            }
        });
        
        enemyProjectiles.forEach((p, index) => {
             p.lifespan -= deltaTime;
             if (p.lifespan <= 0) {
                 enemyProjectiles.splice(index, 1);
                 return;
             }
             p.x += p.dx * dt;
             p.y += p.dy * dt;
        });
    }

    function updateXPGems(dt) {
        xpGems.forEach((gem, index) => {
            const dx = player.x - gem.x;
            const dy = player.y - gem.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < player.pickupRadius) {
                if (dist < 10) {
                    player.xp += gem.value;
                    xpGems.splice(index, 1);
                    sounds.xp();
                } else {
                    gem.x += (dx / dist) * 300 * dt;
                    gem.y += (dy / dist) * 300 * dt;
                }
            }
        });
    }

    function updateExplosions(dt) {
        explosions.forEach((exp, index) => {
            exp.alpha -= (1 / exp.duration) * (dt*1000);
            if (exp.alpha <= 0) {
                explosions.splice(index, 1);
            }
        });
    }
    
    function updateOrbitalShields(dt) {
        while(orbitalShields.length < player.shields) {
            orbitalShields.push({
                angle: Math.random() * Math.PI * 2, radius: 50, speed: 3, size: 15,
                color: '#FF00FF', damage: 25, lastHitTime: 0
            });
        }
         while(orbitalShields.length > player.shields) {
            orbitalShields.pop();
        }
        
        const angleIncrement = Math.PI * 2 / Math.max(1, orbitalShields.length);
        orbitalShields.forEach((s, i) => {
            s.angle += s.speed * dt;
            s.x = player.x + Math.cos(s.angle + i * angleIncrement) * s.radius;
            s.y = player.y + Math.sin(s.angle + i * angleIncrement) * s.radius;
        });
    }
    
    function onEnemyKilled(enemy) {
        xpGems.push({ x: enemy.x, y: enemy.y, value: enemy.xp });
        lastKillTime = performance.now();
        comboCount++;

        // Drop items
        if (Math.random() < 0.05) healthPacks.push({ x: enemy.x, y: enemy.y, size: 15 });
        if (Math.random() < 0.01) nukes.push({ x: enemy.x, y: enemy.y, size: 20 });
        if (Math.random() < 0.02) speedBoosts.push({ x: enemy.x, y: enemy.y, size: 15 });
        if (Math.random() < 0.02) fireRateBoosts.push({ x: enemy.x, y: enemy.y, size: 15 });
        if (Math.random() < 0.015) freezeBombs.push({ x: enemy.x, y: enemy.y, size: 15 });
        if (Math.random() < 0.01) invincibilityShields.push({ x: enemy.x, y: enemy.y, size: 15 });
        if (Math.random() < 0.005) blackHoleItems.push({ x: enemy.x, y: enemy.y, size: 15 });
        
        if (enemy.onDeath === 'explode') {
             explosions.push({ x: enemy.x, y: enemy.y, radius: 80, duration: 300, alpha: 1, damage: enemy.damage });
             sounds.explosion();
        }
    }

    function handleCollisions() {
        const now = performance.now();
        // Projectile - Enemy
        for (let pIndex = projectiles.length - 1; pIndex >= 0; pIndex--) {
            const p = projectiles[pIndex];
            if (p.type === 'lightning') {
                 if (!p.processed) {
                     p.processed = true;
                     let currentTarget = p.target;
                     let bounceList = [];
                     for (let i = 0; i < p.bounces; i++) {
                         if (!currentTarget || currentTarget.hp <= 0) break;
                         bounceList.push(currentTarget);
                         
                         currentTarget.hp -= p.damage;
                         createDamageText(currentTarget.x, currentTarget.y, p.damage);
                         
                         const nextTarget = findNearestEnemy(currentTarget, bounceList);
                         if (nextTarget) {
                             currentTarget = nextTarget;
                         } else {
                             break;
                         }
                     }
                     p.bounceHistory = bounceList;
                 }
                 continue;
            }

            for (let eIndex = enemies.length - 1; eIndex >= 0; eIndex--) {
                const e = enemies[eIndex];
                const dist = Math.sqrt((p.x - e.x) ** 2 + (p.y - e.y) ** 2);
                if (dist < e.size / 2 + p.size / 2) {
                    let damage = p.damage;
                    let isCrit = false;
                    
                    if (p.critChance && Math.random() < p.critChance) {
                        damage *= p.critMultiplier;
                        isCrit = true;
                    }
                    createDamageText(e.x, e.y, damage, isCrit);
                    e.hp -= damage;
                    sounds.hit();
                    
                    if (p.knockback) {
                        const angle = Math.atan2(e.y - p.y, e.x - p.x);
                        e.x += Math.cos(angle) * p.knockback * 0.1;
                        e.y += Math.sin(angle) * p.knockback * 0.1;
                    }
                    if (p.slowAmount) {
                        e.slowTimer = p.slowDuration;
                        e.slowAmount = p.slowAmount;
                    }
                    if (p.burnDamage) {
                        e.burnTimer = (e.burnTimer || 0) + p.burnDuration;
                        e.burnDamage = p.burnDamage;
                    }

                    const isPenetrating = p.type === 'laser' || p.type === 'arrow' || p.type === 'flame';
                    if (isPenetrating) {
                        if (!p.pierced.includes(e)) {
                            p.pierced.push(e);
                        } else {
                            continue;
                        }
                    } else {
                        if(player.explosiveProjectiles && p.type !== 'missile' && p.type !== 'bomb') {
                             explosions.push({ x: p.x, y: p.y, radius: 30, duration: 200, alpha: 1, damage: p.damage / 2 });
                        }
                        projectiles.splice(pIndex, 1);
                        break; 
                    }
                }
            }
        }


        // Player - Enemy
        if (player.invincibilityTimer <= 0 && !player.isDashing) {
            enemies.forEach(e => {
                const dist = Math.sqrt((player.x - e.x) ** 2 + (player.y - e.y) ** 2);
                if (dist < PLAYER_SIZE / 2 + e.size / 2) {
                    player.hp -= e.damage;
                    sounds.hit();
                    player.invincibilityTimer = 500; // 0.5s invincibility after hit
                }
            });
        }
        
        // Player - Enemy Projectiles
         if (player.invincibilityTimer <= 0 && !player.isDashing) {
            enemyProjectiles.forEach((p, index) => {
                const dist = Math.sqrt((player.x - p.x) ** 2 + (player.y - p.y) ** 2);
                 if (dist < PLAYER_SIZE / 2 + p.size / 2) {
                    player.hp -= p.damage;
                    sounds.hit();
                    player.invincibilityTimer = 500;
                    enemyProjectiles.splice(index, 1);
                 }
            });
         }

        // Orbital Shield - Enemy
        orbitalShields.forEach(s => {
             enemies.forEach((e, eIndex) => {
                if(now - s.lastHitTime < 500) return;
                const dist = Math.sqrt((s.x - e.x)**2 + (s.y - e.y)**2);
                if (dist < s.size/2 + e.size/2) {
                    s.lastHitTime = now;
                    e.hp -= s.damage;
                    createDamageText(e.x, e.y, s.damage);
                }
            });
        });

        // Explosions - Enemy
        explosions.forEach(exp => {
             if (exp.processed) return;
             enemies.forEach((e, eIndex) => {
                 const dist = Math.sqrt((exp.x - e.x)**2 + (exp.y - e.y)**2);
                 if (dist < exp.radius + e.size/2) {
                     e.hp -= exp.damage;
                     createDamageText(e.x, e.y, exp.damage);
                 }
             });
             exp.processed = true;
        });

        // Player - Items
        const checkItemPickup = (items, onPickup) => {
            items.forEach((item, index) => {
                const dist = Math.sqrt((player.x - item.x)**2 + (player.y - item.y)**2);
                if (dist < PLAYER_SIZE/2 + item.size/2) {
                    onPickup(item);
                    items.splice(index, 1);
                }
            });
        };

        checkItemPickup(healthPacks, () => { player.hp = Math.min(player.maxHp, player.hp + 20); sounds.heal(); });
        checkItemPickup(nukes, () => { enemies.forEach(e => { e.hp = 0; createDamageText(e.x, e.y, 9999); }); sounds.nuke(); });
        checkItemPickup(speedBoosts, () => { player.speedBoostTimer = 5000; player.speed = player.baseSpeed * 1.5; sounds.powerup(); });
        checkItemPickup(fireRateBoosts, () => { player.fireRateBoostTimer = 5000; player.fireRate = player.baseFireRate * 0.5; sounds.powerup(); });
        checkItemPickup(freezeBombs, () => { enemiesFrozen = true; enemiesFrozenTimer = 5000; sounds.freeze(); });
        checkItemPickup(invincibilityShields, () => { player.invincibilityTimer = 5000; sounds.shieldUp(); });
        checkItemPickup(blackHoleItems, (item) => {
             blackHoles.push({ x: item.x, y: item.y, pullRadius: 200, strength: 250, duration: 5000, age: 0, rotation: 0});
             sounds.blackHole();
        });
    }

    function handleLevelUp() {
        player.xp -= player.xpToNextLevel;
        player.level++;
        player.xpToNextLevel = Math.floor(player.xpToNextLevel * 1.4);
        sounds.levelUp();
        
        isPaused = true;
        levelUpScreen.classList.remove('hidden');
        levelUpOptionsContainer.innerHTML = '';

        const upgradeChoices = [];
        const shuffledUpgrades = [...availableUpgrades].sort(() => 0.5 - Math.random());
        
        for (let i = 0; i < Math.min(3, shuffledUpgrades.length); i++) {
            upgradeChoices.push(shuffledUpgrades[i]);
        }
        
        upgradeChoices.forEach(upgrade => {
            const card = document.createElement('div');
            card.className = 'p-4 rounded-lg upgrade-card flex flex-col items-center justify-center text-center';
            card.innerHTML = `<h3 class="text-2xl font-bold mb-2 text-glow">${upgrade.title}</h3><p class="text-gray-300">${upgrade.description}</p>`;
            card.onclick = () => {
                upgrade.apply(player);
                if (upgrade.id === 'shield') {
                    // Update shield visuals immediately
                    orbitalShields = [];
                    for(let i=0; i<player.shields; i++){
                         orbitalShields.push({
                            angle: (i * Math.PI * 2) / player.shields, radius: 50, speed: 3, size: 15,
                            color: '#FF00FF', damage: 25, lastHitTime: 0
                        });
                    }
                }
                levelUpScreen.classList.add('hidden');
                isPaused = false;
                lastTime = performance.now();
                gameLoop(lastTime);
            };
            levelUpOptionsContainer.appendChild(card);
        });
    }

    function showGameOverScreen() {
        if(animationFrameId) cancelAnimationFrame(animationFrameId);
        gameOverScreen.classList.remove('hidden');
        pauseButton.classList.add('hidden');
        gameOverTimeUI.textContent = `생존 시간: ${formatTime(timer)}`;
        const finalRank = getRank(timer);
        gameOverRankUI.innerHTML = `달성 랭크: <span style="color:${finalRank.color}; text-shadow: 0 0 8px ${finalRank.color};">${finalRank.name}</span>`;
        const highscoreRank = getRank(highScore);
        gameOverHighscoreUI.innerHTML = `최고 기록: ${formatTime(highScore)} (${highscoreRank.name})`;
    }

    function updateUI() {
        levelUI.textContent = `레벨: ${player.level}`;
        timerUI.textContent = formatTime(timer);
        hpBar.style.width = `${Math.max(0, (player.hp / player.maxHp) * 100)}%`;
        xpBar.style.width = `${(player.xp / player.xpToNextLevel) * 100}%`;
        const rank = getRank(timer);
        currentRankUI.innerHTML = `<span style="color:${rank.color}; text-shadow: 0 0 5px ${rank.color};">${rank.name}</span>`;
        if (comboCount > 1) {
            comboUI.textContent = `${comboCount} COMBO!`;
        } else {
            comboUI.textContent = '';
        }
    }

    function gameLoop(timestamp) {
        if (gameState !== 'playing') return;
        
        const deltaTime = timestamp - lastTime;
        lastTime = timestamp;

        if (!isPaused) {
            update(deltaTime);
            draw();
        }

        animationFrameId = requestAnimationFrame(gameLoop);
    }
    
    init();
});
</script>
</body>
</html>
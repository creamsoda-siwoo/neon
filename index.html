
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>네온 서바이버</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      font-family: 'Orbitron', sans-serif;
      overflow: hidden;
      background-color: #0d0221;
      color: white;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      margin: 0;
      padding: 1rem;
      touch-action: none;
    }
    .game-container {
      background: #0a0a1f;
      border: 2px solid #00ffff;
      box-shadow: 0 0 20px #00ffff, inset 0 0 20px #00ffff;
      width: 90vmin;
      aspect-ratio: 4 / 3;
      touch-action: none;
    }
    #game-canvas {
      background-color: #0d0221;
      cursor: none;
      width: 100%;
      height: 100%;
      display: block;
    }
    .text-glow {
      color: #fff;
      text-shadow: 0 0 7px #fff, 0 0 10px #fff, 0 0 21px #ff00ff, 0 0 42px #ff00ff;
    }
    .button-retro {
      background-color: transparent;
      border: 2px solid #fff;
      color: #fff;
      padding: 0.75rem 1.5rem;
      text-transform: uppercase;
      letter-spacing: 2px;
      transition: all 0.2s ease-in-out;
      text-shadow: 0 0 8px #ff00ff;
      cursor: pointer;
    }
    .button-retro:hover:not(:disabled) {
      background-color: #fff;
      color: #0d0221;
      box-shadow: 0 0 20px #fff, 0 0 30px #ff00ff;
    }
    .button-retro:disabled {
        cursor: not-allowed;
        opacity: 0.5;
    }
    .selection-button {
        border-width: 2px;
        border-color: #fff;
        background-color: transparent;
        padding: 0.5rem;
        height: 100%;
        font-size: 0.875rem;
    }
    .selection-button.selected {
        background-color: #00ffff;
        color: #0d0221;
        box-shadow: 0 0 20px #00ffff;
    }
    .upgrade-card {
      border: 2px solid #00ffff;
      background: rgba(13, 2, 33, 0.8);
      transition: all 0.2s ease-in-out;
      cursor: pointer;
    }
    .upgrade-card:hover {
      background: rgba(0, 255, 255, 0.2);
      box-shadow: 0 0 15px #00ffff;
      transform: translateY(-5px);
    }
    .overlay {
        position: absolute;
        inset: 0;
        background-color: rgba(0,0,0,0.85);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
        z-index: 10;
        padding: 1rem;
    }
    .hidden {
        display: none;
    }
    #start-button {
        padding: 1rem 2rem;
        font-size: 1.25rem;
        font-weight: bold;
    }
    @keyframes pulse-glow {
        0% {
            transform: scale(1);
            box-shadow: 0 0 15px #00ffff, 0 0 25px #ff00ff;
        }
        50% {
            transform: scale(1.08);
            box-shadow: 0 0 30px #00ffff, 0 0 50px #ff00ff;
        }
        100% {
            transform: scale(1);
            box-shadow: 0 0 15px #00ffff, 0 0 25px #ff00ff;
        }
    }

    #start-button:not(:disabled) {
        border-color: #00ffff;
        color: #00ffff;
        text-shadow: 0 0 8px #00ffff;
        animation: pulse-glow 2s infinite ease-in-out;
    }
    .joystick {
        position: absolute;
        width: 80px;
        height: 80px;
        pointer-events: none;
    }
    .joystick-base {
        position: absolute;
        width: 100%;
        height: 100%;
        border-radius: 50%;
        background-color: rgba(0, 255, 255, 0.1);
        border: 2px solid rgba(0, 255, 255, 0.4);
        box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        transition: transform 0.1s ease-out, background-color 0.1s, border-color 0.1s;
    }
    .joystick-handle {
        position: absolute;
        width: 40px;
        height: 40px;
        top: 20px;
        left: 20px;
        border-radius: 50%;
        background-color: rgba(0, 255, 255, 0.3);
        border: 2px solid rgba(0, 255, 255, 0.8);
        box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
        transition: transform 0.05s linear, background-color 0.1s, border-color 0.1s;
    }
    .joystick.active .joystick-base {
        transform: scale(1.1);
        background-color: rgba(0, 255, 255, 0.2);
        border-color: rgba(0, 255, 255, 0.8);
    }
    .joystick.active .joystick-handle {
        background-color: rgba(0, 255, 255, 0.6);
        border-color: #fff;
    }
    .stat {
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }
    .stat-label {
        width: 60px;
        text-align: right;
        font-size: 0.8rem;
        color: #a7a7a7;
        flex-shrink: 0;
    }
    .stat-bar-bg {
        flex-grow: 1;
        height: 10px;
        background-color: rgba(0, 50, 50, 0.5);
        border: 1px solid #00ffff;
        border-radius: 5px;
        padding: 1px;
    }
    .stat-bar-fill {
        height: 100%;
        background: linear-gradient(90deg, #ff00ff, #00ffff);
        border-radius: 3px;
        box-shadow: 0 0 5px #00ffff;
        transition: width 0.3s ease-out;
    }
  </style>
</head>
<body>

  <main class="flex flex-col items-center">
    <div class="flex justify-between w-full mb-2 px-2 text-glow" style="max-width: 90vmin;">
        <div class="flex gap-4 items-center">
            <div id="level-ui" class="text-xl">레벨: 1</div>
            <div id="current-rank-ui" class="text-lg"></div>
        </div>
        <div class="flex flex-col items-center">
            <div id="timer-ui" class="text-2xl font-bold">00:00</div>
            <div id="combo-ui" class="text-xl font-bold text-yellow-400 h-6" style="text-shadow: 0 0 8px #facc15;"></div>
        </div>
        <div id="highscore-ui" class="text-xl text-right">최고기록: 00:00</div>
    </div>
    
    <div class="w-full h-8 mb-2 flex flex-col justify-around" style="max-width: 90vmin;">
        <div class="w-full bg-gray-700 h-3 rounded-full overflow-hidden border border-red-500">
            <div id="hp-bar" class="bg-red-500 h-full" style="width: 100%"></div>
        </div>
        <div class="w-full bg-gray-700 h-3 rounded-full overflow-hidden border border-cyan-400">
            <div id="xp-bar" class="bg-cyan-400 h-full" style="width: 0%"></div>
        </div>
    </div>

    <div id="game-wrapper" class="relative rounded-lg overflow-hidden game-container">
      <canvas id="game-canvas" width="800" height="600"></canvas>
      <button id="pause-button" class="absolute top-2 right-2 text-2xl w-12 h-12 button-retro hidden items-center justify-center" style="padding: 0;">||</button>
      
      <div id="movement-joystick" class="joystick hidden">
        <div class="joystick-base"></div>
        <div class="joystick-handle"></div>
      </div>
      
      <div id="start-screen" class="overlay">
          <div class="absolute top-4 left-4 text-xs text-gray-500">제작자: 한국인이라면</div>
          <h1 class="text-5xl md:text-6xl font-bold mb-4 text-glow">네온 서바이버</h1>
          <div id="start-screen-highscore" class="text-xl mb-8 text-glow"></div>
          
          <div class="w-full max-w-2xl">
            <h2 class="text-xl mb-2 text-glow">난이도 선택</h2>
            <div id="difficulty-selection" class="grid grid-cols-3 gap-2 mb-4">
                <button class="button-retro selection-button" data-difficulty="쉬움">쉬움</button>
                <button class="button-retro selection-button" data-difficulty="보통">보통</button>
                <button class="button-retro selection-button" data-difficulty="어려움">어려움</button>
            </div>
          </div>

          <div class="w-full max-w-2xl mt-4">
              <h2 class="text-xl mb-2 text-glow">무기 선택</h2>
              <div id="weapon-selection" class="grid grid-cols-4 gap-2 mb-2">
                  <button class="button-retro selection-button" data-weapon="machine-gun">기관총</button>
                  <button class="button-retro selection-button" data-weapon="missile">유도 미사일</button>
                  <button class="button-retro selection-button" data-weapon="bomb">폭탄</button>
                  <button class="button-retro selection-button" data-weapon="laser">레이저</button>
                  <button class="button-retro selection-button" data-weapon="bow">활</button>
                  <button class="button-retro selection-button" data-weapon="chain-lightning">연쇄 번개</button>
                  <button class="button-retro selection-button" data-weapon="black-hole-generator">블랙홀</button>
                  <button class="button-retro selection-button" data-weapon="plasma-cannon">플라즈마</button>
                  <button class="button-retro selection-button" data-weapon="ricochet-blade">리코</button>
                  <button class="button-retro selection-button" data-weapon="vortex-cannon">볼텍스 캐논</button>
                  <button class="button-retro selection-button" data-weapon="glitch-pulser">글리치 펄서</button>
                  <button class="button-retro selection-button" data-weapon="cryo-blaster">크라이오 블래스터</button>
              </div>
          </div>

          <button id="start-button" class="button-retro mt-8" disabled>게임 시작</button>
      </div>

      <div id="pause-screen" class="overlay hidden">
          <h2 class="text-6xl font-bold mb-8 text-glow">일시정지</h2>
          <div class="flex flex-col gap-4 w-64">
              <button id="resume-button" class="button-retro">계속하기</button>
              <button id="restart-pause-button" class="button-retro">다시 시작</button>
              <button id="quit-button" class="button-retro">그만하기</button>
          </div>
      </div>

      <div id="levelup-screen" class="overlay hidden">
          <h2 class="text-5xl font-bold mb-8 text-glow">레벨 업!</h2>
          <div id="levelup-options" class="grid grid-cols-1 md:grid-cols-3 gap-6">
              <!-- Upgrade cards will be injected here -->
          </div>
      </div>

      <div id="gameover-screen" class="overlay hidden">
          <h2 class="text-6xl font-bold mb-4 text-glow">게임 오버</h2>
          <p id="gameover-time" class="text-3xl mb-2">생존 시간: 00:00</p>
          <p id="gameover-rank" class="text-2xl mb-6"></p>
          <p id="gameover-highscore" class="text-xl mb-8">최고 기록: 00:00</p>
          <button id="restart-button" class="button-retro">새로 시작</button>
      </div>
    </div>
  </main>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- DOM Elements ---
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    const gameWrapper = document.getElementById('game-wrapper');
    const startScreen = document.getElementById('start-screen');
    const pauseScreen = document.getElementById('pause-screen');
    const levelUpScreen = document.getElementById('levelup-screen');
    const gameOverScreen = document.getElementById('gameover-screen');
    const startButton = document.getElementById('start-button');
    const restartButton = document.getElementById('restart-button');
    const pauseButton = document.getElementById('pause-button');
    const levelUpOptionsContainer = document.getElementById('levelup-options');
    const weaponSelection = document.getElementById('weapon-selection');
    const difficultySelection = document.getElementById('difficulty-selection');
    const resumeButton = document.getElementById('resume-button');
    const restartPauseButton = document.getElementById('restart-pause-button');
    const quitButton = document.getElementById('quit-button');

    // Joystick UI
    const movementJoystickUI = document.getElementById('movement-joystick');
    const movementJoystickHandle = movementJoystickUI.querySelector('.joystick-handle');
    
    // UI Elements
    const levelUI = document.getElementById('level-ui');
    const timerUI = document.getElementById('timer-ui');
    const comboUI = document.getElementById('combo-ui');
    const highscoreUI = document.getElementById('highscore-ui');
    const hpBar = document.getElementById('hp-bar');
    const xpBar = document.getElementById('xp-bar');
    const gameOverTimeUI = document.getElementById('gameover-time');
    const gameOverRankUI = document.getElementById('gameover-rank');
    const gameOverHighscoreUI = document.getElementById('gameover-highscore');
    const startScreenHighscoreUI = document.getElementById('start-screen-highscore');
    const currentRankUI = document.getElementById('current-rank-ui');

    // --- Game Constants ---
    const CANVAS_WIDTH = 800;
    const CANVAS_HEIGHT = 600;
    const PLAYER_SIZE = 20;
    const COMBO_TIMEOUT = 2500;
    const HEALTH_PACK_DROP_CHANCE = 0.10; // 10%

    // --- Ranking System ---
    const RANKS = [
        { name: '네온 초심자', threshold: 0, color: '#9ca3af' },
        { name: '그리드 러너', threshold: 60, color: '#6ee7b7' },
        { name: '서킷 브레이커', threshold: 120, color: '#60a5fa' },
        { name: '데이터 스트리머', threshold: 180, color: '#c084fc' },
        { name: '사이버 검투사', threshold: 240, color: '#f87171' },
        { name: '신스웨이브 파수꾼', threshold: 300, color: '#facc15' },
        { name: '디지털 오버로드', threshold: 420, color: '#f472b6' },
        { name: '코드 아크마스터', threshold: 600, color: '#00ffff' },
        { name: '매트릭스 군주', threshold: 900, color: '#ffffff' }
    ];

    function getRank(seconds) {
        let currentRank = RANKS[0];
        for (const rank of RANKS) {
            if (seconds >= rank.threshold) {
                currentRank = rank;
            } else {
                break;
            }
        }
        return currentRank;
    }
    
    // --- Enemy Types ---
    const ENEMY_TYPES = {
        'grunt': { size: 15, hp: 10, speed: 70, color: '#ff4d4d', xp: 1, shape: 'square', damage: 5 },
        'tank': { size: 30, hp: 50, speed: 40, color: '#ff8c66', xp: 5, shape: 'square', damage: 15 },
        'shooter': { size: 18, hp: 15, speed: 60, color: '#fcf003', xp: 2, shape: 'triangle', damage: 10, fireRate: 2000, projectileSpeed: 150 },
        'bomber': { size: 20, hp: 20, speed: 80, color: '#ff99cc', xp: 3, shape: 'square', damage: 20, onDeath: 'explode' },
        'summoner': { size: 25, hp: 40, speed: 50, color: '#cc99ff', xp: 8, shape: 'triangle', damage: 5, actionRate: 5000, action: 'summon' },
        'boss': { size: 50, hp: 500, speed: 60, color: '#ff0000', xp: 50, shape: 'square', damage: 25, fireRate: 1000, projectileSpeed: 200 },
    };


    // --- Game Configs ---
    const DIFFICULTY_SETTINGS = {
        '쉬움': { hp: 120, enemyHpMult: 0.7, enemySpeedMult: 0.8, spawnRateMult: 1.2 },
        '보통': { hp: 100, enemyHpMult: 1.0, enemySpeedMult: 1.0, spawnRateMult: 1.0 },
        '어려움': { hp: 80, enemyHpMult: 1.5, enemySpeedMult: 1.2, spawnRateMult: 0.8 },
    };
    const WEAPON_SETTINGS = {
        'machine-gun': { fireRate: 400, damage: 12, projectileType: 'bullet', name: '기관총', knockback: 20, description: '가장 균형잡힌 무기. 8발마다 강력한 넉백탄 발사!' },
        'missile': { fireRate: 1000, damage: 40, projectileType: 'missile', name: '유도 미사일', explosionRadius: 70, description: '가장 가까운 적을 추적하며 넓은 범위에 폭발 피해를 줍니다.' },
        'bomb': { fireRate: 800, damage: 25, projectileType: 'bomb', name: '폭탄', shrapnelCount: 5, description: '포물선으로 날아가 폭발하며 5개의 파편을 흩뿌립니다.' },
        'laser': { fireRate: 1200, damage: 45, projectileType: 'laser', name: '레이저', slowAmount: 0.5, slowDuration: 1000, description: '적을 관통하며 1초간 이동 속도를 50% 감소시킵니다.' },
        'bow': { fireRate: 600, damage: 25, projectileType: 'arrow', name: '활', critChance: 0.15, critMultiplier: 2, description: '적을 관통하며 15% 확률로 2배의 치명타 피해를 입힙니다.' },
        'chain-lightning': { fireRate: 800, damage: 30, projectileType: 'lightning', name: '연쇄 번개', bounces: 4, description: '적들 사이를 4번 튕기는 번개를 발사합니다.' },
        'black-hole-generator': { fireRate: 2000, damage: 0, projectileType: 'black-hole-orb', name: '블랙홀 생성기', description: '적을 끌어당기고 지속 피해를 주는 소형 블랙홀을 발사합니다.' },
        'plasma-cannon': { fireRate: 1800, damage: 50, projectileType: 'plasma-ball', name: '플라즈마 캐논', explosionRadius: 80, burnDamage: 10, burnDuration: 3000, description: '느리지만 강력한 플라즈마 구체를 발사합니다. 구체는 폭발하며 3초간 화상 피해를 입힙니다.' },
        'ricochet-blade': { fireRate: 750, damage: 20, projectileType: 'ricochet-blade', name: '리코셰 블레이드', bounces: 3, description: '적에게 튕기는 회전 칼날을 발사하여 최대 4명의 적을 공격합니다.' },
        'vortex-cannon': { fireRate: 2200, damage: 10, projectileType: 'vortex-orb', name: '볼텍스 캐논', description: '적을 끌어당기며 지속 피해를 주는 소용돌이를 생성하는 구체를 발사합니다.' },
        'glitch-pulser': { fireRate: 900, damage: 15, projectileType: 'glitch-pulse', name: '글리치 펄서', stunChance: 0.2, stunDuration: 1000, description: '짧은 거리의 적들을 관통하는 에너지 파동을 방출합니다. 피격된 적은 확률적으로 잠시 기절합니다.' },
        'cryo-blaster': { fireRate: 850, damage: 18, projectileType: 'cryo-shard', name: '크라이오 블래스터', slowAmount: 0.4, slowDuration: 1500, freezeOnNthShot: 5, freezeDuration: 1000, description: '적을 느리게 만드는 얼음 파편을 발사합니다. 5번째 공격마다 적을 잠시 얼립니다.'}
    };
   
    // --- Audio ---
    let audioContext;
    try { audioContext = new (window.AudioContext || window.webkitAudioContext)(); }
    catch (e) { console.error("Web Audio API is not supported in this browser"); }

    function playSound(type, frequency, duration, volume = 0.3) {
        if (!audioContext) return;
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        oscillator.type = type;
        oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
        gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.00001, audioContext.currentTime + duration);
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + duration);
    }
    const sounds = {
        hit: () => playSound('square', 150, 0.1, 0.2),
        shoot: () => playSound('triangle', 440, 0.05, 0.1),
        xp: () => playSound('sine', 600, 0.1, 0.2),
        levelUp: () => playSound('sine', 880, 0.4),
        heal: () => playSound('sine', 700, 0.3),
        dash: () => playSound('sine', 300, 0.2, 0.4),
        explosion: () => playSound('sine', 50, 0.3, 0.5),
        nuke: () => playSound('sine', 100, 1.0, 0.8),
        powerup: () => playSound('sine', 900, 0.2),
        freeze: () => playSound('sawtooth', 200, 0.5, 0.4),
        shieldUp: () => playSound('sine', 1000, 0.2, 0.5),
        shieldDown: () => playSound('square', 100, 0.2, 0.5),
        blackHole: () => playSound('noise', 100, 2, 0.4),
        summon: () => playSound('sine', 500, 0.3, 0.2),
    };
    
    // --- Game State ---
    let gameState = 'start';
    let isPaused = false;
    let player, enemies, projectiles, enemyProjectiles, xpGems, healthPacks, nukes, explosions;
    let orbitalShields, speedBoosts, fireRateBoosts, freezeBombs, invincibilityShields, blackHoleItems;
    let drones, explosiveBarrels, blackHoles, vortexes;
    let holographicDecoys, decoys;
    let magnets, xpBombs;
    let damageTexts;
    let screenShake = { duration: 0, magnitude: 0 };
    let timer, gameTime, lastTime, animationFrameId;
    let lastSpawnTime, spawnInterval;
    let bossSpawned, enemiesFrozen, enemiesFrozenTimer;
    let keysPressed = {};
    let highScore = Number(localStorage.getItem('neonSurvivorHighScore') || 0);
    let comboCount, lastKillTime;
    let activeTouchCount = 0;
    let nextEnemyId = 0;
    
    // Selection and Game-wide states
    let selectedDifficulty, selectedWeapon;
    let gameDifficulty;

    // Joystick State
    const JOYSTICK_BASE_RADIUS = 40;
    const JOYSTICK_MAX_OFFSET = JOYSTICK_BASE_RADIUS - 20;
    const JOYSTICK_DEAD_ZONE = 5;
    let movementJoystickState = { active: false, x: 0, y: 0, dx: 0, dy: 0, touchId: null };


    // --- Upgrades ---
    const UPGRADES = [
        { id: 'firerate', title: "연사력 강화", description: "공격 속도 20% 증가", apply: p => { p.baseFireRate *= 0.8; p.fireRate = p.baseFireRate;} },
        { id: 'damage', title: "강화 탄환", description: "공격력 25% 증가", apply: p => p.projectileDamage *= 1.25 },
        { id: 'multishot', title: "멀티샷", description: "발사체 수 +1", apply: p => p.projectiles++ },
        { id: 'hp', title: "나노 수리봇", description: "최대 체력 20 증가 및 모두 회복", apply: p => { p.maxHp += 20; p.hp = p.maxHp; } },
        { id: 'speed', title: "고속 추진기", description: "이동 속도 10% 증가", apply: p => { p.baseSpeed *= 1.1; p.speed = p.baseSpeed; } },
        { id: 'shield', title: '궤도 방패', description: '주위를 도는 방패 추가', apply: p => p.shields++ },
        { id: 'explosive', title: '폭발탄', description: '탄환이 명중 시 폭발합니다', apply: p => p.explosiveProjectiles = true },
        { id: 'magnet', title: '경험치 자석', description: '경험치 획득 범위 50% 증가', apply: p => p.pickupRadius *= 1.5 },
        { id: 'drone', title: '컴패니언 드론', description: '플레이어를 돕는 공격 드론을 추가합니다.', apply: p => p.drones = (p.drones || 0) + 1 },
        { id: 'regeneration', title: '나노 재생 갑옷', description: '초당 최대 체력의 1%를 회복합니다.', apply: p => p.regeneration = (p.regeneration || 0) + (p.maxHp * 0.01) },
        { id: 'thorns', title: '에너지 가시', description: '플레이어에게 닿는 적에게 20의 피해를 입힙니다.', apply: p => p.thornsDamage = (p.thornsDamage || 0) + 20 },
        { id: 'chain-reaction', title: '연쇄 폭발', description: '적이 죽을 때 15% 확률로 폭발하여 주변에 피해를 줍니다.', apply: p => p.chainReactionChance = (p.chainReactionChance || 0) + 0.15 }
    ];
    let availableUpgrades = [...UPGRADES];
    
    function createInitialPlayer(difficulty, weapon) {
        const difficultySettings = DIFFICULTY_SETTINGS[difficulty];
        const weaponSettings = WEAPON_SETTINGS[weapon];
        
        return {
            x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2,
            hp: difficultySettings.hp, maxHp: difficultySettings.hp,
            xp: 0, level: 1, xpToNextLevel: 10,
            weaponType: weapon,
            fireRate: weaponSettings.fireRate, baseFireRate: weaponSettings.fireRate,
            projectiles: 1, projectileDamage: weaponSettings.damage, projectileType: weaponSettings.projectileType,
            lastShotTime: 0, speed: 220, baseSpeed: 220, pickupRadius: 100,
            dashCooldown: 2000, lastDashTime: 0, isDashing: false, dashDuration: 150, dashSpeed: 750,
            shields: 1, // Start with 1 shield by default
            explosiveProjectiles: false,
            speedBoostTimer: 0, fireRateBoostTimer: 0, invincibilityTimer: 0, magnetTimer: 0,
            drones: 0,
            machineGunShotCount: 0,
            decoyCharges: 0,
            regeneration: 0,
            thornsDamage: 0,
            chainReactionChance: 0,
        };
    }

    function formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
    }

    function updateStartButtonState() {
        startButton.disabled = !(selectedDifficulty && selectedWeapon);
    }

    function togglePause() {
        if (gameState !== 'playing' || levelUpScreen.style.display === 'flex') return;
        isPaused = !isPaused;
        pauseScreen.classList.toggle('hidden', !isPaused);
        if (isPaused) {
            cancelAnimationFrame(animationFrameId);
            screenShake = { duration: 0, magnitude: 0 };
        } else {
            lastTime = performance.now();
            animationFrameId = requestAnimationFrame(gameLoop);
        }
    }

    function selectUpgrade(upgrade) {
        upgrade.apply(player);
        availableUpgrades = availableUpgrades.filter(u => u.id !== upgrade.id && u.id !== 'multishot');
        levelUpScreen.classList.add('hidden');
        isPaused = false;
        gameState = 'playing';
        lastTime = performance.now();
        animationFrameId = requestAnimationFrame(gameLoop);
    }

    function levelUp() {
        isPaused = true;
        gameState = 'levelup';
        sounds.levelUp();
        cancelAnimationFrame(animationFrameId);
        screenShake = { duration: 0, magnitude: 0 };
        
        levelUpOptionsContainer.innerHTML = '';
        const selectedUpgrades = [];
        const tempUpgrades = [...availableUpgrades];
        
        for (let i = 0; i < 3 && tempUpgrades.length > 0; i++) {
            const randomIndex = Math.floor(Math.random() * tempUpgrades.length);
            selectedUpgrades.push(tempUpgrades[randomIndex]);
            tempUpgrades.splice(randomIndex, 1);
        }

        selectedUpgrades.forEach(upgrade => {
            const card = document.createElement('div');
            card.className = 'upgrade-card p-4 rounded-lg flex flex-col items-center justify-center text-center';
            card.innerHTML = `
                <h3 class="text-xl font-bold mb-2 text-glow">${upgrade.title}</h3>
                <p>${upgrade.description}</p>
            `;
            card.onclick = () => selectUpgrade(upgrade);
            levelUpOptionsContainer.appendChild(card);
        });

        levelUpScreen.classList.remove('hidden');
    }
    
    function collectXP(amount) {
        sounds.xp();
        player.xp += amount;
        if (player.xp >= player.xpToNextLevel) {
            player.level++;
            player.xp -= player.xpToNextLevel;
            player.xpToNextLevel = Math.floor(player.xpToNextLevel * 1.5);
            levelUI.textContent = `레벨: ${player.level}`;
            levelUp();
        }
    }
    
    function createDamageText(text, x, y, isCrit = false) {
        damageTexts.push({
            text, x, y,
            alpha: 1,
            timer: 0,
            color: isCrit ? '255, 255, 0' : '255, 255, 255'
        });
    }

    function takeDamage(entity, amount, isCrit = false) {
        entity.hp -= amount;
        if (entity.hp <= 0) {
            entity.hp = 0;
        }

        if (entity === player) {
             if (player.invincibilityTimer > 0) return;
             
             if (player.shields > 0) {
                 player.shields--;
                 player.invincibilityTimer = 1000;
                 sounds.shieldDown();
                 return;
             }
            sounds.hit();
            screenShake = { duration: 200, magnitude: 4 };
        } else {
            createDamageText(String(Math.floor(amount)), entity.x, entity.y, isCrit);
        }
    }
    
    function getSpawnPosition() {
        let x, y;
        const edge = Math.floor(Math.random() * 4);
        if (edge === 0) { // Top
            x = Math.random() * CANVAS_WIDTH;
            y = -30;
        } else if (edge === 1) { // Right
            x = CANVAS_WIDTH + 30;
            y = Math.random() * CANVAS_HEIGHT;
        } else if (edge === 2) { // Bottom
            x = Math.random() * CANVAS_WIDTH;
            y = CANVAS_HEIGHT + 30;
        } else { // Left
            x = -30;
            y = Math.random() * CANVAS_HEIGHT;
        }
        return { x, y };
    }

    function spawnEnemy() {
        if (enemies.length > 150) return;
        
        const { x, y } = getSpawnPosition();
        let enemyType = 'grunt';
        
        const timeFactor = Math.min(gameTime / 180, 1); // Cap difficulty increase at 3 minutes
        const rand = Math.random();
        
        if (gameTime > 60 && rand < 0.1 + timeFactor * 0.2) {
            enemyType = 'summoner';
        } else if (gameTime > 45 && rand < 0.2 + timeFactor * 0.2) {
            enemyType = 'bomber';
        } else if (gameTime > 30 && rand < 0.4 + timeFactor * 0.2) {
            enemyType = 'shooter';
        } else if (gameTime > 15 && rand < 0.6 + timeFactor * 0.2) {
            enemyType = 'tank';
        }

        const base = ENEMY_TYPES[enemyType];
        const finalHp = base.hp * DIFFICULTY_SETTINGS[gameDifficulty].enemyHpMult * (1 + gameTime / 120);
        const finalSpeed = base.speed * DIFFICULTY_SETTINGS[gameDifficulty].enemySpeedMult;
        
        enemies.push({ 
            id: nextEnemyId++,
            ...base, 
            x, y, 
            hp: finalHp, 
            maxHp: finalHp, 
            speed: finalSpeed, 
            lastActionTime: 0,
            slowTimer: 0,
            slowAmount: 0,
            freezeTimer: 0,
            burnTimer: 0,
            burnDamage: 0
        });
    }

    function spawnBoss() {
        if (bossSpawned) return;
        bossSpawned = true;
        const { x, y } = getSpawnPosition();
        const base = ENEMY_TYPES['boss'];
        const finalHp = base.hp * DIFFICULTY_SETTINGS[gameDifficulty].enemyHpMult;
        enemies.push({ ...base, id: nextEnemyId++, x, y, hp: finalHp, maxHp: finalHp, lastActionTime: 0 });
    }
    
    function shoot(targetX, targetY) {
        if (performance.now() - player.lastShotTime < player.fireRate) return;
        player.lastShotTime = performance.now();
        sounds.shoot();

        const weapon = WEAPON_SETTINGS[player.weaponType];
        
        for (let i = 0; i < player.projectiles; i++) {
            let angle = Math.atan2(targetY - player.y, targetX - player.x);
            if (player.projectiles > 1) {
                angle += (i - (player.projectiles - 1) / 2) * 0.2;
            }
            
            let projectileSpeed = 300;
            let lifetime = 2000;
            
            const projectile = {
                x: player.x,
                y: player.y,
                damage: player.projectileDamage,
                type: player.projectileType,
                owner: 'player',
                lifetime: lifetime,
                explosive: player.explosiveProjectiles,
                explosionRadius: 50,
            };
            
            switch (player.projectileType) {
                case 'missile':
                    projectile.vx = Math.cos(angle) * 150;
                    projectile.vy = Math.sin(angle) * 150;
                    projectile.target = enemies.length > 0 ? enemies.reduce((closest, e) => {
                        const dist = Math.hypot(e.x - player.x, e.y - player.y);
                        return dist < closest.dist ? { dist, e } : closest;
                    }, { dist: Infinity, e: null }).e : null;
                    projectile.explosionRadius = weapon.explosionRadius;
                    break;
                case 'laser':
                    projectile.vx = Math.cos(angle) * 600;
                    projectile.vy = Math.sin(angle) * 600;
                    projectile.lifetime = 1200;
                    projectile.pierce = true;
                    projectile.slowAmount = weapon.slowAmount;
                    projectile.slowDuration = weapon.slowDuration;
                    break;
                case 'arrow':
                    projectile.vx = Math.cos(angle) * 450;
                    projectile.vy = Math.sin(angle) * 450;
                    projectile.pierce = true;
                    projectile.critChance = weapon.critChance;
                    projectile.critMultiplier = weapon.critMultiplier;
                    break;
                case 'lightning':
                    projectile.target = enemies.length > 0 ? enemies[Math.floor(Math.random() * enemies.length)] : null;
                    projectile.bouncesLeft = weapon.bounces;
                    projectile.bounceRange = 150;
                    if (!projectile.target) return;
                    break;
                 case 'black-hole-orb':
                    projectile.vx = Math.cos(angle) * 100;
                    projectile.vy = Math.sin(angle) * 100;
                    projectile.lifetime = 3000;
                    break;
                case 'plasma-ball':
                    projectile.vx = Math.cos(angle) * 80;
                    projectile.vy = Math.sin(angle) * 80;
                    projectile.explosionRadius = weapon.explosionRadius;
                    projectile.burnDamage = weapon.burnDamage;
                    projectile.burnDuration = weapon.burnDuration;
                    projectile.lifetime = 4000;
                    break;
                case 'ricochet-blade':
                    projectile.vx = Math.cos(angle) * 350;
                    projectile.vy = Math.sin(angle) * 350;
                    projectile.bouncesLeft = weapon.bounces;
                    projectile.bounceRange = 200;
                    projectile.rotation = 0;
                    projectile.rotationSpeed = 15;
                    projectile.hitEnemies = [];
                    break;
                case 'vortex-orb':
                    projectile.vx = Math.cos(angle) * 120;
                    projectile.vy = Math.sin(angle) * 120;
                    projectile.lifetime = 2500;
                    break;
                case 'glitch-pulse':
                    projectile.width = 100;
                    projectile.height = 10;
                    projectile.angle = angle;
                    projectile.pierce = true;
                    projectile.stunChance = weapon.stunChance;
                    projectile.stunDuration = weapon.stunDuration;
                    projectile.lifetime = 300;
                    break;
                case 'cryo-shard':
                    projectile.vx = Math.cos(angle) * 400;
                    projectile.vy = Math.sin(angle) * 400;
                    projectile.slowAmount = weapon.slowAmount;
                    projectile.slowDuration = weapon.slowDuration;
                    
                    player.machineGunShotCount = (player.machineGunShotCount || 0) + 1;
                    if (player.machineGunShotCount % weapon.freezeOnNthShot === 0) {
                        projectile.shouldFreeze = true;
                        projectile.freezeDuration = weapon.freezeDuration;
                    }
                    break;
                 case 'bomb':
                    const speed = 250;
                    const travelTime = 600; // in ms
                    projectile.vx = Math.cos(angle) * speed;
                    projectile.vy = Math.sin(angle) * speed;
                    projectile.vz = 200; // initial upward velocity
                    projectile.gravity = -400; // gravity effect
                    projectile.lifetime = travelTime;
                    projectile.shrapnelCount = weapon.shrapnelCount;
                    break;
                default: // machine-gun (bullet)
                    projectile.vx = Math.cos(angle) * 400;
                    projectile.vy = Math.sin(angle) * 400;
                    player.machineGunShotCount = (player.machineGunShotCount || 0) + 1;
                    if (player.machineGunShotCount % 8 === 0) {
                        projectile.knockback = weapon.knockback * 5;
                        projectile.size = 10;
                    } else {
                        projectile.knockback = weapon.knockback;
                        projectile.size = 5;
                    }
                    break;
            }
            projectiles.push(projectile);
        }
    }

    function findClosestEnemy() {
        if (enemies.length === 0) return null;
        let closest = null;
        let closestDistSq = Infinity;
        for (const enemy of enemies) {
            const distSq = (enemy.x - player.x) ** 2 + (enemy.y - player.y) ** 2;
            if (distSq < closestDistSq) {
                closestDistSq = distSq;
                closest = enemy;
            }
        }
        return closest;
    }


    function update(dt) {
        if (!player || player.hp <= 0) return;

        // --- Player Movement ---
        let moveX = 0, moveY = 0;
        if (keysPressed['w'] || keysPressed['ArrowUp']) moveY = -1;
        if (keysPressed['s'] || keysPressed['ArrowDown']) moveY = 1;
        if (keysPressed['a'] || keysPressed['ArrowLeft']) moveX = -1;
        if (keysPressed['d'] || keysPressed['ArrowRight']) moveX = 1;
        
        if (movementJoystickState.active) {
            moveX = movementJoystickState.dx;
            moveY = movementJoystickState.dy;
        }

        const moveMagnitude = Math.hypot(moveX, moveY);
        if (moveMagnitude > 0) {
            const normalizedX = moveX / moveMagnitude;
            const normalizedY = moveY / moveMagnitude;
            player.x += normalizedX * player.speed * dt;
            player.y += normalizedY * player.speed * dt;
        }

        // Clamp player position
        player.x = Math.max(PLAYER_SIZE / 2, Math.min(CANVAS_WIDTH - PLAYER_SIZE / 2, player.x));
        player.y = Math.max(PLAYER_SIZE / 2, Math.min(CANVAS_HEIGHT - PLAYER_SIZE / 2, player.y));
        
        // --- Automatic Shooting ---
        const closestEnemy = findClosestEnemy();
        if (closestEnemy) {
            shoot(closestEnemy.x, closestEnemy.y);
        }

        // --- Timers ---
        gameTime += dt;
        timerUI.textContent = formatTime(gameTime);
        if (gameTime > highScore) {
            highScore = gameTime;
            localStorage.setItem('neonSurvivorHighScore', highScore);
            highscoreUI.textContent = `최고기록: ${formatTime(highScore)}`;
        }
        
        const currentRank = getRank(gameTime);
        currentRankUI.textContent = currentRank.name;
        currentRankUI.style.color = currentRank.color;
        currentRankUI.style.textShadow = `0 0 8px ${currentRank.color}`;

        // Combo
        if (comboCount > 0 && performance.now() - lastKillTime > COMBO_TIMEOUT) {
            comboCount = 0;
            comboUI.textContent = '';
        }
        
        // --- Spawning ---
        lastSpawnTime += dt * 1000;
        if (lastSpawnTime > spawnInterval) {
            lastSpawnTime = 0;
            const spawnCount = 1 + Math.floor(gameTime / 20);
            for(let i=0; i<spawnCount; i++) {
                spawnEnemy();
            }
            spawnInterval = Math.max(200, 1500 * DIFFICULTY_SETTINGS[gameDifficulty].spawnRateMult - gameTime * 5);
        }
        if (gameTime > 300 && !bossSpawned) {
             spawnBoss();
        }

        // --- Player Regeneration ---
        if (player.regeneration > 0) {
            player.hp = Math.min(player.maxHp, player.hp + player.regeneration * dt);
        }

        // --- Update Entities ---

        // Projectiles
        for (let i = projectiles.length - 1; i >= 0; i--) {
            const p = projectiles[i];
            if (p.type === 'missile' && p.target && p.target.hp > 0) {
                const angle = Math.atan2(p.target.y - p.y, p.target.x - p.x);
                p.vx += Math.cos(angle) * 500 * dt;
                p.vy += Math.sin(angle) * 500 * dt;
                const speed = Math.hypot(p.vx, p.vy);
                const maxSpeed = 300;
                if (speed > maxSpeed) {
                    p.vx = (p.vx / speed) * maxSpeed;
                    p.vy = (p.vy / speed) * maxSpeed;
                }
            } else if (p.type === 'bomb') {
                p.vz += p.gravity * dt;
                p.y -= p.vz * dt;
            }
            
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            
            p.lifetime -= dt * 1000;
            if (p.lifetime <= 0) {
                if (p.type === 'bomb' || p.type === 'black-hole-orb' || p.type === 'plasma-ball' || p.type === 'vortex-orb') {
                    // Special on-expire effects
                     if (p.type === 'black-hole-orb') {
                        blackHoles.push({ x: p.x, y: p.y, radius: 10, maxRadius: 100, duration: 5000, pullForce: 250, damage: 15, damageInterval: 500, lastDamageTime: 0 });
                        sounds.blackHole();
                    } else if (p.type === 'bomb') {
                         explosions.push({ x: p.x, y: p.y, radius: 0, maxRadius: 40, damage: p.damage });
                        // shrapnel
                        for (let k = 0; k < p.shrapnelCount; k++) {
                            const angle = Math.random() * Math.PI * 2;
                            projectiles.push({
                                x: p.x, y: p.y, type: 'bullet', damage: p.damage / 2,
                                vx: Math.cos(angle) * 200, vy: Math.sin(angle) * 200,
                                lifetime: 500, owner: 'player', knockback: 10
                            });
                        }
                    } else if (p.type === 'plasma-ball') {
                        explosions.push({ x: p.x, y: p.y, radius: 0, maxRadius: p.explosionRadius, damage: p.damage, burnDamage: p.burnDamage, burnDuration: p.burnDuration });
                    }
                }
                projectiles.splice(i, 1);
            }
        }

        // Enemies
        for (let i = enemies.length - 1; i >= 0; i--) {
            const e = enemies[i];
            // Effects
            if (e.freezeTimer > 0) {
                e.freezeTimer -= dt * 1000;
            } else if (e.slowTimer > 0) {
                e.slowTimer -= dt * 1000;
            }
            if (e.burnTimer > 0) {
                e.burnTimer -= dt * 1000;
                if (Math.floor(e.burnTimer / 500) !== Math.floor((e.burnTimer + dt * 1000) / 500)) {
                    takeDamage(e, e.burnDamage);
                }
            }

            const speed = e.speed * (e.freezeTimer > 0 ? 0 : (e.slowTimer > 0 ? (1 - e.slowAmount) : 1));
            const angle = Math.atan2(player.y - e.y, player.x - e.x);
            e.x += Math.cos(angle) * speed * dt;
            e.y += Math.sin(angle) * speed * dt;

            // Collision with player
            if (Math.hypot(e.x - player.x, e.y - player.y) < PLAYER_SIZE / 2 + e.size / 2) {
                takeDamage(player, e.damage);
                if (player.thornsDamage > 0) {
                    takeDamage(e, player.thornsDamage);
                }
            }
            
            // Enemy actions (shooting, summoning)
            if (e.lastActionTime + (e.fireRate || e.actionRate) < performance.now()) {
                e.lastActionTime = performance.now();
                if (e.shape === 'triangle' && e.action !== 'summon') { // Shooter
                    const angleToPlayer = Math.atan2(player.y - e.y, player.x - e.x);
                    enemyProjectiles.push({
                        x: e.x, y: e.y, type: 'bullet', damage: e.damage,
                        vx: Math.cos(angleToPlayer) * e.projectileSpeed,
                        vy: Math.sin(angleToPlayer) * e.projectileSpeed,
                        lifetime: 3000, owner: 'enemy'
                    });
                } else if (e.action === 'summon') {
                    sounds.summon();
                    for(let k = 0; k < 2; k++) {
                        const grunt = ENEMY_TYPES['grunt'];
                        enemies.push({ ...grunt, id: nextEnemyId++, x: e.x + (Math.random() - 0.5) * 40, y: e.y + (Math.random() - 0.5) * 40, hp: grunt.hp * 0.5, speed: grunt.speed * 1.1 });
                    }
                }
            }

            // Projectile collision with enemy
            for (let j = projectiles.length - 1; j >= 0; j--) {
                const p = projectiles[j];
                 if (Math.hypot(p.x - e.x, p.y - e.y) < e.size / 2 + 5) {
                    let damage = p.damage;
                    let isCrit = false;
                    if (p.critChance && Math.random() < p.critChance) {
                        damage *= p.critMultiplier;
                        isCrit = true;
                    }

                    takeDamage(e, damage, isCrit);
                    
                    if (p.knockback) {
                        const angle = Math.atan2(e.y - p.y, e.x - p.x);
                        e.x += Math.cos(angle) * p.knockback;
                        e.y += Math.sin(angle) * p.knockback;
                    }

                    if (p.slowAmount) {
                        e.slowTimer = p.slowDuration;
                        e.slowAmount = p.slowAmount;
                    }
                    if (p.shouldFreeze) {
                         e.freezeTimer = p.freezeDuration;
                         sounds.freeze();
                    }
                     
                    if (p.explosive) {
                        explosions.push({ x: p.x, y: p.y, radius: 0, maxRadius: p.explosionRadius, damage: p.damage / 2 });
                    }
                    
                    if (!p.pierce) {
                        if (p.type === 'ricochet-blade' && p.bouncesLeft > 0) {
                            p.hitEnemies.push(e.id);
                            p.bouncesLeft--;
                            let nextTarget = null;
                            let minDistance = Infinity;
                            enemies.forEach(otherEnemy => {
                                if (otherEnemy.hp > 0 && !p.hitEnemies.includes(otherEnemy.id)) {
                                    const dist = Math.hypot(e.x - otherEnemy.x, e.y - otherEnemy.y);
                                    if (dist < p.bounceRange && dist < minDistance) {
                                        minDistance = dist;
                                        nextTarget = otherEnemy;
                                    }
                                }
                            });
                            if (nextTarget) {
                                const angle = Math.atan2(nextTarget.y - e.y, nextTarget.x - e.x);
                                p.vx = Math.cos(angle) * 350;
                                p.vy = Math.sin(angle) * 350;
                            } else {
                                projectiles.splice(j, 1);
                            }
                        } else {
                            projectiles.splice(j, 1);
                        }
                    }
                }
            }

            if (e.hp <= 0) {
                 if (e.onDeath === 'explode') {
                    explosions.push({ x: e.x, y: e.y, radius: 0, maxRadius: 60, damage: e.damage });
                }
                if (player.chainReactionChance > 0 && Math.random() < player.chainReactionChance) {
                    explosions.push({ x: e.x, y: e.y, radius: 0, maxRadius: 50, damage: 15 });
                }

                xpGems.push({ x: e.x, y: e.y, value: e.xp, size: 5 + e.xp });
                enemies.splice(i, 1);
                lastKillTime = performance.now();
                comboCount++;
                comboUI.textContent = `${comboCount} COMBO`;
            }
        }
        
        // XP Gems
        for (let i = xpGems.length - 1; i >= 0; i--) {
            const gem = xpGems[i];
            const dist = Math.hypot(gem.x - player.x, gem.y - player.y);
            if (dist < player.pickupRadius) {
                const angle = Math.atan2(player.y - gem.y, player.x - gem.x);
                gem.x += Math.cos(angle) * 400 * dt;
                gem.y += Math.sin(angle) * 400 * dt;
                if (dist < 10) {
                    collectXP(gem.value);
                    xpGems.splice(i, 1);
                }
            }
        }
        
        // Explosions
        for (let i = explosions.length - 1; i >= 0; i--) {
            const exp = explosions[i];
            exp.radius += 200 * dt;
            if (exp.radius >= exp.maxRadius) {
                if (!exp.hasDamaged) {
                    enemies.forEach(e => {
                        if (Math.hypot(exp.x - e.x, exp.y - e.y) < exp.maxRadius) {
                            takeDamage(e, exp.damage);
                        }
                    });
                    exp.hasDamaged = true;
                }
                explosions.splice(i, 1);
            }
        }

        // Damage Texts
        for (let i = damageTexts.length - 1; i >= 0; i--) {
            const dt = damageTexts[i];
            dt.timer += 16;
            dt.y -= 1;
            dt.alpha -= 0.02;
            if (dt.alpha <= 0) {
                damageTexts.splice(i, 1);
            }
        }

        // Update UI Bars
        hpBar.style.width = `${(player.hp / player.maxHp) * 100}%`;
        xpBar.style.width = `${(player.xp / player.xpToNextLevel) * 100}%`;

        // Check for game over
        if (player.hp <= 0) {
            gameOver();
        }
    }

    function draw() {
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        ctx.save();

        if (screenShake.duration > 0) {
            const dx = (Math.random() - 0.5) * screenShake.magnitude;
            const dy = (Math.random() - 0.5) * screenShake.magnitude;
            ctx.translate(dx, dy);
            screenShake.duration -= 16; // Assuming 60fps
        }

        // Draw XP Gems
        xpGems.forEach(gem => {
            ctx.fillStyle = '#00ffff';
            ctx.beginPath();
            ctx.arc(gem.x, gem.y, gem.size / 2, 0, Math.PI * 2);
            ctx.fill();
        });

        // Draw Player
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(player.x - PLAYER_SIZE / 2, player.y - PLAYER_SIZE / 2, PLAYER_SIZE, PLAYER_SIZE);
        
        // Draw Player Shields
        if (player.shields > 0) {
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 2;
            const angle = (performance.now() / 1000) * 2;
            for (let i = 0; i < player.shields; i++) {
                const shieldAngle = angle + (i * (Math.PI * 2 / player.shields));
                const x = player.x + Math.cos(shieldAngle) * 40;
                const y = player.y + Math.sin(shieldAngle) * 40;
                ctx.beginPath();
                ctx.arc(x, y, 8, 0, Math.PI * 2);
                ctx.stroke();
            }
        }


        // Draw Enemies
        enemies.forEach(e => {
            ctx.fillStyle = e.color;
            if (e.freezeTimer > 0) ctx.fillStyle = '#a0d2eb';
            if (e.shape === 'square') {
                ctx.fillRect(e.x - e.size / 2, e.y - e.size / 2, e.size, e.size);
            } else if (e.shape === 'triangle') {
                ctx.beginPath();
                ctx.moveTo(e.x, e.y - e.size / 2);
                ctx.lineTo(e.x - e.size / 2, e.y + e.size / 2);
                ctx.lineTo(e.x + e.size / 2, e.y + e.size / 2);
                ctx.closePath();
                ctx.fill();
            }
        });

        // Draw Projectiles
        projectiles.forEach(p => {
             ctx.fillStyle = '#00ff00';
             if (p.type === 'ricochet-blade') {
                ctx.save();
                ctx.translate(p.x, p.y);
                ctx.rotate(p.rotation += p.rotationSpeed * (16/1000));
                ctx.fillRect(-5, -5, 10, 10);
                ctx.restore();
            } else {
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size || 5, 0, Math.PI * 2);
                ctx.fill();
            }
        });
        
        // Draw Explosions
        explosions.forEach(exp => {
            ctx.fillStyle = `rgba(255, 165, 0, ${1 - exp.radius / exp.maxRadius})`;
            ctx.beginPath();
            ctx.arc(exp.x, exp.y, exp.radius, 0, Math.PI * 2);
            ctx.fill();
        });
        
        // Draw Damage Texts
        damageTexts.forEach(dt => {
            ctx.fillStyle = `rgba(${dt.color}, ${dt.alpha})`;
            ctx.font = 'bold 16px Orbitron';
            ctx.textAlign = 'center';
            ctx.fillText(dt.text, dt.x, dt.y);
        });

        ctx.restore();
    }
    
    function gameLoop(timestamp) {
        if (!lastTime) lastTime = timestamp;
        if (isPaused || gameState !== 'playing') return;

        const dt = (timestamp - lastTime) / 1000;
        lastTime = timestamp;

        update(dt);
        draw();

        animationFrameId = requestAnimationFrame(gameLoop);
    }

    function gameOver() {
        gameState = 'gameover';
        cancelAnimationFrame(animationFrameId);
        gameOverScreen.classList.remove('hidden');
        gameOverTimeUI.textContent = `생존 시간: ${formatTime(gameTime)}`;
        const finalRank = getRank(gameTime);
        gameOverRankUI.textContent = `달성 랭크: ${finalRank.name}`;
        gameOverHighscoreUI.textContent = `최고 기록: ${formatTime(highScore)}`;
    }

    function startGame() {
        startScreen.classList.add('hidden');
        pauseButton.classList.remove('hidden');
        
        gameDifficulty = selectedDifficulty;
        player = createInitialPlayer(selectedDifficulty, selectedWeapon);
        
        // Reset game entities
        enemies = [];
        projectiles = [];
        enemyProjectiles = [];
        xpGems = [];
        healthPacks = [];
        explosions = [];
        damageTexts = [];
        blackHoles = [];
        
        // Reset game state
        gameTime = 0;
        lastSpawnTime = 0;
        spawnInterval = 2000;
        bossSpawned = false;
        comboCount = 0;
        
        gameState = 'playing';
        isPaused = false;
        lastTime = performance.now();
        animationFrameId = requestAnimationFrame(gameLoop);
    }
    
    function resetGame() {
        startScreen.classList.remove('hidden');
        pauseScreen.classList.add('hidden');
        levelUpScreen.classList.add('hidden');
        gameOverScreen.classList.add('hidden');
        pauseButton.classList.add('hidden');
        
        gameState = 'start';
        isPaused = false;
        gameTime = 0;
        timerUI.textContent = "00:00";
        currentRankUI.textContent = "";

        // Set default selections and update UI
        selectedDifficulty = '보통';
        selectedWeapon = 'machine-gun';

        difficultySelection.querySelectorAll('button').forEach(btn => {
            btn.classList.toggle('selected', btn.dataset.difficulty === selectedDifficulty);
        });
        weaponSelection.querySelectorAll('button').forEach(btn => {
            btn.classList.toggle('selected', btn.dataset.weapon === selectedWeapon);
        });

        updateStartButtonState();
    }

    function updateUI() {
        const formattedHighScore = formatTime(highScore);
        highscoreUI.textContent = `최고기록: ${formattedHighScore}`;
        startScreenHighscoreUI.textContent = `최고기록: ${formattedHighScore}`;
    }

    // --- Event Listeners ---
    
    // Selection buttons
    difficultySelection.querySelectorAll('button').forEach(button => {
        button.addEventListener('click', () => {
            selectedDifficulty = button.dataset.difficulty;
            difficultySelection.querySelectorAll('button').forEach(btn => btn.classList.remove('selected'));
            button.classList.add('selected');
            updateStartButtonState();
        });
    });

    weaponSelection.querySelectorAll('button').forEach(button => {
        button.addEventListener('click', () => {
            selectedWeapon = button.dataset.weapon;
            weaponSelection.querySelectorAll('button').forEach(btn => btn.classList.remove('selected'));
            button.classList.add('selected');
            updateStartButtonState();
        });
    });

    // Game state buttons
    startButton.addEventListener('click', startGame);
    restartButton.addEventListener('click', resetGame);
    pauseButton.addEventListener('click', togglePause);
    resumeButton.addEventListener('click', togglePause);
    restartPauseButton.addEventListener('click', () => {
        resetGame();
        startGame();
    });
    quitButton.addEventListener('click', resetGame);
    
    // Keyboard controls
    window.addEventListener('keydown', e => { keysPressed[e.key] = true; });
    window.addEventListener('keyup', e => { keysPressed[e.key] = false; });
    window.addEventListener('keydown', e => { if (e.key === 'Escape') togglePause(); });

    // --- Touch Controls ---
    function handleTouchStart(e) {
        e.preventDefault();
        const touch = e.changedTouches[0];
        if (!movementJoystickState.active) {
            movementJoystickState.active = true;
            movementJoystickState.touchId = touch.identifier;
            movementJoystickState.x = touch.clientX;
            movementJoystickState.y = touch.clientY;
            
            const rect = gameWrapper.getBoundingClientRect();
            movementJoystickUI.style.left = `${touch.clientX - rect.left - JOYSTICK_BASE_RADIUS}px`;
            movementJoystickUI.style.top = `${touch.clientY - rect.top - JOYSTICK_BASE_RADIUS}px`;
            movementJoystickUI.classList.remove('hidden');
            movementJoystickUI.classList.add('active');
        }
    }

    function handleTouchMove(e) {
        e.preventDefault();
        if (!movementJoystickState.active) return;
        
        const touch = Array.from(e.changedTouches).find(t => t.identifier === movementJoystickState.touchId);
        if (!touch) return;
        
        const dx = touch.clientX - movementJoystickState.x;
        const dy = touch.clientY - movementJoystickState.y;
        const distance = Math.hypot(dx, dy);
        
        const clampedDistance = Math.min(distance, JOYSTICK_MAX_OFFSET);
        const angle = Math.atan2(dy, dx);
        
        const handleX = clampedDistance * Math.cos(angle);
        const handleY = clampedDistance * Math.sin(angle);
        
        movementJoystickHandle.style.transform = `translate(${handleX}px, ${handleY}px)`;
        
        if (distance > JOYSTICK_DEAD_ZONE) {
            movementJoystickState.dx = handleX / JOYSTICK_MAX_OFFSET;
            movementJoystickState.dy = handleY / JOYSTICK_MAX_OFFSET;
        } else {
            movementJoystickState.dx = 0;
            movementJoystickState.dy = 0;
        }
    }

    function handleTouchEnd(e) {
        e.preventDefault();
        const touch = Array.from(e.changedTouches).find(t => t.identifier === movementJoystickState.touchId);
        if (touch) {
            movementJoystickState.active = false;
            movementJoystickState.touchId = null;
            movementJoystickState.dx = 0;
            movementJoystickState.dy = 0;
            movementJoystickUI.classList.add('hidden');
            movementJoystickUI.classList.remove('active');
            movementJoystickHandle.style.transform = `translate(0px, 0px)`;
        }
    }

    gameWrapper.addEventListener('touchstart', handleTouchStart, { passive: false });
    gameWrapper.addEventListener('touchmove', handleTouchMove, { passive: false });
    gameWrapper.addEventListener('touchend', handleTouchEnd, { passive: false });
    gameWrapper.addEventListener('touchcancel', handleTouchEnd, { passive: false });

    // --- Initialization ---
    updateUI();
    resetGame();
});
</script>

</body>
</html>
